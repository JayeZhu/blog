---
title: 数组算法-快慢双指针
date: 2025-10-22 22:57:06
permalink: /pages/eaa181/
categories:
  - 更多
tags:
  - 算法
  - 数组算法
---
在解决LeetCode数组问题时，双指针是一种非常高效且常用的技巧，特别是快慢双指针模式。这种模式通常用于原地修改数组，可以在不使用额外空间的情况下完成操作。本文将通过三个经典题目（第26题、第27题和第283题）来展示如何使用JavaScript中的快慢双指针来优化数组问题的解决方案。

## 第26题：删除有序数组中的重复项

### 题目描述
给你一个有序数组 `nums` ，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

### 示例
```
输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

### 使用快慢双指针的解决方案
由于数组是有序的，我们可以使用两个指针：慢指针指向已处理部分的末尾，快指针遍历整个数组。当快指针指向的元素与慢指针指向的元素不同时，将慢指针前进一步，并将快指针的值赋给慢指针。

### 代码实现
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    // 处理边界情况
    if (nums.length === 0) return 0;
    
    // 慢指针初始指向第一个元素
    let slow = 0;
    
    // 快指针从第二个元素开始遍历
    for (let fast = 1; fast < nums.length; fast++) {
        // 如果快指针指向的元素不等于慢指针指向的元素
        if (nums[fast] !== nums[slow]) {
            // 慢指针前进一步
            slow++;
            // 将快指针的值赋给慢指针
            nums[slow] = nums[fast];
        }
    }
    
    // 返回新长度（慢指针索引+1）
    return slow + 1;
};
```

### 复杂度分析
- 时间复杂度：O(n)，其中n是数组的长度。我们只需要遍历数组一次。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。

## 第27题：移除元素

### 题目描述
给你一个数组 `nums` 和一个值 `val`，你需要原地移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。

### 示例
```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。
```

### 使用快慢双指针的解决方案
我们可以使用两个指针：慢指针指向下一个要填充的位置，快指针遍历整个数组。当快指针指向的元素不等于val时，将其赋值给慢指针位置，然后慢指针前进一步。

### 代码实现
```javascript
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    // 慢指针初始指向0，表示下一个要填充的位置
    let slow = 0;
    
    // 快指针遍历整个数组
    for (let fast = 0; fast < nums.length; fast++) {
        // 如果快指针指向的元素不等于val
        if (nums[fast] !== val) {
            // 将其赋值给慢指针位置
            nums[slow] = nums[fast];
            // 慢指针前进一步
            slow++;
        }
    }
    
    // 返回新长度
    return slow;
};
```

### 复杂度分析
- 时间复杂度：O(n)，其中n是数组的长度。我们只需要遍历数组一次。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。

## 第283题：移动零

### 题目描述
给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

### 示例
```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

### 使用快慢双指针的解决方案
我们可以使用两个指针：慢指针指向下一个要放置非零元素的位置，快指针遍历整个数组。当快指针指向的元素不为0时，将其与慢指针位置的元素交换（如果两者不同），然后慢指针前进一步。

### 代码实现
```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    // 慢指针初始指向0，表示下一个要放置非零元素的位置
    let slow = 0;
    
    // 快指针遍历整个数组
    for (let fast = 0; fast < nums.length; fast++) {
        // 如果快指针指向的元素不为0
        if (nums[fast] !== 0) {
            // 交换慢指针和快指针的元素（如果两者不同）
            if (slow !== fast) {
                [nums[slow], nums[fast]] = [nums[fast], nums[slow]];
            }
            // 慢指针前进一步
            slow++;
        }
    }
};
```

### 复杂度分析
- 时间复杂度：O(n)，其中n是数组的长度。我们只需要遍历数组一次。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。

## 总结

快慢双指针是一种非常强大的数组处理技巧，特别适用于原地修改数组的场景。在上述三个题目中：

1. 第26题（删除有序数组中的重复项）展示了如何使用快慢双指针来处理有序数组的去重问题。
2. 第27题（移除元素）展示了如何使用快慢双指针来移除特定值的元素。
3. 第283题（移动零）展示了如何使用快慢双指针来重新排列数组中的元素。

快慢双指针的核心思想是：
- 慢指针通常指向当前处理的位置或下一个要填充的位置。
- 快指针用于遍历数组，寻找符合条件的元素。
- 当快指针找到符合条件的元素时，将其赋值或交换到慢指针位置，然后慢指针前进一步。

这种模式的优点是：
1. 空间效率高：不需要额外的数组空间，原地操作。
2. 时间效率高：通常只需要一次遍历，时间复杂度为O(n)。
3. 代码简洁：逻辑清晰，易于理解和实现。

在实际编程中，快慢双指针模式广泛应用于数组去重、元素移动、条件筛选等场景。