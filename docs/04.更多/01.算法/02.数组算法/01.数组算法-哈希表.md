---
title: 数组算法-哈希表
date: 2025-10-22 22:48:40
permalink: /pages/54c21f/
categories:
  - 更多
tags:
  - 算法
  - 数组算法
---
在解决数组算法问题时，哈希表是一种非常强大的工具，它可以帮助我们高效地查找、存储和操作数据。本文将通过LeetCode三个经典题目（第1题、第349题和第26题）来展示如何使用JavaScript中的哈希表（Map和Set）来优化数组问题的解决方案。

## 第1题：两数之和

### 题目描述
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。

### 示例
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

### 使用哈希表的解决方案
哈希表非常适合解决这个问题，因为它可以在O(1)时间内查找元素。我们可以遍历数组，对于每个元素，检查目标值减去当前元素的值是否存在于哈希表中。如果存在，我们找到了答案；否则，将当前元素及其索引存入哈希表。

### 代码实现
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    // 创建一个哈希表，用于存储数组元素及其索引
    const numMap = new Map();
    
    // 遍历数组
    for (let i = 0; i < nums.length; i++) {
        // 计算补数（target - 当前元素）
        const complement = target - nums[i];
        
        // 检查补数是否存在于哈希表中
        if (numMap.has(complement)) {
            // 如果存在，返回补数的索引和当前元素的索引
            return [numMap.get(complement), i];
        }
        
        // 如果不存在，将当前元素及其索引存入哈希表
        numMap.set(nums[i], i);
    }
    
    // 如果没有找到匹配的元素，返回空数组（虽然题目保证有解）
    return [];
};
```

### 复杂度分析
- 时间复杂度：O(n)，其中n是数组的长度。我们只需要遍历数组一次。
- 空间复杂度：O(n)，用于存储哈希表。

## 第349题：两个数组的交集

### 题目描述
给定两个数组，编写一个函数来计算它们的交集。

### 示例
```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

### 使用哈希表的解决方案
我们可以使用一个哈希表（Set）来存储第一个数组中的所有元素，然后遍历第二个数组，检查每个元素是否存在于Set中。如果存在，将该元素添加到结果数组中，并从Set中移除该元素，以避免重复。

### 代码实现
```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    // 创建一个Set，存储nums1中的所有元素
    const set1 = new Set(nums1);
    const result = [];
    
    // 遍历nums2
    for (const num of nums2) {
        // 如果当前元素存在于set1中
        if (set1.has(num)) {
            // 将其添加到结果数组
            result.push(num);
            // 从set1中移除，避免重复
            set1.delete(num);
        }
    }
    
    return result;
};
```

### 复杂度分析
- 时间复杂度：O(m + n)，其中m和n分别是两个数组的长度。
- 空间复杂度：O(min(m, n))，用于存储较小的数组。

## 第26题：删除有序数组中的重复项

### 题目描述
给你一个有序数组 `nums` ，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

### 示例
```
输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

### 使用哈希表的解决方案
虽然题目要求不使用额外空间，但我们可以使用哈希表来理解问题。在实际解决方案中，由于数组是有序的，我们可以使用双指针法。但为了展示哈希表的应用，我们可以先使用哈希表来记录已出现的元素，然后构建新数组。

### 代码实现
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    // 创建一个Set来存储已经出现的元素
    const seen = new Set();
    let writeIndex = 0;
    
    // 遍历数组
    for (let i = 0; i < nums.length; i++) {
        // 如果当前元素没有出现过
        if (!seen.has(nums[i])) {
            // 将其添加到Set中
            seen.add(nums[i]);
            // 将其写入到writeIndex位置
            nums[writeIndex] = nums[i];
            // 增加写索引
            writeIndex++;
        }
    }
    
    // 返回新数组的长度
    return writeIndex;
};
```

### 复杂度分析
- 时间复杂度：O(n)，其中n是数组的长度。
- 空间复杂度：O(n)，使用了一个Set来存储已出现的元素。注意，这不符合题目O(1)空间的要求，但展示了哈希表的应用。

## 总结

哈希表（在JavaScript中主要是Map和Set）是解决数组问题的强大工具，特别是在涉及查找、去重和计数等场景时。在上述三个题目中：

1. 第1题（两数之和）展示了如何使用哈希表来快速查找补数，从而将时间复杂度从O(n²)降低到O(n)。
2. 第349题（两个数组的交集）展示了如何使用Set来处理去重问题。
3. 第26题（删除有序数组中的重复项）虽然最优解是双指针法，但也可以通过哈希表来理解去重的概念。

在实际编程中，选择合适的数据结构是优化算法的关键。哈希表以其O(1)的平均查找时间，在许多场景下都能提供高效的解决方案。