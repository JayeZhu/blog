---
title: 数组算法-左右双指针
date: 2025-10-22 23:00:34
permalink: /pages/28eb68/
categories:
  - 更多
tags:
  - 算法
  - 数组算法
---
上一章讲解了快慢双指针，这一章介绍左右双指针模式。这种模式通常用于处理有序数组或需要从两端向中间遍历的场景。本文将通过两个经典题目（第167题和第977题）来展示如何使用JavaScript中的左右双指针来优化数组问题的解决方案。

## 第167题：两数之和 II - 输入有序数组

### 题目描述
给你一个下标从 1 开始的整数数组 `numbers` ，该数组已按非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 < numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

### 示例
```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

### 使用左右双指针的解决方案
由于数组是有序的，我们可以使用两个指针：左指针从数组开头开始，右指针从数组末尾开始。计算两指针所指元素的和：
- 如果和等于目标值，返回结果。
- 如果和小于目标值，左指针右移，增加和的值。
- 如果和大于目标值，右指针左移，减少和的值。

### 代码实现
```javascript
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
    // 初始化左右指针
    let left = 0;
    let right = numbers.length - 1;
    
    // 当左指针小于右指针时循环
    while (left < right) {
        // 计算两指针所指元素的和
        const sum = numbers[left] + numbers[right];
        
        // 如果和等于目标值，返回结果（注意题目要求下标从1开始）
        if (sum === target) {
            return [left + 1, right + 1];
        }
        // 如果和小于目标值，左指针右移
        else if (sum < target) {
            left++;
        }
        // 如果和大于目标值，右指针左移
        else {
            right--;
        }
    }
    
    // 题目保证有解，所以这里不会执行
    return [];
};
```

### 复杂度分析
- 时间复杂度：O(n)，其中n是数组的长度。最坏情况下，我们只需要遍历数组一次。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。

## 第977题：有序数组的平方

### 题目描述
给你一个按非递减顺序排序的整数数组 `nums`，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。

### 示例
```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]
```

### 使用左右双指针的解决方案
虽然我们可以先对每个元素平方，然后排序，但这样时间复杂度为O(n log n)。我们可以利用左右双指针来优化：
- 由于数组是有序的，平方后最大的值一定在原数组的两端。
- 我们可以使用两个指针：左指针从数组开头开始，右指针从数组末尾开始。
- 比较两指针所指元素的平方值，将较大的值放入结果数组的末尾，然后移动相应的指针。

### 代码实现
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortedSquares = function(nums) {
    // 初始化结果数组
    const result = new Array(nums.length);
    // 初始化左右指针和结果数组的填充位置
    let left = 0;
    let right = nums.length - 1;
    let position = nums.length - 1;
    
    // 当左指针小于等于右指针时循环
    while (left <= right) {
        // 计算两指针所指元素的平方
        const leftSquare = nums[left] * nums[left];
        const rightSquare = nums[right] * nums[right];
        
        // 如果左平方大于右平方
        if (leftSquare > rightSquare) {
            // 将左平方放入结果数组的当前位置
            result[position] = leftSquare;
            // 左指针右移
            left++;
        }
        // 如果右平方大于等于左平方
        else {
            // 将右平方放入结果数组的当前位置
            result[position] = rightSquare;
            // 右指针左移
            right--;
        }
        // 填充位置前移
        position--;
    }
    
    return result;
};
```

### 复杂度分析
- 时间复杂度：O(n)，其中n是数组的长度。我们只需要遍历数组一次。
- 空间复杂度：O(n)，用于存储结果数组。如果不考虑输出数组的空间，额外空间为O(1)。

## 第344题：反转字符串

### 题目描述
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

### 示例
```
输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

### 使用左右双指针的解决方案
我们可以使用两个指针：左指针从字符串开头开始，右指针从字符串末尾开始。每次交换两个指针所指的字符，然后两个指针相向而行，直到相遇或交叉。

### 代码实现
```javascript
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
    let left = 0;
    let right = s.length - 1;
    
    while (left < right) {
        // 交换左右指针所指的字符
        [s[left], s[right]] = [s[right], s[left]];
        // 左指针右移，右指针左移
        left++;
        right--;
    }
};
```

### 复杂度分析
- 时间复杂度：O(n)，其中n是字符串的长度。我们只需要遍历字符串的一半。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。

## 第125题：验证回文串

### 题目描述
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

### 示例
```
输入: "A man, a plan, a canal: Panama"
输出: true
解释："amanaplanacanalpanama" 是回文串
```

### 使用左右双指针的解决方案
我们可以使用两个指针：左指针从字符串开头开始，右指针从字符串末尾开始。每次比较两个指针所指的字符（忽略非字母数字字符和大小写），然后两个指针相向而行，直到相遇或交叉。

### 代码实现
```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    let left = 0;
    let right = s.length - 1;
    
    // 辅助函数：判断字符是否为字母或数字
    const isAlphaNumeric = (c) => {
        return /^[a-z0-9]$/i.test(c);
    };
    
    while (left < right) {
        // 跳过非字母数字字符
        while (left < right && !isAlphaNumeric(s[left])) {
            left++;
        }
        while (left < right && !isAlphaNumeric(s[right])) {
            right--;
        }
        
        // 比较字符（忽略大小写）
        if (s[left].toLowerCase() !== s[right].toLowerCase()) {
            return false;
        }
        
        // 左指针右移，右指针左移
        left++;
        right--;
    }
    
    return true;
};
```

### 复杂度分析
- 时间复杂度：O(n)，其中n是字符串的长度。我们只需要遍历字符串的一半。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。

## 总结

左右双指针是一种非常强大的数组处理技巧，特别适用于处理有序数组或需要从两端向中间遍历的场景。在上述四个题目中：

1. 第167题（两数之和 II - 输入有序数组）展示了如何使用左右双指针来在有序数组中查找两个数，使其和等于目标值。
2. 第977题（有序数组的平方）展示了如何利用左右双指针来高效地对平方后的数组进行排序。
3. 第344题（反转字符串）展示了如何使用左右双指针来原地反转字符串，交换两端的字符。
4. 第125题（验证回文串）展示了如何使用左右双指针来验证回文串，同时处理非字母数字字符和大小写问题。

左右双指针的核心思想是：
- 左指针从数组开头开始，右指针从数组末尾开始。
- 根据特定条件（如和大于/小于目标值，平方值大小等）移动指针。
- 逐渐缩小搜索范围，直到满足条件或遍历完整个数组。

这种模式的优点是：
1. 时间效率高：通常只需要一次遍历，时间复杂度为O(n)。
2. 空间效率高：通常只需要常数级别的额外空间（不考虑输出数组）。
3. 代码简洁：逻辑清晰，易于理解和实现。

在实际编程中，左右双指针模式广泛应用于有序数组的查找、排序、合并、字符串反转和回文验证等场景。

这样，你的左右双指针博客就包含了更多的实际应用案例，能够更全面地展示左右双指针的应用场景和实现方法。