---
title: 删除有序数组中的重复项
date: 2025-10-20 17:17:40
permalink: /pages/45c439/
categories:
  - 更多
tags:
  - 算法
  - 数组
---
# 删除有序数组中的重复项：三种高效解法详解

## 题目描述

给你一个 **有序** 数组 `nums` ，请你 **原地** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **原地修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

### 示例

**示例 1：**
```
输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**
```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ，并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

### 约束条件

- `1 <= nums.length <= 3 * 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 已按 **升序** 排列

## 解法一：双指针法

### 思路分析

由于数组是有序的，所有重复元素一定是连续的。我们可以使用双指针法：

1. 使用一个慢指针 `i` 指向当前不重复元素的位置
2. 使用一个快指针 `j` 遍历整个数组
3. 当 `nums[i]` 不等于 `nums[j]` 时，说明找到了新的不重复元素，将 `i` 后移一位，并将 `nums[j]` 的值赋给 `nums[i]`

### 代码实现

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  if (nums.length === 0) return 0;
  
  let i = 0; // 慢指针，指向不重复元素的位置
  
  for (let j = 1; j < nums.length; j++) {
    // 如果当前元素与前一个元素不同，说明找到了新的不重复元素
    if (nums[j] !== nums[i]) {
      i++; // 慢指针后移
      nums[i] = nums[j]; // 将新元素放到慢指针位置
    }
  }
  
  return i + 1; // 返回新数组长度
};
```

### 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组长度。我们只遍历一次数组。
- **空间复杂度**：O(1)，只使用了常数个额外空间。

### 优缺点

- **优点**：原地修改，不需要额外空间，时间效率高。
- **缺点**：需要修改原数组。

## 解法二：覆盖法

### 思路分析

这种方法与双指针法类似，但更直观。我们遍历数组，每当发现不重复的元素时，就将其移动到数组的前面。

### 代码实现

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  if (nums.length === 0) return 0;
  
  let writeIndex = 1; // 下一个不重复元素应该写入的位置
  
  for (let i = 1; i < nums.length; i++) {
    // 如果当前元素与前一个元素不同
    if (nums[i] !== nums[i - 1]) {
      nums[writeIndex] = nums[i]; // 将元素写入下一个位置
      writeIndex++; // 更新写入位置
    }
  }
  
  return writeIndex; // 返回新数组长度
};
```

### 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组长度。
- **空间复杂度**：O(1)，只使用了常数个额外空间。

### 优缺点

- **优点**：逻辑清晰，易于理解。
- **缺点**：与双指针法本质相同，没有性能优势。

## 解法三：ES6 Set方法

### 思路分析

虽然题目要求原地修改，但我们可以使用ES6的Set来展示一种不同的思路。这种方法不满足题目要求，但在实际开发中可能有用。

### 代码实现

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
  // 使用Set去重
  const uniqueNums = [...new Set(nums)];
  
  // 将去重后的数组复制回原数组
  for (let i = 0; i < uniqueNums.length; i++) {
    nums[i] = uniqueNums[i];
  }
  
  return uniqueNums.length;
};
```

### 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组长度。Set的去重操作是O(n)的。
- **空间复杂度**：O(n)，最坏情况下需要存储所有元素。

### 优缺点

- **优点**：代码简洁，易于实现。
- **缺点**：不满足题目要求，需要额外空间。

## 方法比较

| 方法 | 时间复杂度 | 空间复杂度 | 是否原地修改 |
|------|------------|------------|--------------|
| 双指针法 | O(n) | O(1) | 是 |
| 覆盖法 | O(n) | O(1) | 是 |
| ES6 Set方法 | O(n) | O(n) | 否 |

## 实际应用

### 示例：数据去重工具
客户提供的生产数据可能包含重复项，需要先进行去重处理：

```javascript
/**
 * 对有序数组进行去重处理
 * @param {number[]} sortedArray - 已排序的数组
 * @return {Object} 包含去重后数组和新长度的对象
 */
function removeDuplicatesFromSortedArray(sortedArray) {
  const length = removeDuplicates(sortedArray);
  return {
    array: sortedArray.slice(0, length), // 只返回有效部分
    length: length
  };
}

// 使用示例
const sensorData = [1, 1, 2, 2, 2, 3, 4, 4, 5];
const result = removeDuplicatesFromSortedArray(sensorData);

console.log('去重后的数据:', result.array);
console.log('新长度:', result.length);

// 输出:
// 去重后的数据: [1, 2, 3, 4, 5]
// 新长度: 5
```

### 示例：实时数据流处理

在实时数据流处理中，可能需要对接收到的有序数据进行去重：

```javascript
class DataStreamProcessor {
  constructor() {
    this.buffer = [];
  }
  
  // 添加新数据到缓冲区（假设数据是有序的）
  addData(data) {
    this.buffer.push(...data);
    // 对缓冲区进行去重
    const newLength = removeDuplicates(this.buffer);
    this.buffer = this.buffer.slice(0, newLength);
  }
  
  // 获取处理后的数据
  getData() {
    return [...this.buffer];
  }
}

// 使用示例
const processor = new DataStreamProcessor();

// 模拟接收数据流
processor.addData([1, 1, 2, 3]);
console.log('第一次处理后:', processor.getData()); // [1, 2, 3]

processor.addData([3, 4, 4, 5]);
console.log('第二次处理后:', processor.getData()); // [1, 2, 3, 4, 5]
```

## 总结

删除有序数组中的重复项是一个经典算法问题，主要考察对数组操作和双指针技巧的理解。在三种解法中，双指针法是最优解，因为它满足题目要求的所有条件：原地修改、O(1)额外空间和O(n)时间复杂度。

在实际开发中，如果不需要原地修改，使用ES6的Set方法可能更简洁。但在算法面试中，通常需要展示对双指针等基础算法技巧的掌握，因此双指针法是最佳选择。
