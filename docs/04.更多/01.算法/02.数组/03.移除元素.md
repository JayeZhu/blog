---
title: 移除元素
date: 2025-10-21 23:51:46
permalink: /pages/0a1978/
categories:
  - 更多
tags:
  - 算法
  - 数组
---
## 题目描述

给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

## 示例

示例 1：
```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
```

示例 2：
```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 4, 0, 3。
```

## JavaScript解法

### 方法一：双指针法（推荐）

这是解决这类问题的经典方法，使用两个指针：
- 一个指针（慢指针）用于构建结果数组
- 另一个指针（快指针）用于遍历原数组

```javascript
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    // 慢指针，用于构建结果数组
    let slow = 0;
    
    // 快指针遍历数组
    for (let fast = 0; fast < nums.length; fast++) {
        // 如果当前元素不等于要删除的值
        if (nums[fast] !== val) {
            // 将其放入结果数组
            nums[slow] = nums[fast];
            // 慢指针向前移动
            slow++;
        }
    }
    
    return slow;
};
```

### 方法二：双指针优化

当要删除的元素很少时，方法一会进行很多不必要的复制操作。我们可以优化一下：当遇到要删除的元素时，将其与最后一个元素交换，然后减少数组长度。

```javascript
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let i = 0;
    let n = nums.length;
    
    while (i < n) {
        // 如果当前元素是要删除的值
        if (nums[i] === val) {
            // 将其与最后一个元素交换
            nums[i] = nums[n - 1];
            // 数组长度减1
            n--;
        } else {
            // 否则继续检查下一个元素
            i++;
        }
    }
    
    return n;
};
```

## 复杂度分析

### 方法一：
- 时间复杂度：O(n)，其中 n 是数组的长度。我们最多遍历数组一次。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。

### 方法二：
- 时间复杂度：O(n)，最坏情况下（所有元素都要删除）需要遍历整个数组。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。

## 示例测试

```javascript
// 测试方法一
let nums1 = [3,2,2,3];
let len1 = removeElement(nums1, 3);
console.log(len1, nums1.slice(0, len1)); // 输出: 2 [2,2]

let nums2 = [0,1,2,2,3,0,4,2];
let len2 = removeElement(nums2, 2);
console.log(len2, nums2.slice(0, len2)); // 输出: 5 [0,1,3,0,4]

// 测试方法二
let nums3 = [3,2,2,3];
let len3 = removeElement(nums3, 3);
console.log(len3, nums3.slice(0, len3)); // 输出: 2 [2,2]

let nums4 = [0,1,2,2,3,0,4,2];
let len4 = removeElement(nums4, 2);
console.log(len4, nums4.slice(0, len4)); // 输出: 5 [0,1,4,0,3] (顺序可能不同)
```

## 两种方法的选择

- 方法一（简单双指针）适用于要删除的元素较多的情况，因为它保持了元素的相对顺序。
- 方法二（优化双指针）适用于要删除的元素较少的情况，因为它减少了不必要的元素复制操作。

## 解题思路

这道题的关键在于理解"原地修改"和"不需要考虑数组中超出新长度后面的元素"这两个要求。双指针法是解决这类问题的经典方法：

1. 方法一使用快慢指针，快指针遍历原数组，慢指针构建新数组。当快指针指向的元素不是要删除的值时，将其复制到慢指针位置，然后慢指针前进。

2. 方法二是一个巧妙的优化，当发现要删除的元素时，直接用数组末尾的元素覆盖它，然后数组长度减1。这种方法虽然会改变元素的顺序，但减少了不必要的复制操作。

## 总结

这道题考察了数组操作和双指针技巧，是LeetCode中的基础题。通过这道题，我们可以学到：

1. 双指针技巧在数组操作中的应用
2. 如何在原地修改数组
3. 如何优化算法以减少不必要的操作

这些技巧在解决其他数组问题时也很有用，比如删除排序数组中的重复项、合并两个有序数组等。