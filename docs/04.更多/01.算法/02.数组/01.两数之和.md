---
title: 两数之和
date: 2025-10-20 16:42:09
permalink: /pages/28a53f/
categories:
  - 更多
  - 算法
  - 数组
tags:
  - 
---
## 题目描述

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。你可以按任意顺序返回答案。

### 示例

**示例 1：**
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**
```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**
```
输入：nums = [3,3], target = 6
输出：[0,1]
```

### 约束条件

- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- 只会存在一个有效答案

## 解法一：暴力枚举

### 思路分析

最直观的方法是使用双重循环遍历数组，检查每一对数字的和是否等于目标值。外层循环固定第一个数字，内层循环寻找第二个数字。

### 代码实现

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
  for(let i = 0; i < nums.length; i++) {
    for(let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }
};
```

### 复杂度分析

- **时间复杂度**：O(n²)，其中 n 是数组长度。最坏情况下需要检查所有可能的数对。
- **空间复杂度**：O(1)，只使用了常数个额外空间。

### 优缺点

- **优点**：实现简单直观，不需要额外数据结构。
- **缺点**：时间复杂度高，对于大数组效率低下。

## 解法二：哈希表

### 思路分析

我们可以使用哈希表（在JavaScript中是Map对象）来存储已经遍历过的元素及其索引。在遍历数组时，对于每个元素，检查其与目标值的差值是否已经在哈希表中。如果存在，则找到了答案；否则，将当前元素及其索引存入哈希表。

### 代码实现

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
  const map = new Map();
  for(let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    map.set(nums[i], i);
  }
};
```

### 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组长度。我们只遍历一次数组，哈希表的查找和插入操作平均时间复杂度为O(1)。
- **空间复杂度**：O(n)，最坏情况下需要存储所有元素。

### 优缺点

- **优点**：时间效率高，只需一次遍历。
- **缺点**：需要额外的空间存储哈希表。

## 解法三：双指针

### 思路分析

双指针法需要先对数组进行排序，然后使用两个指针分别指向数组的开始和结束。根据两个指针所指元素之和与目标值的关系，移动指针：

- 如果和等于目标值，找到答案。
- 如果和小于目标值，移动左指针向右。
- 如果和大于目标值，移动右指针向左。

**注意**：由于排序会改变原始数组的索引，我们需要在排序前保存原始索引。

### 代码实现

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
  nums.sort((a, b) => a - b);
  let left = 0;
  let right = nums.length - 1;
  while(left < right) {
    const sum = nums[left] + nums[right];
    if (sum === target) {
      return [left, right];
    } else if (sum < target) {
      left++;
    } else {
      right--;
    }
  }
};
```

### 复杂度分析

- **时间复杂度**：O(n log n)，其中 n 是数组长度。排序的时间复杂度为O(n log n)，双指针遍历的时间复杂度为O(n)。
- **空间复杂度**：O(n)，需要额外空间存储索引数组。

### 优缺点

- **优点**：不需要哈希表，空间效率较高。
- **缺点**：由于需要排序，时间复杂度高于哈希表法。

## 方法比较

| 方法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|------------|------------|----------|
| 暴力枚举 | O(n²) | O(1) | 小规模数据，简单实现 |
| 哈希表 | O(n) | O(n) | 大多数场景，特别是大数据量 |
| 双指针 | O(n log n) | O(n) | 需要额外考虑空间优化的场景 |

## 实际应用

### 示例：电商购物车

假设你在开发一个电商网站，需要实现一个功能：在购物车中找到两件商品，使其总价等于用户的预算。

```javascript
/**
 * 在购物车中找到总价等于预算的两件商品
 * @param {Array} cart - 购物车商品数组，每个商品包含price属性
 * @param {number} budget - 用户预算
 * @return {Array} 两件商品的索引，如果没有则返回空数组
 */
function findTwoItemsWithinBudget(cart, budget) {
  const map = new Map();
  
  for (let i = 0; i < cart.length; i++) {
    const remainingBudget = budget - cart[i].price;
    
    if (map.has(remainingBudget)) {
      return [map.get(remainingBudget), i];
    }
    
    map.set(cart[i].price, i);
  }
  
  return []; // 没有找到符合条件的商品
}

// 使用示例
const shoppingCart = [
  { name: '商品A', price: 25 },
  { name: '商品B', price: 40 },
  { name: '商品C', price: 15 },
  { name: '商品D', price: 30 }
];

const budget = 55;
const result = findTwoItemsWithinBudget(shoppingCart, budget);

if (result.length > 0) {
  console.log(`找到了两件商品：${shoppingCart[result[0]].name} 和 ${shoppingCart[result[1]].name}`);
} else {
  console.log('没有找到符合条件的商品组合');
}
```

## 总结

两数之和问题是算法面试中的经典题目，通过这道题可以增加对数组操作、哈希表和双指针等基本数据结构和算法的掌握程度。

在实际开发中，哈希表法通常是最佳选择，因为它在时间效率上表现最好，而且代码实现简洁。双指针法虽然时间复杂度稍高，但在某些需要优化空间使用的场景下也是一个不错的选择。暴力法则主要适用于教学目的或者数据规模很小的情况。