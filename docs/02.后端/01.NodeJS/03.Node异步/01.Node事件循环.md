---
title: Node事件循环
date: 2023-10-13 17:53:05
permalink: /pages/4e059b/
categories:
  - 后端
tags:
  - NodeJS
  - Node异步
---

## 同步与异步

Node.js 的异步特性是其核心灵魂，也是它高性能的关键所在。简单来说，Node.js 的异步编程是一种编程模式，它允许程序在等待诸如文件读写、网络请求等耗时操作完成的同时，继续处理其他任务，而不是干等着什么都不做。

### 同步与异步的区别

| 特性 | 同步模式 (Synchronous) | 异步模式 (Asynchronous) |
|------|------------------------|--------------------------|
| 执行方式 | **顺序执行**：一个任务完成后，才能开始下一个任务。 | **并发执行**：发起一个任务后，无需等待其完成，立即继续执行后续代码。 |
| 线程阻塞 | **阻塞**：在执行耗时操作（如读取大文件）时，整个线程会被挂起，无法处理其他请求。 | **非阻塞**：主线程不会因耗时操作而停滞，可以继续处理其他任务，操作完成后通过回调等方式通知。 |
| 性能与资源 | 资源利用率较低，尤其在I/O密集型场景下，线程大量时间处于空闲等待状态。 | 资源利用率高，单线程即可处理大量并发连接，特别适合I/O密集型应用。 |
| 代码风格 | 代码流程直观，符合线性思维。 | 代码流程非线性的，需要通过回调、Promise或async/await来管理执行顺序。 |

## 什么是事件循环？

Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现的。

**事件循环**是 Node.js 实现非阻塞 I/O 操作的基石，尽管 JavaScript 是单线程的，事件循环允许 Node.js 执行非阻塞操作，如读写文件、网络请求等，不会导致程序停止等待操作完成。

事件循环的本质是一个持续运行的循环，它不断地检查是否有待处理的事件或回调函数，然后按特定顺序执行它们。Node.js 单线程类似进入一个 while(true) 的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者。

### 为什么需要事件循环？

JavaScript 是单线程的编程语言，只有一个调用栈，在同一时间只能做一件事，按顺序来处理事件。但前端的某些任务是非常耗时的，比如网络请求、定时器和事件监听，如果让它们和别的任务一样，都老老实实排队等待执行的话，执行效率会非常低，甚至导致页面的假死。在遇到耗时的任务（异步任务）时，js 并没有阻塞，还会继续执行，这就是因为有事件循环机制，实现了单线程非阻塞的方法。

在服务器端，Node.js 需要处理大量 I/O 操作（如文件读写、网络请求等）。如果使用同步方式，会导致线程阻塞，无法处理其他请求。事件循环机制使得 Node.js 可以通过将操作转移到系统内核中来执行非阻塞 I/O 操作。由于大多数现代内核是多线程的，因此它们可以处理在后台执行的多个操作。当这些操作之一完成时，内核会告诉 Node.js，以便可以将适当的回调添加到轮询队列中以最终执行。

## 事件循环的六个阶段详解

Node.js 的事件循环分为六个不同的阶段，每个阶段都有一个 FIFO（先进先出）队列来执行回调函数。下面是这六个阶段的详细说明：

| 阶段 | 描述 | 主要 API |
|------|------|---------|
| timers | 执行 setTimeout 和 setInterval 的回调 | setTimeout, setInterval |
| pending callbacks | 执行延迟到下一个循环迭代的 I/O 回调 | 系统操作错误回调 |
| idle, prepare | 内部使用 | 内部使用 |
| poll | 检索新的 I/O 事件，执行 I/O 相关回调 | 文件读写、网络请求等 |
| check | 执行 setImmediate 的回调 | setImmediate |
| close callbacks | 执行关闭事件的回调，如 socket.on('close') | socket 关闭事件 |

### timers 阶段

timers 是事件循环的第一个阶段，Node.js 会去检查是否有已经过期的 timer（定时器），如果有，就将它的回调放入队列中执行。但需要注意的是，Node.js 并不能保证 timer 在预设时间到了就会立即执行回调，因为 Node.js 对 timer 的过期检查可能受到机器上其他运行程序的影响，或者是当前主线程不空闲的情况。

例如，如果你设置了一个 100ms 后执行的定时器，但同步代码执行需要 200ms，那么定时器的回调会在同步代码执行完成后才执行，导致实际延迟超过预设值。

```javascript
const start = Date.now();

setTimeout(() => {
  console.log(`实际延迟: ${Date.now() - start}ms`);
}, 100);

// 模拟耗时操作
let i = 0;
while (i < 1000000000) { i++; }
```

### pending 阶段
pending callbacks 阶段执行一些系统调用的错误回调，例如网络通信的错误回调。大多数情况下，在轮询 I/O 后立即调用所有 I/O 回调，但某些情况下，这类回调会推迟到下一次循环迭代执行。

### poll 阶段
poll 阶段是事件循环中最复杂且最重要的阶段，它有两个主要功能：

处理 poll 阶段的任务队列
当有了已经超时的 timer 时执行其回调函数
在 poll 阶段，事件循环会检查是否有新的 I/O 事件需要处理。如果 poll 队列不为空，事件循环会同步执行队列中的回调直到队列为空或达到系统限制。如果 poll 队列为空，事件循环会在此处等待，具体行为取决于是否有其他任务待处理：

如果设置了 setImmediate 回调，事件循环会结束 poll 阶段进入 check 阶段
如果没有 setImmediate 回调，但有定时器即将到期，事件循环会等待定时器到期然后进入 timers 阶段
如果既没有 setImmediate 回调也没有即将到期的定时器，事件循环会阻塞在 poll 阶段等待新的 I/O 事件
### check 阶段
check 阶段主要执行 setImmediate 的回调函数。setImmediate 设计为在当前 poll 阶段完成后立即执行。当 poll 阶段空闲（即没有更多 I/O 事件需要处理）且存在 setImmediate 回调时，事件循环会直接进入 check 阶段执行这些回调。

### close 阶段
close callbacks 阶段执行一些与关闭相关的回调函数，如 socket.on('close', ...) 这样的回调。当 socket 或句柄突然关闭时（例如 socket.destroy()），'close' 事件会在这个阶段发出。

## 微任务（Microtasks）与 process.nextTick
除了上述六个主要阶段外，事件循环还有一个重要的概念：微任务（Microtasks）。微任务包括 Promise 回调和 queueMicrotask API，以及 Node.js 特有的 process.nextTick。

### 微任务的执行时机
在 Node.js 的事件循环中，每个阶段执行完成后，在移动到下一个阶段之前，都会先清空微任务队列。但 process.nextTick 和 Promise 微任务之间有重要区别：

- process.nextTick：在当前阶段结束后立即执行，优先级高于 Promise
- Promise 微任务：在 process.nextTick 队列清空后执行
```javascript
// 示例：微任务执行顺序
setImmediate(() => console.log('setImmediate'));
process.nextTick(() => console.log('nextTick 1'));
Promise.resolve().then(() => console.log('Promise 1'));
process.nextTick(() => console.log('nextTick 2'));
Promise.resolve().then(() => console.log('Promise 2'));

// 输出顺序：
// nextTick 1
// nextTick 2
// Promise 1
// Promise 2
// setImmediate
```
### process.nextTick 与 setImmediate 的命名困惑
这两个 API 的命名经常让人困惑：

- process.nextTick：在当前阶段"立即"执行，在所有微任务中最先执行
- setImmediate：在事件循环的 check 阶段执行，相对较"晚"

实际上，setImmediate 应该叫 setNextIteration，而 process.nextTick 应该叫 setImmediate 更为合适。但这是历史遗留问题，不太可能改变。

### Node.js 11.x 版本前后的重要变化
在 Node.js v11.x 之前，事件循环在每个阶段会执行所有可执行的宏任务，然后清空微任务队列。但从 v11.x 开始，改为与浏览器一致的行为：每个阶段执行一个宏任务后就会清空微任务队列。

```javascript
// Node.js 11.x+ 行为
setImmediate(() => {
  console.log('setImmediate1');
  Promise.resolve().then(() => console.log('Promise microtask 1'));
});
setImmediate(() => {
  console.log('setImmediate2');
  Promise.resolve().then(() => console.log('Promise microtask 2'));
});

// v11.x之前输出：setImmediate1, setImmediate2, Promise microtask 1, Promise microtask 2
// v11.x之后输出：setImmediate1, Promise microtask 1, setImmediate2, Promise microtask 2
```
这一变化使得微任务能够更及时地执行，避免了微任务被长时间阻塞的问题。

## 代码示例与执行顺序分析
### setTimeout vs setImmediate
```javascript
setTimeout(() => console.log('setTimeout'));
setImmediate(() => console.log('setImmediate'));

// 输出顺序可能是：
// setTimeout -> setImmediate
// 或者
// setImmediate -> setTimeout
```
为什么输出顺序不确定？因为 setTimeout 的延迟时间设为 0 时，实际会被强制设置为 1ms。事件循环启动的时间会影响哪个先到期。但如果将这两个调用放在 I/O 循环内，顺序就固定了：

```javascript
const fs = require('fs');
fs.readFile(__filename, () => {
  setTimeout(() => console.log('setTimeout'));
  setImmediate(() => console.log('setImmediate')); // 总是先输出
});
```
这是因为 在 I/O 回调中，setImmediate 总是在当前 poll 阶段后的 check 阶段执行，而 setTimeout 需要等到下一次事件循环的 timers 阶段。

### 理解事件循环的完整流程
```javascript
const start = Date.now();

console.log('开始'); // 同步任务

setTimeout(() => {
  console.log(`定时器回调，延迟: ${Date.now() - start}ms`);
}, 100);

process.nextTick(() => {
  console.log('process.nextTick回调');
});

fs.readFile(__filename, () => {
  console.log('文件读取完成');
  
  setImmediate(() => {
    console.log('setImmediate在I/O回调内');
  });
  
  process.nextTick(() => {
    console.log('process.nextTick在I/O回调内');
  });
});

console.log('结束'); // 同步任务

// 预期输出顺序：
// 开始
// 结束
// process.nextTick回调
// 定时器回调，延迟: ~100ms
// 文件读取完成
// process.nextTick在I/O回调内
// setImmediate在I/O回调内
```
### 事件循环流程图解
```text

┌───────────────────────────┐
│           开始             |
└─────────────┬─────────────┘
              │
┌─────────────▼─────────────┐
│        同步代码执行         │
└─────────────┬─────────────┘
              │
┌─────────────▼─────────────┐
│   process.nextTick队列     │
└─────────────┬─────────────┘
              │
┌─────────────▼─────────────┐
│      Promise微任务队列      │
└─────────────┬─────────────┘
              │
┌─────────────▼─────────────┐
│       事件循环开始          │
└─────────────┬─────────────┘
              │
      ┌───────▼───────┐
      │   timers阶段   │ ◄─── 检查过期定时器
      └───────┬───────┘
              │
      ┌───────▼───────┐
      │  pending阶段   │ ◄─── 处理上一轮遗留的I/O回调
      └───────┬───────┘
              │
      ┌───────▼───────┐
      │    poll阶段    │ ◄─── 检索新I/O事件，可能阻塞
      └───────┬───────┘
              │
      ┌───────▼───────┐
      │   check阶段    │ ◄─── 执行setImmediate回调
      └───────┬───────┘
              │
      ┌───────▼───────┐
      │   close阶段    │ ◄─── 执行关闭事件回调
      └───────┬───────┘
              │
              ▼
┌───────────────────────────┐
│           结束             │
└───────────────────────────┘
```

## 实践应用与常见问题
实践应用与常见问题
避免I/O饥饿（Starvation）
递归调用 process.nextTick 会导致 I/O 饥饿，因为每次事件循环阶段之间都会清空 nextTick 队列，导致 I/O 回调无法得到执行。

```javascript
// 错误示例：会导致I/O饥饿
let count = 0;
function run() {
  if (count >= 1000) return;
  count++;
  
  fs.readFile(__filename, () => {
    console.log('文件读取完成'); // 这将很难执行
  });
  
  process.nextTick(run); // 递归调用，阻止事件循环进入下一阶段
}
run();

// 正确做法：使用setImmediate
function runSafe() {
  if (count >= 1000) return;
  count++;
  
  fs.readFile(__filename, () => {
    console.log('文件读取完成'); // 可以正常执行
  });
  
  setImmediate(runSafe); // 在下一次事件循环中执行，不会阻塞I/O
}
```
### 选择合适的定时API
| API | 执行时机 | 适用场景 |
|-----|---------|---------|
| process.nextTick | 当前阶段结束后立即执行 | 需要尽快执行的用户回调 |
| Promise.then | nextTick后执行 | 异步流程控制，错误处理 |
| setImmediate | 当前事件循环的check阶段 | 在I/O操作后但不太紧急的任务 |
| setTimeout | 指定延迟后（可能不精确） | 需要延迟执行的任务 |

### 性能优化建议
- 避免阻塞事件循环：长时间运行的同步代码会阻止事件循环处理其他任务
- 合理使用微任务：微任务适合异步流程控制，但不宜过多递归
- 注意定时器精度：高精度定时需求考虑其他方案（如worker线程）

监控事件循环延迟：通过定期检查定时器实际执行时间与预期时间的差异来监控系统负载

## 结语
Node.js的事件循环机制是其异步非阻塞I/O的基石，深入理解它对于编写高性能、可靠的Node.js应用至关重要。通过掌握事件循环的六个阶段、微任务执行时机以及不同API的特性，开发者可以更好地优化代码结构，避免常见的性能陷阱。

记住，事件循环虽然复杂，但遵循确定的规则。通过实践和调试，你可以逐渐掌握这一强大机制，构建出更高效的Node.js应用。