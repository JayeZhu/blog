---
title: Node异步控制
date: 2025-10-14 18:28:35
permalink: /pages/3fe632/
categories:
  - 后端
tags:
  - NodeJS
  - Node异步
---

:::tip
平常开发过程中，存在很多异步操作共存的情况，需要对这些异步操作进行控制，比如并发控制、顺序控制等。
:::

## 顺序控制

### Promise

```js
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p1')
  }, 1000)
})

const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p2')
  }, 2000)
})

p1.then((res) => {
  console.log(res)
  return p2
}).then((res) => {
  console.log(res)
})
```

## 并发控制

### Promise.all

```js
const promises = [
  fetch('/api/user'),
  fetch('/api/posts'),
  fetch('/api/comments')
];

Promise.all(promises)
  .then(results => {
    // 所有请求都成功
    console.log(results);
  })
  .catch(err => {
    // 任何一个请求失败都会进入这里
    console.error(err);
  });
```

### 特点
- 并行执行：所有 Promise 同时启动
- 全有或全无：要么全部成功，要么全部失败
- 快速失败：任何一个 Promise 失败，立即 reject
- 结果保持顺序：结果数组顺序与 Promise 数组顺序一致

## 竞争控制

### Promise.race
```js
const race = Promise.race([
  fetch('/api/fast'),
  fetch('/api/slow'),
  new Promise((_, reject) => 
    setTimeout(() => reject(new Error('超时')), 5000)
  )
]);

race
  .then(result => console.log(result))
  .catch(err => console.error(err));
```

### 特点
- 竞争机制：返回最快的结果
- 不分胜负：只要有一个完成，立即返回
- 保持原样：成功就成功，失败就失败
- 一次性：其他 Promise 不会取消，继续执行

## 并行状态收集控制
### Promise.allSettled

```js
const promises = [
  Promise.resolve('成功'),
  Promise.reject('失败'),
  Promise.resolve('又成功')
];

Promise.allSettled(promises)
  .then(results => {
    results.forEach(result => {
      if (result.status === 'fulfilled') {
        console.log('成功:', result.value);
      } else {
        console.log('失败:', result.reason);
      }
    });
  });
```

### 特点
- 全部等待：等待所有 Promise 完成
- 不关心结果：成功失败都接收
- 状态记录：记录每个 Promise 的最终状态
- 完整性：提供完整的执行结果


## 对比
| 特性 | Promise.all | Promise.race | Promise.allSettled | Promise链式调用 |
|------|------------|-------------|-------------------|----------------|
| 控制类型 | 并行聚合 | 竞争 | 并行状态收集 | 顺序控制 |
| 失败处理 | 任一失败则整体失败 | 最快的结果决定整体 | 记录所有状态 | 链式传递失败 |
| 返回时机 | 全部完成 | 任意完成 | 全部完成 | 前一个完成 |
| 结果格式 | 成功数组 | 单个结果 | 状态对象数组 | 单个结果 |
| 使用场景 | 需要全部成功 | 超时/多源获取 | 允许部分失败 | 需要顺序执行 |


## 综合场景
```js
// 综合应用示例
class AsyncController {
  async fetchDataWithFallback() {
    // 使用 race 实现超时控制
    const data = await Promise.race([
      this.fetchFromPrimary(),
      this.timeout(5000)
    ]);

    // 使用 allSettled 处理相关数据
    const related = await Promise.allSettled([
      this.fetchRelated1(data.id),
      this.fetchRelated2(data.id),
      this.fetchRelated3(data.id)
    ]);

    // 使用 all 处理必须成功的操作
    const [processed, saved] = await Promise.all([
      this.processData(data),
      this.saveData(data)
    ]);

    return { data, related, processed, saved };
  }

  timeout(ms) {
    return new Promise((_, reject) =>
      setTimeout(() => reject(new Error('超时')), ms)
    );
  }
}
```