---
title: Node事件
date: 2025-10-15 10:51:26
permalink: /pages/39eedd/
categories:
  - 后端
tags:
  - NodeJS
  - Node核心模块深入
---

## 1. EventEmitter 类

### 1.1 基本概念

EventEmitter 是 Node.js 中事件驱动架构的核心，它提供了事件监听和触发的功能。所有能触发事件的对象都是 EventEmitter 类的实例。

```javascript
const EventEmitter = require('events');

// 创建 EventEmitter 实例
const emitter = new EventEmitter();
```

### 1.2 基本属性和方法

```javascript
// 查看事件监听器数量
console.log(emitter.listenerCount('event')); // 0

// 获取事件名数组
console.log(emitter.eventNames()); // []

// 设置最大监听器数量
emitter.setMaxListeners(10);
console.log(emitter.getMaxListeners()); // 10
```

## 2. 自定义事件

### 2.1 创建自定义事件发射器

```javascript
const EventEmitter = require('events');

class MyEmitter extends EventEmitter {
  constructor() {
    super();
    this.id = Math.random();
  }
}

// 创建实例
const myEmitter = new MyEmitter();

// 触发自定义事件
myEmitter.emit('customEvent', 'arg1', 'arg2');
```

### 2.2 事件参数传递

```javascript
// 传递多个参数
myEmitter.on('userData', (user, action) => {
  console.log(`用户 ${user.name} 执行了 ${action}`);
});

myEmitter.emit('userData', 
  { name: 'John', age: 30 }, 
  '登录'
);
```

## 3. 事件监听与触发

### 3.1 基本监听和触发

```javascript
const emitter = new EventEmitter();

// 监听事件
emitter.on('event', () => {
  console.log('事件触发！');
});

// 触发事件
emitter.emit('event');
```

### 3.2 多次监听

```javascript
// 可以添加多个监听器
emitter.on('event', () => {
  console.log('第一个监听器');
});

emitter.on('event', () => {
  console.log('第二个监听器');
});

// 触发时所有监听器都会执行
emitter.emit('event');
```

### 3.3 一次性监听

```javascript
// 使用 once 监听，触发后自动移除
emitter.once('event', () => {
  console.log('只会触发一次');
});

emitter.emit('event'); // 输出
emitter.emit('event'); // 不会输出
```

### 3.4 监听器管理

```javascript
function listener1() {
  console.log('监听器1');
}

function listener2() {
  console.log('监听器2');
}

// 添加监听器
emitter.on('event', listener1);
emitter.on('event', listener2);

// 移除特定监听器
emitter.removeListener('event', listener1);

// 移除所有监听器
emitter.removeAllListeners('event');

// 获取所有监听器
const listeners = emitter.listeners('event');
console.log(listeners);
```

## 4. 错误事件处理

### 4.1 错误事件特殊处理

```javascript
const emitter = new EventEmitter();

// 错误事件必须有监听器
emitter.on('error', (err) => {
  console.error('捕获到错误:', err);
});

// 触发错误事件
emitter.emit('error', new Error('出错了！'));
```

### 4.2 错误处理最佳实践

```javascript
class SafeEmitter extends EventEmitter {
  emit(eventName, ...args) {
    if (eventName === 'error') {
      if (!this.listenerCount('error')) {
        console.error('未处理的错误事件:', args[0]);
        return false;
      }
    }
    return super.emit(eventName, ...args);
  }
}

const safeEmitter = new SafeEmitter();
safeEmitter.emit('error', new Error('测试错误'));
```

## 5. 实际应用示例

### 5.1 简单的发布订阅系统

```javascript
const EventEmitter = require('events');

class PubSub extends EventEmitter {
  subscribe(topic, callback) {
    this.on(topic, callback);
    return () => this.removeListener(topic, callback);
  }

  publish(topic, data) {
    this.emit(topic, data);
  }
}

// 使用示例
const pubsub = new PubSub();

const unsubscribe = pubsub.subscribe('news', (news) => {
  console.log('收到新闻:', news);
});

pubsub.publish('news', '重要新闻！');
unsubscribe();
```

### 5.2 状态管理器

```javascript
class StateManager extends EventEmitter {
  constructor(initialState) {
    super();
    this.state = initialState;
  }

  setState(newState) {
    const oldState = this.state;
    this.state = newState;
    this.emit('stateChange', newState, oldState);
  }

  getState() {
    return this.state;
  }
}

// 使用示例
const stateManager = new StateManager({ count: 0 });

stateManager.on('stateChange', (newState, oldState) => {
  console.log('状态变化:', oldState, '->', newState);
});

stateManager.setState({ count: 1 });
```

### 5.3 任务队列

```javascript
class TaskQueue extends EventEmitter {
  constructor() {
    super();
    this.queue = [];
    this.running = false;
  }

  add(task) {
    this.queue.push(task);
    this.emit('taskAdded', task);
    this.process();
  }

  async process() {
    if (this.running || this.queue.length === 0) return;
    
    this.running = true;
    const task = this.queue.shift();
    
    try {
      this.emit('taskStart', task);
      await task();
      this.emit('taskComplete', task);
    } catch (err) {
      this.emit('taskError', task, err);
    }
    
    this.running = false;
    this.process();
  }
}

// 使用示例
const taskQueue = new TaskQueue();

taskQueue.on('taskStart', task => {
  console.log('开始任务:', task.name);
});

taskQueue.on('taskComplete', task => {
  console.log('任务完成:', task.name);
});

taskQueue.add({ name: '任务1', fn: () => new Promise(resolve => setTimeout(resolve, 1000)) });
```

## 6. 性能优化

### 6.1 监听器数量管理

```javascript
const emitter = new EventEmitter();

// 设置最大监听器数量
emitter.setMaxListeners(20);

// 检查监听器数量
function checkListeners(eventName) {
  const count = emitter.listenerCount(eventName);
  if (count > emitter.getMaxListeners() / 2) {
    console.warn(`警告: ${eventName} 事件监听器数量过多: ${count}`);
  }
}
```

### 6.2 事件委托

```javascript
class EventDelegator extends EventEmitter {
  constructor() {
    super();
    this.delegates = new Map();
  }

  delegate(eventName, targetEmitter) {
    if (!this.delegates.has(eventName)) {
      this.delegates.set(eventName, new Set());
    }
    this.delegates.get(eventName).add(targetEmitter);

    targetEmitter.on(eventName, (...args) => {
      this.emit(eventName, ...args);
    });
  }

  undelegate(eventName, targetEmitter) {
    if (this.delegates.has(eventName)) {
      this.delegates.get(eventName).delete(targetEmitter);
    }
  }
}
```

## 7. 最佳实践

### 7.1 错误处理

```javascript
function safeEmit(emitter, eventName, ...args) {
  try {
    return emitter.emit(eventName, ...args);
  } catch (err) {
    console.error(`事件 ${eventName} 处理出错:`, err);
    emitter.emit('error', err);
    return false;
  }
}
```

### 7.2 事件命名规范

```javascript
const EventNames = {
  USER_LOGIN: 'user:login',
  USER_LOGOUT: 'user:logout',
  DATA_UPDATE: 'data:update',
  ERROR: 'error'
};

// 使用常量作为事件名
emitter.on(EventNames.USER_LOGIN, (user) => {
  console.log(`${user.name} 登录`);
});
```

### 7.3 内存管理

```javascript
class ManagedEmitter extends EventEmitter {
  constructor() {
    super();
    this.listeners = new Map();
  }

  addManagedListener(eventName, listener) {
    this.on(eventName, listener);
    
    if (!this.listeners.has(eventName)) {
      this.listeners.set(eventName, new Set());
    }
    this.listeners.get(eventName).add(listener);

    // 返回清理函数
    return () => {
      this.removeListener(eventName, listener);
      this.listeners.get(eventName).delete(listener);
    };
  }

  removeAllManagedListeners() {
    this.listeners.forEach((listeners, eventName) => {
      listeners.forEach(listener => {
        this.removeListener(eventName, listener);
      });
    });
    this.listeners.clear();
  }
}
```

## 8. 常见陷阱

### 8.1 内存泄漏

```javascript
// 错误示例：未移除监听器
function setupComponent(emitter) {
  emitter.on('data', handleData);
}

// 正确示例：提供清理机制
function setupComponent(emitter) {
  const handleData = (data) => console.log(data);
  emitter.on('data', handleData);
  
  return () => {
    emitter.removeListener('data', handleData);
  };
}
```

### 8.2 错误事件处理

```javascript
// 错误示例：未处理错误事件
const emitter = new EventEmitter();
emitter.emit('error', new Error('未处理的错误'));

// 正确示例：添加错误处理
emitter.on('error', (err) => {
  console.error('捕获错误:', err);
});
```

### 8.3 监听器过多警告

```javascript
// 错误示例：可能产生内存泄漏
for (let i = 0; i < 100; i++) {
  emitter.on('event', () => {});
}

// 正确示例：合理使用监听器
class Component {
  constructor(emitter) {
    this.emitter = emitter;
    this.listenerCount = 0;
  }

  addListener(callback) {
    if (this.listenerCount >= 10) {
      console.warn('监听器数量过多');
      return false;
    }
    this.emitter.on('event', callback);
    this.listenerCount++;
    return true;
  }
}
```

## 9. 总结

Node.js 的事件系统是构建异步应用的基础：

1. **EventEmitter** 提供了事件驱动的基础框架
2. **事件监听和触发** 实现了松耦合的通信机制
3. **错误处理** 确保应用的稳定性
4. **性能优化** 避免常见的内存和性能问题

使用事件系统时应该：
- 始终处理错误事件
- 合理管理监听器数量
- 注意内存泄漏问题
- 遵循事件命名规范
- 实现适当的清理机制

这样可以构建出高效、可维护的事件驱动应用。