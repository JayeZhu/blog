---
title: Node流
date: 2025-10-15 10:50:48
permalink: /pages/abb84b/
categories:
  - 后端
tags:
  - NodeJS
  - Node核心模块深入
---
# Node.js 流 (Stream) 完全指南

## 1. 流的概念

流是 Node.js 中处理流式数据的抽象接口。流可以是可读的、可写的，或是两者都可读写的。所有流都是 EventEmitter 的实例。

### 1.1 四种基本流类型

```javascript
const { Readable, Writable, Duplex, Transform } = require('stream');

// 可读流示例
const readableStream = new Readable({
  read(size) {
    // 实现读取逻辑
  }
});

// 可写流示例
const writableStream = new Writable({
  write(chunk, encoding, callback) {
    // 实现写入逻辑
    callback();
  }
});

// 双工流示例
const duplexStream = new Duplex({
  read(size) {
    // 读取逻辑
  },
  write(chunk, encoding, callback) {
    // 写入逻辑
    callback();
  }
});

// 转换流示例
const transformStream = new Transform({
  transform(chunk, encoding, callback) {
    // 转换逻辑
    this.push(chunk.toString().toUpperCase());
    callback();
  }
});
```

## 2. 可读流 (Readable Stream)

### 2.1 基本使用

```javascript
const fs = require('fs');
const readable = fs.createReadStream('example.txt');

// 监听数据事件
readable.on('data', (chunk) => {
  console.log(`接收到 ${chunk.length} 字节的数据`);
});

// 监听结束事件
readable.on('end', () => {
  console.log('读取完成');
});

// 监听错误事件
readable.on('error', (err) => {
  console.error('读取错误:', err);
});
```

### 2.2 两种模式

```javascript
// 流动模式
readable.on('data', (chunk) => {
  console.log(chunk);
});

// 暂停模式
readable.pause();
readable.on('readable', () => {
  let chunk;
  while (null !== (chunk = readable.read())) {
    console.log(`读取到 ${chunk.length} 字节的数据`);
  }
});
```

## 3. 可写流 (Writable Stream)

### 3.1 基本使用

```javascript
const fs = require('fs');
const writable = fs.createWriteStream('output.txt');

// 写入数据
writable.write('Hello\n');
writable.write('World\n');

// 标记写入完成
writable.end(() => {
  console.log('写入完成');
});

// 处理错误
writable.on('error', (err) => {
  console.error('写入错误:', err);
});
```

### 3.2 drain 事件处理

```javascript
const { Writable } = require('stream');

const writable = new Writable({
  write(chunk, encoding, callback) {
    // 模拟慢速写入
    setTimeout(() => {
      callback();
    }, 100);
  }
});

function writeData(data) {
  const ok = writable.write(data);
  if (!ok) {
    console.log('等待 drain 事件...');
    writable.once('drain', () => {
      console.log('可以继续写入');
      writeData(data);
    });
  } else {
    console.log('继续写入');
    writeData(data);
  }
}
```

## 4. 双工流 (Duplex Stream)

### 4.1 基本实现

```javascript
const { Duplex } = require('stream');

const duplex = new Duplex({
  read(size) {
    // 读取实现
    this.push('some data');
    this.push(null); // 结束读取
  },
  write(chunk, encoding, callback) {
    // 写入实现
    console.log('写入:', chunk.toString());
    callback();
  }
});

// 可以同时读取和写入
duplex.on('data', (chunk) => {
  console.log('读取:', chunk.toString());
});

duplex.write('test data');
```

## 5. 转换流 (Transform Stream)

### 5.1 基本实现

```javascript
const { Transform } = require('stream');

const upperCase = new Transform({
  transform(chunk, encoding, callback) {
    // 转换数据
    this.push(chunk.toString().toUpperCase());
    callback();
  }
});

// 使用转换流
process.stdin
  .pipe(upperCase)
  .pipe(process.stdout);
```

### 5.2 实际应用示例

```javascript
// CSV 转 JSON 转换流
const csvToJson = new Transform({
  objectMode: true,
  transform(chunk, encoding, callback) {
    const values = chunk.toString().split(',');
    const obj = {
      name: values[0],
      age: values[1],
      city: values[2]
    };
    this.push(obj);
    callback();
  }
});
```

## 6. 管道 (pipe)

### 6.1 基本管道操作

```javascript
const fs = require('fs');

// 创建读取和写入流
const readable = fs.createReadStream('input.txt');
const writable = fs.createWriteStream('output.txt');

// 使用管道连接流
readable.pipe(writable);

// 添加错误处理
readable.on('error', (err) => {
  console.error('读取错误:', err);
});

writable.on('error', (err) => {
  console.error('写入错误:', err);
});
```

### 6.2 链式管道

```javascript
const fs = require('fs');
const zlib = require('zlib');

// 压缩文件
fs.createReadStream('input.txt')
  .pipe(zlib.createGzip())
  .pipe(fs.createWriteStream('input.txt.gz'));

// 多个转换流
fs.createReadStream('input.txt')
  .pipe(transform1)
  .pipe(transform2)
  .pipe(transform3)
  .pipe(fs.createWriteStream('output.txt'));
```

## 7. 处理大文件和数据流

### 7.1 大文件复制示例

```javascript
const fs = require('fs');

function copyLargeFile(src, dest) {
  const readable = fs.createReadStream(src);
  const writable = fs.createWriteStream(dest);

  return new Promise((resolve, reject) => {
    readable.on('error', reject);
    writable.on('error', reject);
    writable.on('finish', resolve);
    
    readable.pipe(writable);
  });
}

// 使用示例
copyLargeFile('large-file.zip', 'copy.zip')
  .then(() => console.log('复制完成'))
  .catch(err => console.error('复制失败:', err));
```

### 7.2 流式处理数据

```javascript
const { Transform } = require('stream');

// 处理大型 JSON 文件
class JSONParser extends Transform {
  constructor() {
    super({ objectMode: true });
    this.buffer = '';
  }

  _transform(chunk, encoding, callback) {
    this.buffer += chunk.toString();
    const lines = this.buffer.split('\n');
    this.buffer = lines.pop();

    for (const line of lines) {
      try {
        const obj = JSON.parse(line);
        this.push(obj);
      } catch (err) {
        this.emit('error', err);
      }
    }
    callback();
  }
}

// 使用示例
fs.createReadStream('large-data.json')
  .pipe(new JSONParser())
  .on('data', (obj) => {
    console.log('处理对象:', obj);
  });
```

## 8. 背压机制

### 8.1 理解背压

```javascript
const { Readable } = require('stream');

// 模拟慢速消费者
const slowConsumer = new Writable({
  write(chunk, encoding, callback) {
    // 模拟慢速处理
    setTimeout(() => {
      console.log('处理:', chunk.toString());
      callback();
    }, 100);
  }
});

// 高速生产者
const fastProducer = new Readable({
  read() {
    for (let i = 0; i < 1000; i++) {
      this.push(`数据 ${i}\n`);
    }
    this.push(null);
  }
});

// 管道连接
fastProducer.pipe(slowConsumer);
```

### 8.2 处理背压

```javascript
function handleBackpressure(readable, writable) {
  readable.on('data', (chunk) => {
    const canWrite = writable.write(chunk);
    
    if (!canWrite) {
      readable.pause();
      writable.once('drain', () => {
        readable.resume();
      });
    }
  });
}
```

## 9. 性能优化关键点

### 9.1 缓冲区管理

```javascript
const { Transform } = require('stream');

// 优化缓冲区大小
const optimizedStream = new Transform({
  highWaterMark: 1024 * 1024, // 1MB 缓冲区
  transform(chunk, encoding, callback) {
    // 处理数据
    callback();
  }
});
```

### 9.2 错误处理和恢复

```javascript
function createRobustStream() {
  const stream = new Transform({
    transform(chunk, encoding, callback) {
      try {
        // 转换逻辑
        this.push(processChunk(chunk));
        callback();
      } catch (err) {
        // 错误处理
        callback(err);
      }
    }
  });

  // 错误恢复
  stream.on('error', (err) => {
    console.error('流错误:', err);
    // 实现恢复逻辑
  });

  return stream;
}
```

### 9.3 内存使用优化

```javascript
// 使用 objectMode 处理对象
const objectStream = new Transform({
  objectMode: true,
  transform(chunk, encoding, callback) {
    // 处理对象而非缓冲区
    const processed = processObject(chunk);
    this.push(processed);
    callback();
  }
});

// 及时清理资源
function cleanupStream(stream) {
  stream.destroy();
  stream.removeAllListeners();
}
```

## 10. 实际应用示例

### 10.1 文件上传处理

```javascript
const express = require('express');
const multer = require('multer');
const fs = require('fs');

const app = express();

const upload = multer({
  storage: multer.diskStorage({
    destination: (req, file, cb) => {
      cb(null, 'uploads/');
    },
    filename: (req, file, cb) => {
      cb(null, file.originalname);
    }
  })
});

app.post('/upload', upload.single('file'), (req, res) => {
  const readable = fs.createReadStream(req.file.path);
  const writable = fs.createWriteStream(`processed-${req.file.filename}`);
  
  readable
    .pipe(transformStream)
    .pipe(writable)
    .on('finish', () => {
      res.json({ message: '文件处理完成' });
    });
});
```

### 10.2 实时数据处理

```javascript
const WebSocket = require('ws');
const { Transform } = require('stream');

const wss = new WebSocket.Server({ port: 8080 });

// 数据处理流
const dataProcessor = new Transform({
  objectMode: true,
  transform(chunk, encoding, callback) {
    // 实时数据处理
    const processed = processData(chunk);
    this.push(processed);
    callback();
  }
});

wss.on('connection', ws => {
  const readable = createDataStream(); // 创建数据流
  
  readable
    .pipe(dataProcessor)
    .on('data', data => {
      ws.send(JSON.stringify(data));
    });
});
```

## 11. 最佳实践

1. **错误处理**
   - 始终处理错误事件
   - 实现适当的错误恢复机制
   - 防止错误传播导致程序崩溃

2. **内存管理**
   - 使用适当的缓冲区大小
   - 及时清理资源
   - 避免在流中累积数据

3. **性能优化**
   - 合理使用 highWaterMark
   - 实现适当的背压处理
   - 考虑使用对象模式处理复杂对象

4. **流的设计**
   - 保持流的简单性
   - 遵循 Node.js 流的约定
   - 提供清晰的错误处理机制

## 12. 常见陷阱

1. **未处理背压**
```javascript
// 错误示例
readable.on('data', (chunk) => {
  // 直接处理数据，不考虑背压
  processData(chunk);
});

// 正确示例
readable.on('data', (chunk) => {
  const canProcess = processData(chunk);
  if (!canProcess) {
    readable.pause();
  }
});
```

2. **内存泄漏**
```javascript
// 错误示例
const chunks = [];
readable.on('data', chunk => chunks.push(chunk));

// 正确示例
readable.on('data', chunk => {
  processChunk(chunk);
  // 不累积数据
});
```

3. **错误处理不当**
```javascript
// 错误示例
readable.on('error', err => {
  // 仅记录错误
  console.error(err);
});

// 正确示例
readable.on('error', err => {
  console.error(err);
  // 实现恢复逻辑
  attemptRecovery();
});
```

## 13. 总结

Node.js 的流提供了处理数据的强大而灵活的方式：

1. **四种基本流类型**满足不同的数据处理需求
2. **管道机制**简化了流之间的连接和数据传递
3. **背压处理**确保系统稳定性
4. **性能优化**使大文件处理更高效

使用流时应该：
- 正确处理背压
- 实现适当的错误处理
- 注意内存管理
- 遵循最佳实践

这样可以构建出高效、可靠的流式处理应用程序。