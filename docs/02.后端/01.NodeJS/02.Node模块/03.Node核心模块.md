---
title: Node核心模块
date: 2025-10-13 17:28:03
permalink: /pages/25ae3d/
categories:
  - 后端
tags:
  - NodeJS
  - Node模块
---
:::tip
核心模块是我们无需安装即可使用的内置工具库。Node.js 的核心模块是预编译的模块，直接集成在运行时环境中。
:::

## 什么是核心模块？
核心模块是 Node.js 官方提供的、默认集成在运行时中的一组模块。它们覆盖了服务器端开发所需的基础功能，包括文件操作、网络通信、路径处理等
。与需要通过 npm 安装的第三方模块不同，核心模块无需额外安装即可直接使用。

## 核心模块分类
| 类别 | 核心模块 | 主要功能 | Node.js 文档地址 |
|------|---------|---------|----------------|
| 文件系统 | fs | 文件读写、目录操作 | https://nodejs.org/api/fs.html |
| 网络通信 | http、https、net | 创建服务器和处理网络请求 | https://nodejs.org/api/http.html, https://nodejs.org/api/https.html, https://nodejs.org/api/net.html |
| 路径处理 | path | 文件和目录路径的解析与操作 | https://nodejs.org/api/path.html |
| 系统信息 | os | 获取操作系统相关信息 | https://nodejs.org/api/os.html |
| 加密安全 | crypto | 加密解密、哈希计算 | https://nodejs.org/api/crypto.html |
| 流程控制 | events、stream | 事件处理和流式数据操作 | https://nodejs.org/api/events.html, https://nodejs.org/api/stream.html |
| 工具函数 | util | 提供实用工具函数 | https://nodejs.org/api/util.html |


## 核心模块详解与实战应用
### 文件系统模块（fs）
fs 模块是 Node.js 中最常用的核心模块之一，它提供了文件操作的 API，支持同步和异步两种调用方式
。

​基本文件操作示例：​​

```javascript
const fs = require('fs');

// 异步读取文件
fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log('文件内容:', data);
});

// 同步读取文件
try {
  const data = fs.readFileSync('example.txt', 'utf8');
  console.log('文件内容:', data);
} catch (err) {
  console.error('读取文件出错:', err);
}

// 使用 Promise 版本的 fs（推荐）
const fsPromise = require('fs/promises');

async function readFile() {
  try {
    const data = await fsPromise.readFile('example.txt', 'utf8');
    console.log('文件内容:', data);
  } catch (err) {
    console.error('读取文件出错:', err);
  }
}
```
​高级功能：​​

- ​文件监视​：使用 fs.watch()监听文件变化
- 流式操作​：对于大文件，使用流（Stream）来避免内存溢出
- 目录操作​：创建、删除、读取目录

### HTTP 模块：Web 服务器的核心
http 模块允许我们创建 HTTP 服务器和客户端，是构建 Web 应用的基础
。

​创建基本 HTTP 服务器：​​

```javascript
const http = require('http');

const server = http.createServer((req, res) => {
  // 设置响应头
  res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
  
  // 根据请求 URL 路由到不同处理逻辑
  if (req.url === '/') {
    res.end('<h1>欢迎来到首页</h1>');
  } else if (req.url === '/about') {
    res.end('<h1>关于我们</h1>');
  } else {
    res.writeHead(404);
    res.end('<h1>页面未找到</h1>');
  }
});

server.listen(3000, () => {
  console.log('服务器运行在 http://localhost:3000/');
});
```

​静态文件服务器示例：​​

```javascript
const http = require('http');
const fs = require('fs');
const path = require('path');

const server = http.createServer((req, res) => {
  // 构建文件路径
  let filePath = path.join(__dirname, 'public', req.url === '/' ? 'index.html' : req.url);
  
  // 获取文件扩展名
  const extname = path.extname(filePath);
  
  // 设置内容类型
  const contentTypes = {
    '.html': 'text/html',
    '.css': 'text/css',
    '.js': 'application/javascript',
    '.png': 'image/png',
    '.jpg': 'image/jpeg'
  };
  
  fs.readFile(filePath, (err, data) => {
    if (err) {
      res.writeHead(404);
      res.end('文件未找到');
    } else {
      res.writeHead(200, { 
        'Content-Type': contentTypes[extname] || 'text/plain' 
      });
      res.end(data);
    }
  });
});

server.listen(3000);
```

### 路径处理模块（path）
path 模块提供了处理文件路径的工具方法，帮助我们在不同操作系统中正确处理路径
。

​常用方法示例：​​

```javascript
const path = require('path');

// 路径拼接
const fullPath = path.join('/Users', 'username', 'docs', 'file.txt');
console.log(fullPath); // /Users/username/docs/file.txt

// 解析路径
const pathObj = path.parse('/Users/username/file.txt');
console.log(pathObj);
// { root: '/', dir: '/Users/username', base: 'file.txt', ext: '.txt', name: 'file' }

// 获取绝对路径
const absolutePath = path.resolve('src', 'app.js');
console.log(absolutePath);

// 获取文件名扩展
const ext = path.extname('index.html');
console.log(ext); // .html
```

​路径解析的最佳实践：​​

使用 path.join()和 path.resolve()代替字符串拼接，可以确保路径在不同操作系统上的兼容性。

### 事件模块（events）
events 模块是 Node.js ​事件驱动架构的核心，几乎所有异步操作都基于事件机制
。

​创建和使用事件发射器：​​

```javascript
const EventEmitter = require('events');

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();

// 注册事件监听器
myEmitter.on('login', (username) => {
  console.log(`${username} 登录成功`);
});

myEmitter.on('logout', (username) => {
  console.log(`${username} 退出登录`);
});

// 触发事件
myEmitter.emit('login', '张三');
myEmitter.emit('logout', '张三');

// 一次性事件
myEmitter.once('firstLogin', (username) => {
  console.log(`${username} 首次登录`);
});
```

### 流模块（stream）
流是 Node.js 中处理大数据集的强大抽象，可以逐块处理数据而不必全部加载到内存中
。

​流操作示例：​​

```javascript
const fs = require('fs');
const zlib = require('zlib');

// 使用流复制大文件
const readStream = fs.createReadStream('largefile.txt');
const writeStream = fs.createWriteStream('copy-largefile.txt');

readStream.pipe(writeStream);

// 链式流操作：读取、压缩、写入
fs.createReadStream('largefile.txt')
  .pipe(zlib.createGzip())
  .pipe(fs.createWriteStream('largefile.txt.gz'));

// 自定义转换流
const { Transform } = require('stream');

const upperCaseTransform = new Transform({
  transform(chunk, encoding, callback) {
    this.push(chunk.toString().toUpperCase());
    callback();
  }
});

// 使用转换流
readStream.pipe(upperCaseTransform).pipe(writeStream);
```

## 核心模块的协同工作模式
在实际项目中，我们通常需要组合使用多个核心模块来构建复杂功能。下面是一个综合示例，展示如何将多个核心模块结合使用：

​文件上传服务器示例：​​

```javascript
const http = require('http');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const server = http.createServer(async (req, res) => {
  // 只处理 POST 请求到 /upload 路径
  if (req.method === 'POST' && req.url === '/upload') {
    try {
      // 生成唯一文件名
      const timestamp = Date.now();
      const hash = crypto.createHash('md5').update(timestamp.toString()).digest('hex');
      const fileName = `upload_${hash}.dat`;
      const filePath = path.join(__dirname, 'uploads', fileName);
      
      // 确保上传目录存在
      await fs.promises.mkdir(path.dirname(filePath), { recursive: true });
      
      // 创建可写流
      const writeStream = fs.createWriteStream(filePath);
      
      // 使用流式处理接收数据
      req.pipe(writeStream);
      
      req.on('end', () => {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ 
          success: true, 
          message: '文件上传成功',
          fileName: fileName
        }));
      });
      
    } catch (error) {
      res.writeHead(500);
      res.end(JSON.stringify({ success: false, message: '上传失败' }));
    }
  } else {
    res.writeHead(404);
    res.end('Not Found');
  }
});

server.listen(3000);
```