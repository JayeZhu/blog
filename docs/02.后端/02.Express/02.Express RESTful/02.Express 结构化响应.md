---
title: Express 结构化响应
date: 2025-10-15 17:38:06
permalink: /pages/d6713e/
categories:
  - 后端
tags:
  - Express
  - Express RESTful
---
## 响应格式设计

### 统一响应结构

```javascript
// 基础响应格式
{
  "status": number,      // HTTP状态码
  "message": string,     // 响应消息
  "data": object,        // 响应数据
  "error": object,       // 错误详情(可选)
  "timestamp": string    // 时间戳
}
```

### 响应工具函数

```javascript
// utils/response.js
const sendResponse = (res, status, data, message = '') => {
  res.status(status).json({
    status,
    message,
    data,
    timestamp: new Date().toISOString()
  });
};

const sendError = (res, status, error, message = '') => {
  res.status(status).json({
    status,
    message,
    error: {
      code: error.code || 'UNKNOWN_ERROR',
      message: error.message
    },
    timestamp: new Date().toISOString()
  });
};
```

## 不同场景的响应实现

### 成功响应

```javascript
// 获取资源
app.get('/api/users/:id', async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    if (!user) {
      return sendResponse(res, 404, null, 'User not found');
    }
    sendResponse(res, 200, user, 'Success');
  } catch (error) {
    sendError(res, 500, error);
  }
});

// 创建资源
app.post('/api/users', async (req, res) => {
  try {
    const user = await User.create(req.body);
    sendResponse(res, 201, user, 'User created successfully');
  } catch (error) {
    sendError(res, 400, error);
  }
});
```

### 错误响应

```javascript
// 验证错误
const handleValidationError = (res, error) => {
  const errors = Object.values(error.errors).map(err => ({
    field: err.path,
    message: err.message
  }));
  
  sendError(res, 400, {
    code: 'VALIDATION_ERROR',
    details: errors
  });
};

// 业务逻辑错误
const handleBusinessError = (res, error) => {
  sendError(res, error.status || 500, {
    code: error.code || 'BUSINESS_ERROR',
    message: error.message
  });
};
```

## 分页响应

```javascript
// 分页数据结构
{
  "status": 200,
  "message": "Success",
  "data": {
    "items": [],           // 数据列表
    "pagination": {        // 分页信息
      "page": 1,
      "limit": 10,
      "total": 100,
      "pages": 10
    }
  }
}

// 实现示例
app.get('/api/posts', async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    const posts = await Post.find()
      .skip(skip)
      .limit(limit);

    const total = await Post.countDocuments();

    sendResponse(res, 200, {
      items: posts,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    sendError(res, 500, error);
  }
});
```

## 错误处理中间件

```javascript
// middleware/errorHandler.js
const errorHandler = (err, req, res, next) => {
  // 记录错误日志
  console.error(err);

  // 根据错误类型返回不同的响应
  if (err.name === 'ValidationError') {
    return handleValidationError(res, err);
  }

  if (err.name === 'CastError') {
    return sendError(res, 400, {
      code: 'INVALID_ID',
      message: 'Invalid resource ID'
    });
  }

  // 默认错误响应
  sendError(res, 500, {
    code: 'INTERNAL_ERROR',
    message: process.env.NODE_ENV === 'development' 
      ? err.message 
      : 'Internal server error'
  });
};

// 使用错误处理中间件
app.use(errorHandler);
```

## 最佳实践

### 1. 响应格式一致性

```javascript
// 使用响应拦截器统一处理
app.use((req, res, next) => {
  const originalSend = res.send;
  
  res.send = function(data) {
    if (!res.headersSent) {
      data = {
        status: res.statusCode,
        timestamp: new Date().toISOString(),
        ...data
      };
    }
    originalSend.call(this, data);
  };
  
  next();
});
```

### 2. 错误分类处理

```javascript
// 错误类型定义
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = true;
  }
}

class ValidationError extends AppError {
  constructor(message) {
    super(message, 400);
    this.code = 'VALIDATION_ERROR';
  }
}

// 使用示例
app.post('/api/users', async (req, res) => {
  try {
    if (!req.body.email) {
      throw new ValidationError('Email is required');
    }
    // 处理逻辑...
  } catch (error) {
    next(error);
  }
});
```

### 3. 响应数据过滤

```javascript
// 数据过滤中间件
const filterResponse = (req, res, next) => {
  const originalJson = res.json;
  
  res.json = function(data) {
    if (data.data && req.query.fields) {
      const fields = req.query.fields.split(',');
      data.data = _.pick(data.data, fields);
    }
    originalJson.call(this, data);
  };
  
  next();
};

// 使用示例
app.get('/api/users/:id', filterResponse, async (req, res) => {
  const user = await User.findById(req.params.id);
  sendResponse(res, 200, user);
});

// 请求示例
// GET /api/users/1?fields=name,email
```

## 总结

Express 结构化响应的关键点：

1. **统一响应格式**：保持API响应的一致性
2. **错误分类处理**：根据不同错误类型返回适当的响应
3. **分页数据结构**：标准化分页响应格式
4. **错误处理中间件**：集中处理应用错误
5. **响应数据过滤**：支持字段选择和数据过滤

通过实现这些机制，可以构建出结构清晰、易于维护的API响应系统。