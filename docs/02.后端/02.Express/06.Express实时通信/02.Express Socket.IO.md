---
title: Express Socket.IO
date: 2025-10-15 18:18:00
permalink: /pages/69e98e/
categories:
  - 后端
tags:
  - Express
  - Express实时通信
---
## Socket.IO 基础

### Socket.IO 特性

- **自动连接管理**：自动处理连接重连
- **事件驱动**：基于事件的通信
- **房间支持**：内置房间管理
- **跨浏览器兼容**：支持多种传输方式
- **二进制数据支持**：支持文件传输

### Socket.IO 与原生 WebSocket 对比

| 特性 | Socket.IO | WebSocket |
|------|-----------|-----------|
| 连接管理 | 自动 | 手动 |
| 降级支持 | 是 | 否 |
| 房间系统 | 内置 | 需要自实现 |
| 事件系统 | 内置 | 需要自实现 |
| 兼容性 | 高 | 中等 |

## 安装与配置

### 安装依赖

```bash
npm install socket.io
npm install @socket.io/redis-adapter # Redis适配器
```

### 基本配置

```javascript
// app.js
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);

const io = new Server(server, {
  cors: {
    origin: "http://localhost:3000",
    methods: ["GET", "POST"]
  },
  adapter: require('@socket.io/redis-adapter')(
    require('redis').createClient({ url: 'redis://localhost:6379' }),
    require('redis').createClient({ url: 'redis://localhost:6379' })
  )
});

// Socket.IO 连接处理
io.on('connection', (socket) => {
  console.log('用户连接:', socket.id);
  
  // 断开连接处理
  socket.on('disconnect', () => {
    console.log('用户断开连接:', socket.id);
  });
});

server.listen(3000, () => {
  console.log('服务器运行在端口 3000');
});
```

### 客户端配置

```javascript
// public/client.js
const socket = io('http://localhost:3000', {
  auth: {
    token: 'your-auth-token'
  }
});

// 连接事件
socket.on('connect', () => {
  console.log('连接成功');
});

socket.on('disconnect', () => {
  console.log('连接断开');
});

// 自定义事件
socket.on('message', (data) => {
  console.log('收到消息:', data);
});
```

## 基本通信

### 事件发送与接收

```javascript
// 服务器端
io.on('connection', (socket) => {
  // 发送给当前客户端
  socket.emit('welcome', '欢迎连接！');
  
  // 发送给所有客户端
  io.emit('broadcast', '这是广播消息');
  
  // 发送给除发送者外的所有客户端
  socket.broadcast.emit('notification', '新用户加入');
  
  // 接收客户端消息
  socket.on('message', (data) => {
    console.log('收到消息:', data);
    
    // 回复消息
    socket.emit('reply', '消息已收到');
  });
});

// 客户端
socket.on('welcome', (message) => {
  console.log(message);
});

socket.on('broadcast', (message) => {
  console.log(message);
});

socket.on('notification', (message) => {
  console.log(message);
});

// 发送消息
socket.emit('message', {
  type: 'chat',
  content: 'Hello Server'
});
```

### 自定义事件

```javascript
// 服务器端事件定义
const EVENTS = {
  JOIN_ROOM: 'join-room',
  LEAVE_ROOM: 'leave-room',
  ROOM_MESSAGE: 'room-message',
  USER_TYPING: 'user-typing',
  USER_STOP_TYPING: 'user-stop-typing'
};

// 使用事件
socket.on(EVENTS.JOIN_ROOM, (roomId) => {
  socket.join(roomId);
  socket.to(roomId).emit(EVENTS.ROOM_MESSAGE, {
    type: 'system',
    content: `用户 ${socket.id} 加入房间`
  });
});
```

## 房间管理

### 房间控制器

```javascript
// controllers/roomController.js
class RoomController {
  constructor(io) {
    this.io = io;
    this.rooms = new Map();
  }
  
  createRoom(roomId, options = {}) {
    const room = {
      id: roomId,
      users: new Set(),
      maxUsers: options.maxUsers || 100,
      isPrivate: options.isPrivate || false,
      createdAt: new Date()
    };
    
    this.rooms.set(roomId, room);
    return room;
  }
  
  joinRoom(socket, roomId, userData) {
    const room = this.rooms.get(roomId);
    if (!room) {
      throw new Error('房间不存在');
    }
    
    if (room.users.size >= room.maxUsers) {
      throw new Error('房间已满');
    }
    
    room.users.add({
      socketId: socket.id,
      ...userData
    });
    
    socket.join(roomId);
    socket.roomId = roomId;
    
    // 通知房间内其他用户
    socket.to(roomId).emit('user-joined', {
      user: userData,
      users: Array.from(room.users)
    });
    
    return room;
  }
  
  leaveRoom(socket) {
    const roomId = socket.roomId;
    if (!roomId) return;
    
    const room = this.rooms.get(roomId);
    if (!room) return;
    
    room.users.delete(socket.id);
    socket.leave(roomId);
    
    if (room.users.size === 0) {
      this.rooms.delete(roomId);
    } else {
      socket.to(roomId).emit('user-left', {
        users: Array.from(room.users)
      });
    }
  }
}

module.exports = RoomController;
```

### 房间事件处理

```javascript
// routes/socketEvents.js
const RoomController = require('../controllers/roomController');
const roomController = new RoomController(io);

io.on('connection', (socket) => {
  // 加入房间
  socket.on('join-room', async (data) => {
    try {
      const { roomId, userData } = data;
      const room = roomController.joinRoom(socket, roomId, userData);
      
      socket.emit('room-joined', {
        roomId,
        users: Array.from(room.users)
      });
    } catch (error) {
      socket.emit('error', { message: error.message });
    }
  });
  
  // 离开房间
  socket.on('leave-room', () => {
    roomController.leaveRoom(socket);
    socket.emit('room-left');
  });
  
  // 房间消息
  socket.on('room-message', (data) => {
    const { roomId, message } = data;
    socket.to(roomId).emit('room-message', {
      message,
      sender: socket.id
    });
  });
});
```

## 中间件使用

### 认证中间件

```javascript
// middleware/socketAuth.js
const jwt = require('jsonwebtoken');

const socketAuth = async (socket, next) => {
  try {
    const token = socket.handshake.auth.token;
    
    if (!token) {
      return next(new Error('认证令牌缺失'));
    }
    
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.id);
    
    if (!user) {
      return next(new Error('用户不存在'));
    }
    
    socket.user = user;
    next();
  } catch (error) {
    next(new Error('认证失败'));
  }
};

module.exports = socketAuth;
```

### 使用中间件

```javascript
// app.js
const socketAuth = require('./middleware/socketAuth');

// 全局中间件
io.use(socketAuth);

// 特定事件中间件
io.on('connection', (socket) => {
  socket.use((packet, next) => {
    const [event, ...args] = packet;
    
    if (event === 'message') {
      // 消息验证
      if (!args[0] || !args[0].content) {
        return next(new Error('无效消息'));
      }
    }
    
    next();
  });
});
```

## 认证与授权

### 用户认证

```javascript
// services/authService.js
class AuthService {
  static async authenticateSocket(socket) {
    try {
      const token = socket.handshake.auth.token;
      const user = await this.verifyToken(token);
      
      if (!user) {
        throw new Error('认证失败');
      }
      
      socket.user = user;
      return user;
    } catch (error) {
      throw new Error('认证失败');
    }
  }
  
  static async verifyToken(token) {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    return await User.findById(decoded.id);
  }
}

module.exports = AuthService;
```

### 权限控制

```javascript
// middleware/socketAuthz.js
const authorizeSocket = (permission) => {
  return async (socket, next) => {
    try {
      const hasPermission = await checkUserPermission(
        socket.user.id,
        permission
      );
      
      if (!hasPermission) {
        return next(new Error('权限不足'));
      }
      
      next();
    } catch (error) {
      next(error);
    }
  };
};

// 使用示例
io.on('connection', (socket) => {
  socket.on('admin-action', authorizeSocket('admin'), (data) => {
    // 处理管理员操作
  });
});
```

## 错误处理

### 错误处理中间件

```javascript
// middleware/errorHandler.js
const handleSocketError = (error, socket) => {
  console.error('Socket错误:', error);
  
  // 根据错误类型发送不同的响应
  if (error.name === 'ValidationError') {
    socket.emit('validation-error', {
      message: error.message,
      details: error.details
    });
  } else if (error.name === 'UnauthorizedError') {
    socket.emit('auth-error', {
      message: '认证失败'
    });
  } else {
    socket.emit('error', {
      message: '服务器错误'
    });
  }
};

module.exports = handleSocketError;
```

### 错误恢复

```javascript
// utils/errorRecovery.js
class SocketErrorRecovery {
  constructor(socket) {
    this.socket = socket;
    this.retryCount = 0;
    this.maxRetries = 3;
  }
  
  async handle(error) {
    if (this.retryCount < this.maxRetries) {
      this.retryCount++;
      await this.retry();
    } else {
      this.socket.emit('error', {
        message: '重试次数超过限制',
        code: 'MAX_RETRIES_EXCEEDED'
      });
    }
  }
  
  async retry() {
    try {
      await this.reconnect();
    } catch (error) {
      this.handle(error);
    }
  }
  
  async reconnect() {
    // 重新连接逻辑
    return new Promise((resolve) => {
      setTimeout(() => {
        this.socket.connect();
        resolve();
      }, 1000 * this.retryCount);
    });
  }
}

module.exports = SocketErrorRecovery;
```

## 性能优化

### 连接管理

```javascript
// utils/connectionManager.js
class ConnectionManager {
  constructor() {
    this.connections = new Map();
    this.maxConnections = 1000;
  }
  
  add(socket) {
    if (this.connections.size >= this.maxConnections) {
      throw new Error('连接数超过限制');
    }
    
    this.connections.set(socket.id, {
      socket,
      createdAt: new Date(),
      lastActivity: new Date()
    });
  }
  
  remove(socketId) {
    this.connections.delete(socketId);
  }
  
  cleanup() {
    const now = new Date();
    for (const [id, connection] of this.connections) {
      if (now - connection.lastActivity > 30 * 60 * 1000) {
        connection.socket.disconnect();
        this.connections.delete(id);
      }
    }
  }
}

module.exports = ConnectionManager;
```

### 消息队列

```javascript
// utils/messageQueue.js
class MessageQueue {
  constructor() {
    this.queue = [];
    this.processing = false;
  }
  
  add(message) {
    this.queue.push(message);
    if (!this.processing) {
      this.process();
    }
  }
  
  async process() {
    this.processing = true;
    
    while (this.queue.length > 0) {
      const message = this.queue.shift();
      try {
        await this.processMessage(message);
      } catch (error) {
        console.error('处理消息错误:', error);
      }
    }
    
    this.processing = false;
  }
  
  async processMessage(message) {
    const { socket, event, data } = message;
    socket.emit(event, data);
  }
}

module.exports = MessageQueue;
```

## 总结

Express Socket.IO 的关键点：

1. **基础配置**
   - 服务器设置
   - 客户端连接
   - 事件系统

2. **高级功能**
   - 房间管理
   - 中间件系统
   - 认证授权

3. **性能优化**
   - 连接管理
   - 消息队列
   - 资源清理

4. **错误处理**
   - 错误捕获
   - 错误恢复
   - 日志记录

5. **最佳实践**
   - 事件命名规范
   - 错误处理策略
   - 性能监控

通过合理使用 Socket.IO 的特性，可以构建出高效、稳定的实时通信系统。记住要注意连接管理和错误处理，以确保系统的可靠性。