---
title: Express Redis
date: 2025-10-15 17:28:48
permalink: /pages/8f6f8e/
categories:
  - 后端
  - Express
  - Express缓存
tags:
  - 
---
## 缓存的重要性

### 1. 性能提升
- 减少数据库查询次数
- 降低服务器响应时间
- 提高并发处理能力

### 2. 资源优化
- 减少数据库负载
- 降低网络带宽使用
- 节省服务器计算资源

### 3. 用户体验
- 更快的页面加载速度
- 更流畅的交互体验
- 减少等待时间

## Redis 安装与配置

### 安装 Redis 客户端

```bash
# ioredis (推荐)
npm install ioredis

# 或使用 redis 客户端
npm install redis
```

### 基本连接配置

```javascript
// config/redis.js
const Redis = require('ioredis');

const redis = new Redis({
  host: 'localhost',
  port: 6379,
  password: '', // 如果有密码
  db: 0,
  retryDelayOnFailover: 100,
  maxRetriesPerRequest: 3
});

module.exports = redis;
```

### 连接池配置

```javascript
// config/redisPool.js
const Redis = require('ioredis');

const redisPool = new Redis.Cluster([
  {
    host: '127.0.0.1',
    port: 6379,
  },
  {
    host: '127.0.0.1',
    port: 6380,
  }
], {
  enableOfflineQueue: false,
  retryDelayOnFailover: 100,
  maxRetriesPerRequest: 3
});

module.exports = redisPool;
```

## Express 中的缓存实现

### 基本缓存中间件

```javascript
// middleware/cache.js
const redis = require('../config/redis');

const cache = (duration = 300) => {
  return async (req, res, next) => {
    const key = req.originalUrl;
    
    try {
      const cached = await redis.get(key);
      if (cached) {
        return res.json(JSON.parse(cached));
      }
      
      // 重写 res.json 以缓存响应
      const originalJson = res.json;
      res.json = function(data) {
        redis.setex(key, duration, JSON.stringify(data));
        return originalJson.call(this, data);
      };
      
      next();
    } catch (error) {
      next();
    }
  };
};

module.exports = cache;
```

### 使用缓存中间件

```javascript
// routes/posts.js
const express = require('express');
const router = express.Router();
const cache = require('../middleware/cache');

// 缓存5分钟
router.get('/posts', cache(300), async (req, res) => {
  const posts = await Post.findAll();
  res.json(posts);
});
```

## 高级缓存策略

### 多层缓存

```javascript
// services/cacheService.js
const redis = require('../config/redis');

class CacheService {
  static async getOrSet(key, fetchFunction, duration = 300) {
    try {
      const cached = await redis.get(key);
      if (cached) {
        return JSON.parse(cached);
      }
      
      const data = await fetchFunction();
      await redis.setex(key, duration, JSON.stringify(data));
      return data;
    } catch (error) {
      return await fetchFunction();
    }
  }
  
  static async invalidate(pattern) {
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
  }
}

module.exports = CacheService;
```

### 缓存更新策略

```javascript
// controllers/postController.js
const CacheService = require('../services/cacheService');

async function updatePost(req, res) {
  try {
    const post = await Post.update(req.params.id, req.body);
    
    // 清除相关缓存
    await CacheService.invalidate('posts:*');
    await CacheService.invalidate(`post:${req.params.id}`);
    
    res.json(post);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
}
```

## 最佳实践

### 1. 缓存键命名规范
```javascript
const cacheKeys = {
  post: (id) => `post:${id}`,
  posts: (page) => `posts:page:${page}`,
  user: (id) => `user:${id}`
};
```

### 2. 缓存时间设置
```javascript
const cacheDurations = {
  short: 60,      // 1分钟
  medium: 300,    // 5分钟
  long: 3600      // 1小时
};
```

### 3. 错误处理
```javascript
const redis = new Redis({
  // ...其他配置
  retryDelayOnFailover: 100,
  maxRetriesPerRequest: 3,
  lazyConnect: true
});

redis.on('error', (error) => {
  console.error('Redis connection error:', error);
});
```

## 性能优化建议

1. **合理设置缓存过期时间**
   - 根据数据更新频率设置
   - 避免缓存雪崩

2. **使用连接池**
   - 避免频繁创建连接
   - 提高连接复用率

3. **监控缓存命中率**
   - 定期分析缓存效果
   - 优化缓存策略

4. **处理缓存穿透**
   - 缓存空值
   - 使用布隆过滤器

## 总结

在 Express 应用中使用缓存，特别是 Redis，可以显著提升应用性能和用户体验。通过合理的缓存策略和实现方式，可以：
- 减少数据库压力
- 提高响应速度
- 支持更高的并发量
- 优化资源使用

记住，缓存不是万能的，需要根据具体业务场景合理使用，并注意维护缓存的一致性。