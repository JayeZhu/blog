---
title: Express 缓存操作
date: 2025-10-15 17:29:17
permalink: /pages/a5f1aa/
categories:
  - 后端
tags:
  - Express
  - Express缓存
---
## Redis 数据类型概述

Redis 支持五种基本数据类型，每种类型都有其特定的使用场景：

| 数据类型 | 特点 | 主要用途 |
|---------|------|----------|
| String | 二进制安全，最大512MB | 缓存、计数器 |
| Hash | 键值对集合 | 存储对象信息 |
| List | 字符串列表，按插入顺序排序 | 消息队列、时间线 |
| Set | 无序字符串集合，元素唯一 | 标签系统、共同好友 |
| Sorted Set | 有序集合，每个元素关联分数 | 排行榜、评分系统 |

## String 操作

### 基本操作

```javascript
const redis = require('ioredis');
const client = new redis();

// 设置和获取值
await client.set('user:1:name', 'John Doe');
const name = await client.get('user:1:name');

// 设置带过期时间的值
await client.setex('session:123', 3600, 'user_data');

// 数字操作
await client.incr('counter');
await client.incrby('counter', 5);
await client.decr('counter');
```

### Express 中的应用

```javascript
// 缓存用户信息
async function cacheUser(userId, userData) {
  await client.setex(`user:${userId}`, 3600, JSON.stringify(userData));
}

// 获取缓存的用户信息
async function getCachedUser(userId) {
  const cached = await client.get(`user:${userId}`);
  return cached ? JSON.parse(cached) : null;
}

// 计数器应用
async function incrementPageViews(pageId) {
  return await client.incr(`pageviews:${pageId}`);
}
```

## Hash 操作

### 基本操作

```javascript
// 设置 Hash 字段
await client.hset('user:1', {
  'name': 'John Doe',
  'email': 'john@example.com',
  'age': '30'
});

// 获取单个字段
const name = await client.hget('user:1', 'name');

// 获取所有字段
const user = await client.hgetall('user:1');

// 删除字段
await client.hdel('user:1', 'age');

// 检查字段是否存在
const exists = await client.hexists('user:1', 'email');
```

### Express 中的应用

```javascript
// 用户会话管理
class SessionManager {
  static async createSession(sessionId, data) {
    await client.hmset(`session:${sessionId}`, data);
    await client.expire(`session:${sessionId}`, 3600);
  }

  static async updateSession(sessionId, field, value) {
    await client.hset(`session:${sessionId}`, field, value);
  }

  static async getSession(sessionId) {
    return await client.hgetall(`session:${sessionId}`);
  }

  static async destroySession(sessionId) {
    await client.del(`session:${sessionId}`);
  }
}
```

## List 操作

### 基本操作

```javascript
// 添加元素到列表
await client.lpush('messages', 'Hello');
await client.rpush('messages', 'World');

// 获取列表范围
const messages = await client.lrange('messages', 0, -1);

// 获取列表长度
const length = await client.llen('messages');

// 弹出元素
const first = await client.lpop('messages');
const last = await client.rpop('messages');
```

### Express 中的应用

```javascript
// 消息队列
class MessageQueue {
  static async enqueue(queueName, message) {
    await client.lpush(queueName, JSON.stringify(message));
  }

  static async dequeue(queueName) {
    const message = await client.rpop(queueName);
    return message ? JSON.parse(message) : null;
  }

  static async getQueueSize(queueName) {
    return await client.llen(queueName);
  }
}

// 时间线实现
class Timeline {
  static async addPost(userId, postId) {
    await client.lpush(`timeline:${userId}`, postId);
    // 只保留最新的100条
    await client.ltrim(`timeline:${userId}`, 0, 99);
  }

  static async getTimeline(userId, start = 0, end = 9) {
    return await client.lrange(`timeline:${userId}`, start, end);
  }
}
```

## Set 操作

### 基本操作

```javascript
// 添加成员
await client.sadd('tags:post:1', 'javascript', 'nodejs', 'redis');

// 获取所有成员
const tags = await client.smembers('tags:post:1');

// 检查成员是否存在
const isMember = await client.sismember('tags:post:1', 'javascript');

// 获取集合大小
const size = await client.scard('tags:post:1');

// 集合运算
await client.sadd('set1', 'a', 'b', 'c');
await client.sadd('set2', 'b', 'c', 'd');

// 交集
const intersection = await client.sinter('set1', 'set2');

// 并集
const union = await client.sunion('set1', 'set2');

// 差集
const difference = await client.sdiff('set1', 'set2');
```

### Express 中的应用

```javascript
// 标签系统
class TagSystem {
  static async addTags(postId, tags) {
    await client.sadd(`tags:post:${postId}`, ...tags);
  }

  static async getTags(postId) {
    return await client.smembers(`tags:post:${postId}`);
  }

  static async getPostsByTag(tag) {
    return await client.smembers(`posts:tag:${tag}`);
  }

  static async getRelatedPosts(postId) {
    const tags = await this.getTags(postId);
    const relatedPosts = await client.sunion(...tags.map(tag => `posts:tag:${tag}`));
    return relatedPosts.filter(id => id !== postId);
  }
}

// 好友系统
class FriendSystem {
  static async addFriend(userId, friendId) {
    await client.sadd(`friends:${userId}`, friendId);
    await client.sadd(`friends:${friendId}`, userId);
  }

  static async getMutualFriends(user1, user2) {
    return await client.sinter(`friends:${user1}`, `friends:${user2}`);
  }

  static async isFriend(userId, friendId) {
    return await client.sismember(`friends:${userId}`, friendId);
  }
}
```

## Sorted Set 操作

### 基本操作

```javascript
// 添加成员和分数
await client.zadd('leaderboard', 100, 'user1', 85, 'user2', 92, 'user3');

// 获取排名范围
const leaders = await client.zrange('leaderboard', 0, 9, 'WITHSCORES');

// 获取分数范围
const topScorers = await client.zrangebyscore('leaderboard', 90, 100, 'WITHSCORES');

// 获取成员排名
const rank = await client.zrank('leaderboard', 'user1');

// 获取成员分数
const score = await client.zscore('leaderboard', 'user1');

// 更新分数
await client.zadd('leaderboard', 95, 'user1');
```

### Express 中的应用

```javascript
// 排行榜系统
class Leaderboard {
  static async updateScore(userId, score) {
    await client.zadd('leaderboard', score, userId);
  }

  static async getTopPlayers(limit = 10) {
    return await client.zrevrange('leaderboard', 0, limit - 1, 'WITHSCORES');
  }

  static async getPlayerRank(userId) {
    return await client.zrevrank('leaderboard', userId);
  }

  static async getPlayersAround(userId, count = 5) {
    const rank = await this.getPlayerRank(userId);
    const start = Math.max(0, rank - Math.floor(count / 2));
    const end = start + count - 1;
    return await client.zrevrange('leaderboard', start, end, 'WITHSCORES');
  }
}

// 评分系统
class RatingSystem {
  static async rateItem(itemId, userId, rating) {
    await client.zadd(`ratings:${itemId}`, rating, userId);
    // 更新平均分
    const ratings = await client.zrange(`ratings:${itemId}`, 0, -1, 'WITHSCORES');
    const average = ratings.reduce((sum, [_, score]) => sum + parseFloat(score), 0) / ratings.length;
    await client.set(`average:${itemId}`, average);
  }

  static async getItemRating(itemId) {
    return await client.get(`average:${itemId}`);
  }

  static async getUserRating(itemId, userId) {
    return await client.zscore(`ratings:${itemId}`, userId);
  }
}
```

## 实际应用场景

### 1. 用户会话管理

```javascript
class UserSession {
  static async create(userId, data) {
    const sessionId = generateSessionId();
    await client.hmset(`session:${sessionId}`, {
      userId,
      ...data
    });
    await client.expire(`session:${sessionId}`, 3600);
    return sessionId;
  }

  static async update(sessionId, data) {
    await client.hmset(`session:${sessionId}`, data);
  }

  static async get(sessionId) {
    return await client.hgetall(`session:${sessionId}`);
  }

  static async destroy(sessionId) {
    await client.del(`session:${sessionId}`);
  }
}
```

### 2. 内容推荐系统

```javascript
class ContentRecommendation {
  static async recordView(userId, contentId) {
    // 记录用户浏览历史
    await client.lpush(`views:${userId}`, contentId);
    await client.ltrim(`views:${userId}`, 0, 99);

    // 更新内容热度
    await client.zincrby('content:hotness', 1, contentId);
  }

  static async getRecommendations(userId, limit = 10) {
    // 获取用户浏览记录
    const views = await client.lrange(`views:${userId}`, 0, -1);
    
    // 获取热门内容
    const hotContent = await client.zrevrange('content:hotness', 0, limit - 1);
    
    // 过滤已浏览内容
    return hotContent.filter(id => !views.includes(id));
  }
}
```

### 3. 实时统计

```javascript
class RealtimeStats {
  static async recordEvent(eventType) {
    const key = `stats:${eventType}:${new Date().toISOString().slice(0, 10)}`;
    await client.incr(key);
    await client.expire(key, 86400 * 7); // 保留7天
  }

  static async getEventStats(eventType, days = 7) {
    const stats = [];
    for (let i = 0; i < days; i++) {
      const date = new Date();
      date.setDate(date.getDate() - i);
      const key = `stats:${eventType}:${date.toISOString().slice(0, 10)}`;
      const count = await client.get(key);
      stats.push({
        date: date.toISOString().slice(0, 10),
        count: count || 0
      });
    }
    return stats;
  }
}
```

## 最佳实践

1. **键命名规范**
   - 使用冒号分隔层级
   - 采用有意义的前缀
   - 保持一致性

2. **数据结构选择**
   - String：简单键值对
   - Hash：对象存储
   - List：有序队列
   - Set：唯一集合
   - Sorted Set：排序需求

3. **过期策略**
   - 设置合理的过期时间
   - 避免内存泄漏
   - 考虑业务场景

4. **性能优化**
   - 使用管道批量操作
   - 合理使用连接池
   - 监控内存使用

## 总结

Redis 的多种数据结构为 Express 应用提供了强大的缓存和数据管理能力。通过合理选择和使用这些数据结构，可以：
- 提高应用性能
- 简化数据操作
- 支持复杂业务场景
- 优化内存使用

在实际应用中，需要根据具体需求选择合适的数据结构，并注意性能优化和数据一致性。