---
title: Express数据验证
date: 2025-10-15 17:17:16
permalink: /pages/03a516/
categories:
  - 后端
tags:
  - Express
  - Express数据持久化
---
## 数据验证的重要性

### 为什么需要数据验证

1. **安全性**：防止恶意输入和注入攻击
2. **数据完整性**：确保数据符合业务规则
3. **用户体验**：提供有意义的错误反馈
4. **系统稳定性**：防止无效数据导致系统错误

### 验证层级

```javascript
// 前端验证 -> 后端验证 -> 数据库验证
app.post('/users', [
  // 1. 前端已验证的基础上
  // 2. 后端再次验证
  validateUserInput,
  // 3. 数据库约束
  createUser
]);
```

## 验证中间件

### 基本验证中间件

```javascript
// middleware/validation.js
const validateUser = (req, res, next) => {
  const { username, email, password } = req.body;
  
  const errors = [];
  
  if (!username || username.length < 3) {
    errors.push('用户名至少需要3个字符');
  }
  
  if (!email || !isValidEmail(email)) {
    errors.push('请提供有效的邮箱地址');
  }
  
  if (!password || password.length < 6) {
    errors.push('密码至少需要6个字符');
  }
  
  if (errors.length > 0) {
    return res.status(400).json({ errors });
  }
  
  next();
};

function isValidEmail(email) {
  const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return re.test(email);
}
```

### 使用验证中间件

```javascript
// routes/users.js
const express = require('express');
const router = express.Router();
const { validateUser } = require('../middleware/validation');

router.post('/users', validateUser, async (req, res) => {
  try {
    const user = await User.create(req.body);
    res.status(201).json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

## 内置验证

### 基本类型验证

```javascript
const validatePost = (req, res, next) => {
  const { title, content, published } = req.body;
  
  // 类型检查
  if (typeof title !== 'string') {
    return res.status(400).json({ error: '标题必须是字符串' });
  }
  
  // 长度验证
  if (title.length < 5 || title.length > 100) {
    return res.status(400).json({ 
      error: '标题长度必须在5-100个字符之间' 
    });
  }
  
  // 布尔值验证
  if (typeof published !== 'boolean') {
    return res.status(400).json({ 
      error: 'published 必须是布尔值' 
    });
  }
  
  // 数组验证
  if (req.body.tags && !Array.isArray(req.body.tags)) {
    return res.status(400).json({ 
      error: 'tags 必须是数组' 
    });
  }
  
  next();
};
```

## Joi 验证库

### 安装和基本使用

```bash
npm install joi
```

```javascript
const Joi = require('joi');

const userSchema = Joi.object({
  username: Joi.string()
    .alphanum()
    .min(3)
    .max(30)
    .required(),
    
  email: Joi.string()
    .email()
    .required(),
    
  password: Joi.string()
    .pattern(new RegExp('^[a-zA-Z0-9]{3,30}$'))
    .required(),
    
  birth_year: Joi.number()
    .integer()
    .min(1900)
    .max(2023),
    
  profile: Joi.object({
    firstName: Joi.string(),
    lastName: Joi.string()
  })
});

// 验证中间件
const validateWithJoi = (schema) => {
  return (req, res, next) => {
    const { error } = schema.validate(req.body);
    if (error) {
      return res.status(400).json({
        error: error.details[0].message
      });
    }
    next();
  };
};

// 使用
app.post('/users', validateWithJoi(userSchema), createUser);
```

### 高级验证规则

```javascript
const advancedSchema = Joi.object({
  // 条件验证
  password: Joi.string().required(),
  confirm_password: Joi.string()
    .valid(Joi.ref('password'))
    .required()
    .messages({
      'any.only': '密码不匹配'
    }),
    
  // 自定义验证
  email: Joi.string()
    .email()
    .custom((value, helpers) => {
      if (value.endsWith('@spam.com')) {
        return helpers.error('email.spam');
      }
      return value;
    })
    .messages({
      'email.spam': '不允许使用垃圾邮件域名'
    }),
    
  // 数组验证
  tags: Joi.array()
    .items(Joi.string())
    .min(1)
    .max(5)
    .unique(),
    
  // 对象验证
  address: Joi.object({
    street: Joi.string().required(),
    city: Joi.string().required(),
    zip: Joi.string().pattern(/^\d{5}$/)
  }).required(),
  
  // 日期验证
  birth_date: Joi.date()
    .max('now')
    .min('1900-01-01')
});
```

## express-validator

### 安装和基本使用

```bash
npm install express-validator
```

```javascript
const { body, validationResult } = require('express-validator');

// 验证规则
const userValidationRules = [
  body('username')
    .isLength({ min: 3 })
    .withMessage('用户名至少需要3个字符')
    .isAlphanumeric()
    .withMessage('用户名只能包含字母和数字'),
    
  body('email')
    .isEmail()
    .withMessage('请提供有效的邮箱地址')
    .normalizeEmail(),
    
  body('password')
    .isLength({ min: 6 })
    .withMessage('密码至少需要6个字符')
    .matches(/\d/)
    .withMessage('密码必须包含至少一个数字'),
    
  body('age')
    .optional()
    .isInt({ min: 18, max: 120 })
    .withMessage('年龄必须在18-120之间')
];

// 验证中间件
const validate = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      errors: errors.array()
    });
  }
  next();
};

// 使用
app.post('/users', userValidationRules, validate, createUser);
```

### 高级验证

```javascript
const advancedValidation = [
  // 自定义验证器
  body('email').custom(async value => {
    const existingUser = await User.findOne({ email: value });
    if (existingUser) {
      throw new Error('邮箱已被使用');
    }
  }),
  
  // 条件验证
  body('confirm_password').custom((value, { req }) => {
    if (value !== req.body.password) {
      throw new Error('密码不匹配');
    }
    return true;
  }),
  
  // 数组验证
  body('tags.*').trim().escape(),
  
  // 文件验证
  body('avatar').custom((value, { req }) => {
    if (!req.file) {
      throw new Error('请上传头像');
    }
    if (!req.file.mimetype.startsWith('image/')) {
      throw new Error('只允许上传图片');
    }
    return true;
  })
];
```

## 自定义验证器

### 创建自定义验证器

```javascript
// validators/customValidators.js
const isValidUsername = (value) => {
  // 自定义用户名验证逻辑
  const usernameRegex = /^[a-zA-Z0-9_]{3,20}$/;
  return usernameRegex.test(value);
};

const isUniqueEmail = async (value) => {
  const user = await User.findOne({ email: value });
  return !user;
};

const isValidPassword = (value) => {
  // 密码强度验证
  const hasUpperCase = /[A-Z]/.test(value);
  const hasLowerCase = /[a-z]/.test(value);
  const hasNumbers = /\d/.test(value);
  const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(value);
  
  return hasUpperCase && hasLowerCase && hasNumbers && hasSpecialChar;
};

module.exports = {
  isValidUsername,
  isUniqueEmail,
  isValidPassword
};
```

### 使用自定义验证器

```javascript
const { isValidUsername, isUniqueEmail, isValidPassword } = require('../validators/customValidators');

const customValidation = [
  body('username')
    .custom(isValidUsername)
    .withMessage('用户名格式不正确'),
    
  body('email')
    .custom(isUniqueEmail)
    .withMessage('邮箱已被使用'),
    
  body('password')
    .custom(isValidPassword)
    .withMessage('密码必须包含大小写字母、数字和特殊字符')
];
```

## 错误处理

### 统一错误处理

```javascript
// middleware/errorHandler.js
const handleValidationError = (err, req, res, next) => {
  if (err.name === 'ValidationError') {
    const errors = Object.values(err.errors).map(e => ({
      field: e.path,
      message: e.message
    }));
    
    return res.status(400).json({
      error: 'Validation Error',
      details: errors
    });
  }
  next(err);
};

// 使用
app.use(handleValidationError);
```

### 自定义错误响应

```javascript
const formatValidationErrors = (errors) => {
  return errors.reduce((acc, error) => {
    acc[error.param] = error.msg;
    return acc;
  }, {});
};

const validationHandler = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      status: 'error',
      message: 'Validation failed',
      errors: formatValidationErrors(errors.array())
    });
  }
  next();
};
```

## 最佳实践

### 1. 验证策略

```javascript
// 分层验证
const validateRequest = {
  // 基础验证
  basic: [
    body('email').isEmail(),
    body('password').isLength({ min: 6 })
  ],
  
  // 详细验证
  detailed: [
    body('email').isEmail().normalizeEmail(),
    body('password').isLength({ min: 6 })
      .matches(/\d/)
      .withMessage('密码必须包含数字'),
    body('username').isAlphanumeric()
  ],
  
  // 严格验证
  strict: [
    ...validateRequest.detailed,
    body('email').custom(isUniqueEmail),
    body('username').custom(isUniqueUsername)
  ]
};
```

### 2. 验证中间件组合

```javascript
const composeValidators = (...validators) => {
  return async (req, res, next) => {
    await Promise.all(validators.map(validator => validator.run(req)));
    
    const errors = validationResult(req);
    if (errors.isEmpty()) {
      return next();
    }
    
    res.status(400).json({
      status: 'error',
      errors: errors.array()
    });
  };
};

// 使用
app.post('/users', 
  composeValidators(
    body('email').isEmail(),
    body('password').isLength({ min: 6 })
  ),
  createUser
);
```

### 3. 异步验证

```javascript
const asyncValidation = async (req, res, next) => {
  try {
    // 检查用户名是否已存在
    const existingUser = await User.findOne({ 
      username: req.body.username 
    });
    
    if (existingUser) {
      return res.status(400).json({
        error: '用户名已被使用'
      });
    }
    
    // 检查邮箱是否已存在
    const existingEmail = await User.findOne({ 
      email: req.body.email 
    });
    
    if (existingEmail) {
      return res.status(400).json({
        error: '邮箱已被使用'
      });
    }
    
    next();
  } catch (error) {
    next(error);
  }
};
```

### 4. 性能优化

```javascript
// 缓存验证规则
const cachedValidationRules = {
  user: Joi.object({
    username: Joi.string().min(3).max(30),
    email: Joi.string().email()
  })
};

// 使用缓存
const validateUser = validateWithJoi(cachedValidationRules.user);
```

## 总结

在 Express.js 中实现数据验证是确保应用程序安全性和可靠性的关键步骤。通过合理使用内置验证、Joi、express-validator 等工具，可以构建出健壮的验证系统。记住：

1. 始终在服务器端进行验证，不要仅依赖前端验证
2. 提供清晰的错误信息，帮助用户理解问题
3. 使用适当的验证中间件，保持代码整洁
4. 考虑性能影响，避免过度验证
5. 定期审查和更新验证规则

通过遵循这些最佳实践，可以构建出安全、可靠且用户友好的应用程序。