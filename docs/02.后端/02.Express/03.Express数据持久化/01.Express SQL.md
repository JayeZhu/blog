---
title: Express SQL
date: 2025-10-15 17:07:27
permalink: /pages/f48337/
categories:
  - 后端
tags:
  - Express
  - Express数据持久化
---
## SQL 数据库选择

### 主流 SQL 数据库对比

| 数据库 | 特点 | 适用场景 |
|--------|------|----------|
| MySQL | 开源，性能优秀 | Web应用，中小型企业 |
| PostgreSQL | 功能丰富，扩展性强 | 复杂查询，数据分析 |
| SQLite | 轻量级，无需服务器 | 小型应用，移动应用 |
| SQL Server | 微软生态，商业支持 | 企业级应用 |

### 推荐选择

对于大多数 Express.js 项目，推荐使用 MySQL 或 PostgreSQL：
- MySQL：适合传统 Web 应用，性能优秀
- PostgreSQL：适合需要复杂查询和数据分析的场景

## 环境准备

### 安装依赖

```bash
# MySQL
npm install mysql2

# PostgreSQL
npm install pg

# 通用连接池
npm install generic-pool

# ORM (可选)
npm install sequelize
npm install typeorm
```

### 基本配置

```javascript
// config/database.js
module.exports = {
  development: {
    host: 'localhost',
    database: 'blog_db',
    username: 'root',
    password: 'password',
    dialect: 'mysql'
  },
  production: {
    host: process.env.DB_HOST,
    database: process.env.DB_NAME,
    username: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    dialect: 'mysql'
  }
};
```

## 连接池配置

### 创建连接池

```javascript
// db/pool.js
const mysql = require('mysql2/promise');
const config = require('../config/database');

const pool = mysql.createPool({
  ...config.development,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

module.exports = pool;
```

### 使用连接池

```javascript
// services/userService.js
const pool = require('../db/pool');

async function getUser(id) {
  const connection = await pool.getConnection();
  try {
    const [rows] = await connection.execute(
      'SELECT * FROM users WHERE id = ?',
      [id]
    );
    return rows[0];
  } finally {
    connection.release();
  }
}
```

## 使用 ORM

### Sequelize 示例

```javascript
// models/User.js
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const User = sequelize.define('User', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  username: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
    validate: {
      isEmail: true
    }
  },
  createdAt: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW
  }
});

module.exports = User;
```

### 使用模型

```javascript
// controllers/userController.js
const User = require('../models/User');

async function createUser(req, res) {
  try {
    const user = await User.create({
      username: req.body.username,
      email: req.body.email
    });
    res.status(201).json(user);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
}
```

## 原生 SQL 查询

### 基本查询

```javascript
// services/postService.js
const pool = require('../db/pool');

class PostService {
  static async findAll() {
    const [rows] = await pool.execute(
      'SELECT * FROM posts ORDER BY created_at DESC'
    );
    return rows;
  }

  static async findById(id) {
    const [rows] = await pool.execute(
      'SELECT * FROM posts WHERE id = ?',
      [id]
    );
    return rows[0];
  }

  static async create(data) {
    const [result] = await pool.execute(
      'INSERT INTO posts (title, content, author_id) VALUES (?, ?, ?)',
      [data.title, data.content, data.authorId]
    );
    return result.insertId;
  }
}
```

### 复杂查询

```javascript
static async findWithComments(postId) {
  const [rows] = await pool.execute(`
    SELECT 
      p.*,
      c.id as comment_id,
      c.content as comment_content,
      c.created_at as comment_created_at,
      u.username as comment_author
    FROM posts p
    LEFT JOIN comments c ON p.id = c.post_id
    LEFT JOIN users u ON c.user_id = u.id
    WHERE p.id = ?
    ORDER BY c.created_at ASC
  `, [postId]);
  
  return rows;
}
```

## 事务处理

### 简单事务

```javascript
async function transferFunds(fromId, toId, amount) {
  const connection = await pool.getConnection();
  try {
    await connection.beginTransaction();
    
    // 扣除源账户金额
    await connection.execute(
      'UPDATE accounts SET balance = balance - ? WHERE id = ?',
      [amount, fromId]
    );
    
    // 增加目标账户金额
    await connection.execute(
      'UPDATE accounts SET balance = balance + ? WHERE id = ?',
      [amount, toId]
    );
    
    await connection.commit();
  } catch (error) {
    await connection.rollback();
    throw error;
  } finally {
    connection.release();
  }
}
```

### Sequelize 事务

```javascript
async function createPostWithComments(postData, comments) {
  const transaction = await sequelize.transaction();
  
  try {
    const post = await Post.create(postData, { transaction });
    
    for (const comment of comments) {
      await Comment.create({
        ...comment,
        postId: post.id
      }, { transaction });
    }
    
    await transaction.commit();
    return post;
  } catch (error) {
    await transaction.rollback();
    throw error;
  }
}
```

## 错误处理

### 全局错误处理中间件

```javascript
// middleware/errorHandler.js
module.exports = (err, req, res, next) => {
  console.error(err.stack);
  
  if (err.code === 'ER_DUP_ENTRY') {
    return res.status(400).json({
      error: 'Duplicate entry'
    });
  }
  
  if (err.code === 'ER_NO_REFERENCED_ROW_2') {
    return res.status(400).json({
      error: 'Referenced row not found'
    });
  }
  
  res.status(500).json({
    error: 'Internal server error'
  });
};
```

### 服务层错误处理

```javascript
class UserService {
  static async create(userData) {
    try {
      const user = await User.create(userData);
      return user;
    } catch (error) {
      if (error.name === 'SequelizeUniqueConstraintError') {
        throw new Error('Username already exists');
      }
      throw error;
    }
  }
}
```

## 性能优化

### 查询优化

```javascript
// 使用索引
const [rows] = await pool.execute(`
  SELECT * FROM posts 
  WHERE author_id = ? 
  ORDER BY created_at DESC 
  LIMIT 10
`, [authorId]);

// 避免N+1查询
const [rows] = await pool.execute(`
  SELECT 
    p.*,
    u.username
  FROM posts p
  JOIN users u ON p.author_id = u.id
  WHERE p.category = ?
`, [category]);
```

### 缓存策略

```javascript
const redis = require('redis');
const client = redis.createClient();

async function getCachedPosts() {
  const cached = await client.get('posts');
  if (cached) {
    return JSON.parse(cached);
  }
  
  const posts = await PostService.findAll();
  await client.setex('posts', 300, JSON.stringify(posts));
  return posts;
}
```

### 连接池优化

```javascript
const pool = mysql.createPool({
  // ...其他配置
  connectionLimit: 20,        // 根据服务器配置调整
  acquireTimeout: 60000,      // 获取连接超时时间
  timeout: 60000,             // 查询超时时间
  reconnect: true,            // 自动重连
  idleTimeout: 300000         // 空闲连接超时
});
```

## 最佳实践

1. **使用连接池**：避免频繁创建和销毁数据库连接
2. **合理使用索引**：为常用查询字段添加索引
3. **避免N+1查询**：使用JOIN或批量查询
4. **使用事务**：确保数据一致性
5. **实现缓存**：减少数据库压力
6. **错误处理**：妥善处理数据库错误
7. **查询优化**：使用EXPLAIN分析查询性能
8. **定期维护**：定期优化数据库表结构

## 总结

在 Express.js 中使用 SQL 数据库需要考虑多个方面，从基本的连接配置到高级的性能优化。选择合适的工具（ORM或原生SQL）并遵循最佳实践，可以构建出高性能、可维护的应用程序。记住，数据库设计是整个应用的基础，值得投入时间来规划和优化。