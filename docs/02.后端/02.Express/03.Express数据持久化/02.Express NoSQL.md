---
title: Express NoSQL
date: 2025-10-15 17:11:37
permalink: /pages/94db0c/
categories:
  - 后端
tags:
  - Express
  - Express数据持久化
---
## NoSQL 数据库选择

### 主流 NoSQL 数据库对比

| 数据库类型 | 代表数据库 | 特点 | 适用场景 |
|------------|------------|------|----------|
| 文档数据库 | MongoDB | 灵活模式，JSON格式 | 内容管理，博客系统 |
| 键值存储 | Redis | 高性能，内存存储 | 缓存，会话存储 |
| 列族数据库 | Cassandra | 高可扩展性 | 大数据，时序数据 |
| 图数据库 | Neo4j | 关系导向 | 社交网络，推荐系统 |

### 推荐选择

对于大多数 Express.js 项目，推荐使用 MongoDB：
- 文档型数据库与 JavaScript 对象天然契合
- 丰富的查询功能
- 强大的聚合框架
- 活跃的社区支持

## 环境准备

### 安装依赖

```bash
# MongoDB 驱动
npm install mongodb

# Mongoose ODM
npm install mongoose

# Redis (可选，用于缓存)
npm install redis
```

### 基本配置

```javascript
// config/database.js
module.exports = {
  development: {
    mongodb: {
      uri: 'mongodb://localhost:27017/blog_db',
      options: {
        useNewUrlParser: true,
        useUnifiedTopology: true
      }
    }
  },
  production: {
    mongodb: {
      uri: process.env.MONGODB_URI,
      options: {
        useNewUrlParser: true,
        useUnifiedTopology: true
      }
    }
  }
};
```

## MongoDB 集成

### 基本连接

```javascript
// db/connection.js
const { MongoClient } = require('mongodb');
const config = require('../config/database');

class Database {
  constructor() {
    this.client = null;
    this.db = null;
  }

  async connect() {
    this.client = new MongoClient(
      config.development.mongodb.uri,
      config.development.mongodb.options
    );
    
    await this.client.connect();
    this.db = this.client.db();
    console.log('Connected to MongoDB');
  }

  async disconnect() {
    await this.client.close();
  }

  getCollection(name) {
    return this.db.collection(name);
  }
}

module.exports = new Database();
```

### 使用原生驱动

```javascript
// services/userService.js
const db = require('../db/connection');

class UserService {
  static async create(userData) {
    const collection = db.getCollection('users');
    const result = await collection.insertOne(userData);
    return result.ops[0];
  }

  static async findById(id) {
    const collection = db.getCollection('users');
    return await collection.findOne({ _id: ObjectId(id) });
  }

  static async update(id, updateData) {
    const collection = db.getCollection('users');
    const result = await collection.updateOne(
      { _id: ObjectId(id) },
      { $set: updateData }
    );
    return result.modifiedCount > 0;
  }
}
```

## Mongoose ODM

### 模型定义

```javascript
// models/User.js
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  profile: {
    name: String,
    avatar: String,
    bio: String
  },
  posts: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Post'
  }],
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// 添加实例方法
userSchema.methods.getPublicProfile = function() {
  return {
    username: this.username,
    profile: this.profile,
    createdAt: this.createdAt
  };
};

// 添加静态方法
userSchema.statics.findByUsername = function(username) {
  return this.findOne({ username });
};

module.exports = mongoose.model('User', userSchema);
```

### 使用模型

```javascript
// controllers/userController.js
const User = require('../models/User');

async function createUser(req, res) {
  try {
    const user = new User({
      username: req.body.username,
      email: req.body.email,
      profile: req.body.profile
    });
    
    await user.save();
    res.status(201).json(user.getPublicProfile());
  } catch (error) {
    if (error.code === 11000) {
      return res.status(400).json({ error: 'Username already exists' });
    }
    res.status(400).json({ error: error.message });
  }
}
```

## 数据建模

### 嵌入式文档

```javascript
const postSchema = new mongoose.Schema({
  title: String,
  content: String,
  comments: [{
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    content: String,
    createdAt: {
      type: Date,
      default: Date.now
    }
  }]
});
```

### 引用式文档

```javascript
const commentSchema = new mongoose.Schema({
  post: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Post',
    required: true
  },
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  content: {
    type: String,
    required: true
  }
});
```

### 混合模式

```javascript
const authorSchema = new mongoose.Schema({
  name: String,
  email: String,
  profile: {
    bio: String,
    social: {
      twitter: String,
      github: String
    }
  },
  posts: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Post'
  }]
});
```

## 查询操作

### 基本查询

```javascript
// 查找所有用户
const users = await User.find();

// 条件查询
const activeUsers = await User.find({ 
  status: 'active',
  'profile.age': { $gte: 18 }
});

// 排序和分页
const paginatedUsers = await User.find()
  .sort({ createdAt: -1 })
  .skip(10)
  .limit(10);

// 字段选择
const userProfiles = await User.find(
  {},
  'username profile.name profile.avatar'
);
```

### 高级查询

```javascript
// 使用正则表达式
const searchResults = await User.find({
  username: new RegExp(searchTerm, 'i')
});

// 使用操作符
const recentPosts = await Post.find({
  createdAt: {
    $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
  },
  tags: { $in: ['javascript', 'nodejs'] }
});

// 数组查询
const popularPosts = await Post.find({
  likes: { $size: { $gte: 100 } }
});

// 地理位置查询
const nearbyUsers = await User.find({
  location: {
    $near: {
      $geometry: {
        type: 'Point',
        coordinates: [longitude, latitude]
      },
      $maxDistance: 1000
    }
  }
});
```

## 聚合管道

### 基本聚合

```javascript
// 统计用户数量
const stats = await User.aggregate([
  {
    $group: {
      _id: null,
      totalUsers: { $sum: 1 },
      activeUsers: {
        $sum: { $cond: [{ $eq: ['$status', 'active'] }, 1, 0] }
      }
    }
  }
]);

// 按月统计文章数量
const monthlyStats = await Post.aggregate([
  {
    $group: {
      _id: {
        year: { $year: '$createdAt' },
        month: { $month: '$createdAt' }
      },
      count: { $sum: 1 }
    }
  },
  { $sort: { '_id.year': -1, '_id.month': -1 } }
]);
```

### 复杂聚合

```javascript
// 获取用户及其最新文章
const userWithLatestPost = await User.aggregate([
  {
    $lookup: {
      from: 'posts',
      localField: '_id',
      foreignField: 'author',
      as: 'posts'
    }
  },
  {
    $project: {
      username: 1,
      email: 1,
      latestPost: { $arrayElemAt: ['$posts', -1] }
    }
  }
]);

// 计算文章平均评分
const postRatings = await Post.aggregate([
  {
    $unwind: '$ratings'
  },
  {
    $group: {
      _id: '$_id',
      title: { $first: '$title' },
      avgRating: { $avg: '$ratings.score' },
      totalRatings: { $sum: 1 }
    }
  },
  {
    $match: {
      totalRatings: { $gte: 5 }
    }
  }
]);
```

## 性能优化

### 索引优化

```javascript
// 创建索引
await User.collection.createIndex({ username: 1 });
await User.collection.createIndex({ email: 1 }, { unique: true });

// 复合索引
await Post.collection.createIndex({ author: 1, createdAt: -1 });

// 文本索引
await Post.collection.createIndex({ 
  title: 'text', 
  content: 'text' 
});

// 地理空间索引
await User.collection.createIndex({ 
  location: '2dsphere' 
});
```

### 查询优化

```javascript
// 使用投影减少数据传输
const users = await User.find(
  {},
  { username: 1, email: 1 }
);

// 使用 lean() 提高查询性能
const posts = await Post.find().lean();

// 使用批量操作
const bulkOps = users.map(user => ({
  updateOne: {
    filter: { _id: user._id },
    update: { $set: { lastLogin: new Date() } }
  }
}));

await User.bulkWrite(bulkOps);
```

### 缓存策略

```javascript
const redis = require('redis');
const client = redis.createClient();

async function getCachedPost(id) {
  // 尝试从缓存获取
  const cached = await client.get(`post:${id}`);
  if (cached) {
    return JSON.parse(cached);
  }

  // 从数据库获取
  const post = await Post.findById(id);
  
  // 存入缓存
  await client.setex(`post:${id}`, 3600, JSON.stringify(post));
  
  return post;
}
```

## 最佳实践

1. **数据建模**
   - 合理使用嵌入和引用
   - 避免过深的嵌套
   - 考虑查询模式设计文档结构

2. **索引策略**
   - 为常用查询字段创建索引
   - 使用复合索引优化多字段查询
   - 定期分析索引使用情况

3. **查询优化**
   - 使用投影减少数据传输
   - 避免全表扫描
   - 合理使用聚合管道

4. **性能优化**
   - 实现适当的缓存策略
   - 使用连接池
   - 监控数据库性能

5. **错误处理**
   - 实现适当的错误处理
   - 处理重复键错误
   - 验证数据完整性

## 总结

在 Express.js 中使用 NoSQL 数据库，特别是 MongoDB，可以充分利用其灵活性和强大的查询能力。通过合理的数据建模、索引设计和查询优化，可以构建出高性能的应用程序。记住，NoSQL 数据库的设计理念与传统关系型数据库不同，需要根据具体需求选择合适的数据结构和查询策略。