---
title: Electron进程通信
date: 2025-10-20 11:46:44
permalink: /pages/0cb8ea/
categories:
  - 后端
tags:
  - Electron
  - Electron核心
---
Electron是一个基于Chromium和Node.js的开源框架，用于构建跨平台桌面应用程序。在Electron应用中，进程间通信(IPC)是实现数据共享和交互的关键机制，因为应用由主进程和一个或多个渲染进程组成，它们各自承担不同的职责。

## Electron进程模型概述

Electron应用包含两种主要进程：
- **主进程**：负责管理应用程序的生命周期和创建窗口
- **渲染进程**：负责呈现窗口内容，类似于浏览器中的网页

由于这两种进程有不同的职责和权限，IPC成为执行许多常见任务的唯一方法，例如从UI调用原生API或从原生菜单触发Web内容的更改。

## IPC通道

在Electron中，进程通过开发者定义的"通道"传递消息进行通信，使用`ipcMain`和`ipcRenderer`模块。这些通道是：
- 任意命名（可以随意命名）
- 双向的（可以在两个模块中使用相同的通道名称）

## 常见通信模式

### 模式1：渲染器进程到主进程（单向）

使用`ipcRenderer.send`发送单向消息，由`ipcMain.on`接收。常用于从Web内容调用主进程API。

```javascript
// 主进程
ipcMain.on('set-title', (event, title) => {
  const webContents = event.sender
  const win = BrowserWindow.fromWebContents(webContents)
  win.setTitle(title)
})

// 预加载脚本
contextBridge.exposeInMainWorld('electronAPI', {
  setTitle: (title) => ipcRenderer.send('set-title', title)
})

// 渲染进程
setButton.addEventListener('click', () => {
  const title = titleInput.value
  window.electronAPI.setTitle(title)
})
```


### 模式2：渲染器进程到主进程（双向）

使用`ipcRenderer.invoke`与`ipcMain.handle`配对，实现双向通信。常用于从渲染器调用主进程模块并等待结果。

```javascript
// 主进程
async function handleFileOpen() {
  const { canceled, filePaths } = await dialog.showOpenDialog()
  if (!canceled) {
    return filePaths[0]
  }
}
ipcMain.handle('dialog:openFile', handleFileOpen)

// 预加载脚本
contextBridge.exposeInMainWorld('electronAPI', {
  openFile: () => ipcRenderer.invoke('dialog:openFile')
})

// 渲染进程
btn.addEventListener('click', async () => {
  const filePath = await window.electronAPI.openFile()
  filePathElement.innerText = filePath
})
```


### 模式3：主进程到渲染器进程

使用`webContents.send`方法将消息从主进程发送到特定渲染器进程。

```javascript
// 主进程
const menu = Menu.buildFromTemplate([
  {
    label: app.name,
    submenu: [
      {
        click: () => mainWindow.webContents.send('update-counter', 1),
        label: 'Increment'
      }
    ]
  }
])

// 预加载脚本
contextBridge.exposeInMainWorld('electronAPI', {
  onUpdateCounter: (callback) => ipcRenderer.on('update-counter', (_event, value) => callback(value))
})

// 渲染进程
window.electronAPI.onUpdateCounter((value) => {
  const oldValue = Number(counter.innerText)
  const newValue = oldValue + value
  counter.innerText = newValue.toString()
})
```


### 模式4：渲染器进程到渲染器进程

没有直接方法在渲染器进程间通信，有两种选择：
1. 将主进程作为消息代理
2. 从主进程向两个渲染器传递MessagePort，实现直接通信



## 安全注意事项

出于安全原因，不应直接暴露整个`ipcRenderer`API。应使用`contextBridge`API选择性地暴露必要的API，并尽可能限制渲染器对Electron API的访问。

## 对象序列化

Electron的IPC实现使用HTML标准的结构化克隆算法序列化进程间传递的对象。这意味着只有某些类型的对象可以通过IPC通道传递。DOM对象、Node.js中由C++类支持的对象和Electron中由C++类支持的对象无法使用结构化克隆序列化。

## 总结

Electron的IPC机制是构建功能丰富的桌面应用程序的关键部分。通过理解不同的通信模式和安全实践，开发者可以有效地在主进程和渲染进程之间传递数据，实现复杂的应用程序功能。