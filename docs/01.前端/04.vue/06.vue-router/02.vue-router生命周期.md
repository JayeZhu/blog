---
title: vue-router生命周期
date: 2021-07-01 10:58:07
permalink: /pages/eaa5be/
categories:
  - 前端
tags:
  - vue
  - vue-router
---
## Vue-Router 导航守卫
有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。

为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的

## 全局路由钩子
全局有三个路由钩子;
- router.beforeEach 全局前置守卫 进入路由之前
- router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用
- router.afterEach 全局后置钩子 进入路由之后
具体使用∶
### beforeEach
判断是否登录了，没登录就跳转到登录页
```js
router.beforeEach((to, from, next) => {  
  let ifInfo = Vue.prototype.$common.getSession('userData');  // 判断是否登录的存储信息
  if (!ifInfo) { 
    // sessionStorage里没有储存user信息    
    if (to.path == '/') { 
      //如果是登录页面路径，就直接next()      
      next();    
    } else { 
      //不然就跳转到登录      
      Message.warning("请重新登录！");     
      window.location.href = Vue.prototype.$loginUrl;
    }
  } else {
    return next();
  }
})
```
### afterEach
跳转之后滚动条回到顶部
```js
router.afterEach((to, from) => {  
  // 跳转之后滚动条回到顶部  
  window.scrollTo(0,0);
});
```
## 单个路由独享钩子
### beforeEnter
如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next
```js
export default [    
  {        
    path: '/',        
    name: 'login',        
    component: login,        
    beforeEnter: (to, from, next) => {          
      console.log('即将进入登录页面')          
      next()        
    }    
  }
]
```
## 组件内钩子
有 beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave 三个钩子

这三个钩子都有三个参数∶to、from、next
- beforeRouteEnter∶ 进入组件前触发
- beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用
- beforeRouteLeave∶ 离开组件被调用
注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：

## Vue路由钩子在生命周期函数的体现
### 完整的路由导航解析流程
不包括其他生命周期
- 触发进入其他路由。
- 调用要离开路由的组件守卫beforeRouteLeave
- 调用局前置守卫∶ beforeEach
- 在重用的组件里调用 beforeRouteUpdate
- 调用路由独享守卫 beforeEnter。
- 解析异步路由组件。
- 在将要进入的路由组件中调用 beforeRouteEnter
- 调用全局解析守卫 beforeResolve
- 导航被确认。
- 调用全局后置钩子的 afterEach 钩子。
- 触发DOM更新（mounted）。
- 执行beforeRouteEnter 守卫中传给 next 的回调函数

### 触发钩子的完整顺序
路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶
- beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。
- beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。
- beforeEnter：路由独享守卫
- beforeRouteEnter：路由组件的组件进入路由前钩子。
- beforeResolve：路由全局解析守卫
- afterEach：路由全局后置钩子
- beforeCreate：组件生命周期，不能访问tAis。
- created;组件生命周期，可以访问tAis，不能访问dom。
- beforeMount：组件生命周期
- deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。
- mounted：访问/操作dom。
- activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。
- 执行beforeRouteEnter回调函数next。

### 导航行为被触发到导航完成的整个过程
- 导航行为被触发，此时导航未被确认。
- 在失活的组件里调用离开守卫 beforeRouteLeave。
- 调用全局的 beforeEach守卫。
- 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。
- 在路由配置里调用 beforeEnteY。 
- 解析异步路由组件（如果有）。
- 在被激活的组件里调用 beforeRouteEnter。
- 调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。
- 导航被确认。
- 调用全局的 afterEach 钩子。
- 非重用组件，开始组件实例的生命周期：beforeCreate&created、beforeMount&mounted
- 触发 DOM 更新。
- 用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。
- 导航完成