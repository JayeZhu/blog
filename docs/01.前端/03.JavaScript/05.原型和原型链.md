---
title: 原型和原型链
date: 2021-05-14 16:05:10
permalink: /pages/ec05da/
categories:
  - 前端
tags:
  - JavaScript
---
## 前言
原型和原型链是没有深入理解 JS 前忽略的东西，他们能有效帮助我们理解引用类型间的关系，并且是 JS 实现继承的重要方式。

## 原型
JS中的原型是JS对象的一个特殊属性，这个属性的作用是用来实现属性和方法的`继承`。

### 什么对象有原型
有一个JS对象是没有原型的，就是 null。

### 原型如何产生
每一个JS对象（非null）被创建时，都会和另外一个对象进行关联，这个被关联的对象就是它的原型。

### 原型种类
#### 显式原型
显式原型是 prototype，函数对象独有的属性。每一个函数被创建的时候都会获得这个属性，它指向一个对象，这个对象包含可以由该函数的所有实例共享的属性和方法。
```js
function Person (name) {
  this.name = name;
}

// 产生了 prototype
Person.prototype.getName = function () {
  return this.name;
}

const person = new Person('Jaye');
person.getName(); // Jaye
```
#### 隐式原型
每一个实例对象都有一个 proto 属性，可以通过
- __proto__
- Object.getPrototypeOf()
进行访问。

```js
person.__proto__.setName = function (name) {
  this.name = name;
}
person.setName('Jarry');
person.getName(); // Jarry
```
隐式原型指向其构造函数的 prototype对象
```js
console.log(person.__proto__ === Person.prototype) // true
console.log(Object.getPrototypeOf(person) === Person.prototype) // true
```

## 原型链
原型链是多个对象通过 __proto__ 链接形成的链式结构。

### 原型链有什么作用
原型链方便对象属性的访问，访问规则如下
- 首先在对象自身属性上查找
- 自身属性上没有，就在 __proto__ 向上查找其原型对象
- 原型对象上没有，就在原型对象的原型上继续寻找
- 这个过程会一直持续，直到找到属性，或者一直找到原型链的尽头，也就是没有原型的对象 null，然后返回 undefined

以刚刚构建的实例 person 举例
```js
// 实例的原型指向其构造函数的原型对象
console.log(person.__proto__ === Person.prototype); // true
// Person是构造函数，它的原型指向 Object 的原型
console.log(Person.prototype.__proto__ === Object.prototype); // true
// 而 Object 的原型就指向了 null
console.log(Object.prototype.__proto__); // null
```

## 从原型链理清构造函数、原型和实例的关系
从上述的例子中，重新确认一下几个观念
- 构造函数：通过关键字 new 来创建实例对象的函数，比如 Person
- 实例：通过关键字 new 构造函数创建出来的对象，比如 person
- 原型：原型对象，构造函数的 prototype 属性所指向的对象，用于存放实例共享的属性和方法

他们的关系如下：
- 实例的隐式原型指向其构造函数的显示原型      person.__proto__ === Person.prototype
- 原型对象的 constructor 属性指向构造函数   Person.prototype.constructor === Person
- 实例通过 constructor 找到构造函数        person.constructor === Person

## 原型继承
JS的继承主要是通过原型来实现的

```js
Person.prototype.work = function () {
  console.log('work');
}

// 子类进行继承
function Man (age) {
  this.age = age;
}

Man.prototype = new Person(); // 子类原型指向父类构造函数构建的实例
Man.prototype.constructor = Man; // 变更子类的constructor指针，重新指向子类
Man.prototype.getAge = function () {
  return this.age;
}
const man1 = new Man('18');
man1.work(); // work
man1.getAge(); // 18
man1.name = 'Evan';
man1.getName(); // Evan
```

## 原型和原型链的实践

### 扩展内置对象
可以对内置对象增加属性，进而扩展功能
```js
// 为数组添加一个求和方法
Array.prototype.sum = function() {
  return this.reduce((total, num) => total + num, 0);
};
const arr = [1, 2, 3];
console.log(arr.sum()); // 6
```

### 修改内置对象
将对象的原生属性进行修改
```js
Array.prototype.toString = function () {
  return this.length;
}
const arr = [1, 2, 3];
console.log(arr.toString()); // 3
```

### 实现继承
同上原型继承

### 节省内存
显式原型指向一个对象，这个对象包含可以由该函数的所有实例共享的属性和方法。现在有一个新的方法，这个方法如果定义在构造函数中，每一个实例都会创建这个方法的副本，但是如果放在原型上就不会。

```js
function InnerFn (name) {
  this.name = name;
  this.sayName = function () { // 这个方法会被每一个实例创建
    console.log(this.name)
  }
}

function OuterFn (name) {
  this.name = name;
}
OuterFn.prototype.sayName = function () { // 这个方法不会被每一个实例创建
  console.log(this.name)
}

```