---
title: TS严格模式
date: 2025-10-11 16:29:02
permalink: /pages/c76313/
categories:
  - 前端
tags:
  - TypeScript
  - TS进阶
---
:::tip
TypeScript 的严格模式是一系列编译选项的集合，旨在提供更强的类型检查，帮助开发者在编译阶段发现潜在错误。开启严格模式是提升代码质量的关键步骤。
:::
<!-- more -->

## 开启严格模式
TypeScript 的配置项都写在项目根目录名为 tsconfig.json的配置文件中，可以通过以下方式开启严格模式：

```json
{
  "compilerOptions": {
    "strict": true
  }
}
```
当开启 strict选项后，相当于同时开启了以下 7 个严格模式子选项：

```json
{
  "compilerOptions": {
    "noImplicitAny": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "strictBindCallApply": true,
    "strictNullChecks": true,
    "strictPropertyInitialization": true,
    "strictFunctionTypes": true
  }
}
```

## noImplicitAny
此规则不允许变量或函数参数具有隐式 any类型。

### 问题示例
```typescript
// 未开启 noImplicitAny
function add10(num) {  // num 隐式具有 any 类型
  return num + 10;
}

const result = add10(5);
console.log(result);
```

### 严格模式下的错误
```typescript
// 开启 noImplicitAny 后
function add10(num) {  // ❌ 错误：参数“num”隐式具有“any”类型
  return num + 10;
}
解决方案
typescript
复制
// 显式指定参数类型
function add10(num: number): number {
  return num + 10;
}

// 或者使用类型注解
const add10 = (num: number): number => num + 10;
```

## noImplicitThis
此规则不允许 this隐式定义上下文。

### 问题示例
```typescript
class Person {
  weight: number;
  height: number;
  
  constructor(weight: number, height: number) {
    this.weight = weight;
    this.height = height;
  }
  
  getBodyMassIndex() {
    return function() {
      // this 指向不明确
      return this.weight / (this.height * this.height);
    };
  }
}

const person = new Person(70, 1.75);
const bmiFunction = person.getBodyMassIndex();
console.log(bmiFunction());  // ❌ 运行时错误：Cannot read properties of undefined
```

### 严格模式下的错误
```typescript
getBodyMassIndex() {
  return function() {
    return this.weight / (this.height * this.height); 
    // ❌ 错误：“this”隐式具有类型“any”，因为它没有类型注释
  };
}
```

### 解决方案
```typescript
// 方案1：使用箭头函数
getBodyMassIndex() {
  return () => {
    return this.weight / (this.height * this.height);
  };
}

// 方案2：显式指定 this 类型
getBodyMassIndex() {
  return function(this: Person) {
    return this.weight / (this.height * this.height);
  };
}

// 方案3：使用 bind
getBodyMassIndex() {
  return function() {
    return this.weight / (this.height * this.height);
  }.bind(this);
}
```

## alwaysStrict
此规则指定始终以严格模式检查每个模块，并在编译后的 JS 文件中加入 "use strict"。

### 严格模式的优势
```typescript
// TypeScript 源码
class StrictExample {
  private secret: string = "confidential";
  
  leakSecret() {
    // 在严格模式下，以下代码会报错
    // eval("var secret = 'leaked';");
    // console.log(secret);
  }
}
```

编译后的 JavaScript：

```javascript
"use strict";
class StrictExample {
  constructor() {
    this.secret = "confidential";
  }
  leakSecret() {
    // 严格模式下，eval 不会引入新的变量到外部作用域
  }
}
```

## strictBindCallApply
此规则确保使用 call()、bind()和 apply()方法时参数类型正确。

### 问题示例
```typescript
function greet(name: string, age: number): string {
  return `Hello, ${name}! You are ${age} years old.`;
}

// 未开启 strictBindCallApply 时
const boundGreet = greet.bind(null, "John");
console.log(boundGreet(30));  // ✅ 正常工作
console.log(boundGreet("30")); // ❌ 运行时可能出错
```

### 严格模式下的错误
```typescript
const boundGreet = greet.bind(null, "John");
console.log(boundGreet("30")); 
// ❌ 错误：类型“string”的参数不能赋给类型“number”的参数
解决方案
typescript
复制
// 正确使用 bind
const boundGreet = greet.bind(null, "John");
console.log(boundGreet(30));  // ✅ 正确

// 或者使用类型安全的包装函数
const createGreet = (name: string) => (age: number) => greet(name, age);
const johnGreet = createGreet("John");
console.log(johnGreet(30));  // ✅ 类型安全
```

## strictNullChecks
此规则使得 null和 undefined值不能赋值给非这两种类型的值。

### 问题示例
```typescript
// 未开启 strictNullChecks
interface Book {
  name: string;
  author: string;
}

function getBook(): Book {
  // 可能返回 null，但类型声明没有体现
  return Math.random() > 0.5 ? { name: "TS Guide", author: "John" } : null;
}

const book = getBook();
console.log(book.name);  // ❌ 潜在运行时错误
```

### 严格模式下的错误
```typescript
function getBook(): Book {
  return Math.random() > 0.5 ? { name: "TS Guide", author: "John" } : null;
  // ❌ 错误：不能将类型“null”分配给类型“Book”
}
```

### 解决方案
```typescript
// 方案1：明确返回类型
function getBook(): Book | null {
  return Math.random() > 0.5 ? { name: "TS Guide", author: "John" } : null;
}

const book = getBook();
if (book) {
  console.log(book.name);  // ✅ 安全访问
}

// 方案2：使用可选链操作符
console.log(book?.name);  // ✅ 安全访问

// 方案3：使用空值合并
console.log(book?.name ?? "Unknown Book");
```

### strictPropertyInitialization
此规则强制在构造函数中初始化所有属性值。

### 问题示例
```typescript
class User {
  name: string;
  age: number;
  email: string;
  
  constructor(name: string) {
    this.name = name;
    // age 和 email 没有被初始化
  }
}
```

### 严格模式下的错误
```typescript
class User {
  name: string;
  age: number;  // ❌ 错误：属性“age”没有初始化表达式，且未在构造函数中明确赋值
  email: string; // ❌ 错误：属性“email”没有初始化表达式，且未在构造函数中明确赋值
  
  constructor(name: string) {
    this.name = name;
  }
}
```

### 解决方案
```typescript
// 方案1：在构造函数中初始化所有属性
class User {
  name: string;
  age: number;
  email: string;
  
  constructor(name: string, age: number, email: string) {
    this.name = name;
    this.age = age;
    this.email = email;
  }
}

// 方案2：使用明确赋值断言
class User {
  name: string;
  age!: number;     // 使用 ! 断言会在使用前赋值
  email!: string;
  
  constructor(name: string) {
    this.name = name;
  }
  
  initialize(age: number, email: string) {
    this.age = age;
    this.email = email;
  }
}

// 方案3：使用可选属性
class User {
  name: string;
  age?: number;
  email?: string;
  
  constructor(name: string) {
    this.name = name;
  }
}
```

## strictFunctionTypes
此规则会对函数参数进行更严格的逆变检查。

### 协变和逆变的概念
```typescript
class Animal {
  name: string;
}

class Dog extends Animal {
  breed: string;
}

// 协变：子类型可以赋值给父类型
let animal: Animal = new Dog();  // ✅ 允许

// 逆变：函数参数的超类型可以赋值给子类型
type AnimalHandler = (animal: Animal) => void;
type DogHandler = (dog: Dog) => void;

let animalHandler: AnimalHandler = (animal: Animal) => { };
let dogHandler: DogHandler = (dog: Dog) => { };

// 未开启 strictFunctionTypes 时
dogHandler = animalHandler;  // ❌ 潜在问题，但默认允许

// 开启 strictFunctionTypes 后
dogHandler = animalHandler;  
// ❌ 错误：不能将类型“AnimalHandler”分配给类型“DogHandler”
```

### 实际应用示例
```typescript
interface EventListener {
  (event: Event): void;
}

interface MouseEventListener {
  (event: MouseEvent): void;
}

// 未开启 strictFunctionTypes
const mouseListener: MouseEventListener = (event: Event) => {
  console.log("Event received");
};

// 开启 strictFunctionTypes 后
const mouseListener: MouseEventListener = (event: Event) => {  
  // ❌ 错误：参数“event”和“event”的类型不兼容
  console.log("Event received");
};

// 正确的方式
const correctMouseListener: MouseEventListener = (event: MouseEvent) => {
  console.log(`Mouse at: ${event.clientX}, ${event.clientY}`);
};
```

## 严格模式的最佳实践
### 渐进式启用严格模式
对于现有项目，建议逐步启用严格模式：

```json
{
  "compilerOptions": {
    "strictNullChecks": true,
    "noImplicitAny": true,
    // 逐步添加其他严格选项
  }
}
```

### 处理第三方库类型
当使用没有类型定义的第三方库时：

```typescript
// 创建类型声明文件
declare module 'untyped-library' {
  export function someFunction(arg: any): any;
}

// 或者使用类型断言
const result = (someUntypedFunction as (arg: string) => number)("hello");
9.3 合理使用类型断言
typescript
复制
// 避免滥用 any
const element = document.getElementById("my-element") as HTMLElement;

// 使用类型守卫替代类型断言
function isHTMLElement(element: Element | null): element is HTMLElement {
  return element !== null && element instanceof HTMLElement;
}

const element = document.getElementById("my-element");
if (isHTMLElement(element)) {
  // element 被正确推断为 HTMLElement
  element.style.color = "red";
}
```

## 严格模式的收益
### 编译时错误检测
```typescript
// 严格模式帮助发现的潜在问题
function calculateTotal(prices: number[]): number {
  return prices.reduce((total, price) => total + price, 0);
}

// 未开启严格模式时可能不会报错
const total = calculateTotal([10, 20, undefined, 30]);  // ❌ NaN

// 开启严格模式后
const prices: (number | undefined)[] = [10, 20, undefined, 30];
const total = calculateTotal(prices as number[]);  
// ❌ 错误：类型“(number | undefined)[]”缺少类型“number[]”的约束
```

### 更好的代码智能提示
```typescript
interface User {
  id: number;
  name: string;
  email?: string;
}

function sendEmail(user: User, message: string): void {
  // 严格模式下，编辑器能提供准确的属性提示
  console.log(`Sending to ${user.name} at ${user.email}`);
  // ✅ 知道 email 是可选的，可能提示需要检查
}
```

## 总结
TypeScript 严格模式通过 7 个子选项提供了全面的类型安全检查：

- ​noImplicitAny​ - 禁止隐式 any 类型

- ​noImplicitThis​ - 禁止隐式 this 上下文

- ​alwaysStrict​ - 始终使用严格模式

- ​strictBindCallApply​ - 严格检查 bind/call/apply

- ​strictNullChecks​ - 严格空值检查

- ​strictPropertyInitialization​ - 严格属性初始化

- ​strictFunctionTypes​ - 严格函数类型检查

​开启严格模式的好处：​​

- 在编译阶段发现潜在错误

- 提供更好的代码智能提示

- 提高代码质量和可维护性

- 减少运行时错误

​建议：​​ 对于新项目，建议从一开始就开启严格模式；对于现有项目，可以逐步启用各个严格选项，确保代码质量稳步提升。

