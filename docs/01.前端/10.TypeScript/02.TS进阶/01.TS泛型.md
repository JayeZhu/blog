---
title: TS泛型
date: 2025-10-10 20:33:35
permalink: /pages/5da5ad/
categories:
  - 前端
tags:
  - TypeScript
  - TS进阶
---
:::tip
泛型（Generics）是Typescript中最重要的特性之一，它允许我们创建可重用的组件，这些组件可以支持多种类型，同时保持类型安全。泛型提供了类型参数化的能力，让我们能够编写更灵活、更通用的代码
:::

## 泛型基础

### 为什么需要泛型
在没有泛型的情况下，我们可能需要编写重复的代码来处理不同类型的数据。
```ts
function identityString(arg: string): string {
  return arg;
}

function identityNumber(arg: number): number {
  return arg;
}

function identityBoolean(arg: boolean): boolean {
  return arg;
}
```
使用泛型后，可以一个函数处理所有类型
```ts
function identity<T>(arg: T): T {
	return arg;
}
```

### 基本语法
泛型使用尖括号 `<T>` 语法，其中 `T` 是类型参数：
```ts
// 泛型函数
function identity<T>(value: T): T {
  return value;
}

// 使用泛型函数
let output1 = identity<string>("hello"); // 显式指定类型
let output2 = identity("world"); // 类型推断：T 被推断为 string
let output3 = identity(42); // T 被推断为 number

// 多个类型参数
function pair<T, U>(first: T, second: U): [T, U] {
  return [first, second];
}

let result = pair("hello", 42); // [string, number]
```

## 泛型约束

### 基本约束
使用 `extends` 关键字对泛型参数进行约束：
```ts
// 约束 T 必须具有 length 属性
interface Lenthwise {
	length: number;
}

function logLength<T extends Lengthwise>(arg: T): T {
	console.log(arg.length);
	return arg;
}

logLength("hello"); // 正确：string 有 length 属性
logLength([1, 2, 3]); // 正确：数组有 length 属性
// logLength(42); // 错误：number 没有 length 属性

// 约束多个类型
function merge<T extends object, U extends object>(obj1: T, obj2: U): T & U {
	return { ...obj1, ...obj2 };
}

const merged = merge({ name: "John" }, { age: 30 });
```

### keyof 约束
```ts
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = { name: "John", age: 30 };
getProperty(person, "name"); // 正确
// getProperty(person, "email"); // 错误："email" 不在 person 的键中

// 使用接口约束
interface User {
  id: number;
  name: string;
  email: string;
}

function getUserProperty<T extends User, K extends keyof T>(user: T, key: K): T[K] {
  return user[key];
}
```

## 泛型接口

### 基本泛型接口
```ts
// 泛型接口
interface GenericIdentity<T> {
  (arg: T): T;
}

// 使用泛型接口
const stringIdentity: GenericIdentity<string> = (arg) => arg;
const numberIdentity: GenericIdentity<number> = (arg) => arg;

// 带默认类型的泛型接口
interface PaginatedResponse<T = any> {
  data: T[];
  total: number;
  page: number;
  limit: number;
}

// 使用默认类型
const userResponse: PaginatedResponse = {
  data: [],
  total: 0,
  page: 1,
  limit: 10
};

// 指定具体类型
const productResponse: PaginatedResponse<Product> = {
  data: [product1, product2],
  total: 2,
  page: 1,
  limit: 10
};
```

### 复杂泛型接口
```ts
// 嵌套泛型接口
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  metadata?: {
    timestamp: Date;
    version: string;
  };
}

// 使用嵌套泛型
const userResponse: ApiResponse<User> = {
  success: true,
  data: { id: 1, name: "John" }
};

// 多个类型参数的接口
interface KeyValuePair<K, V> {
  key: K;
  value: V;
}

const pair: KeyValuePair<string, number> = {
  key: "age",
  value: 30
};
```

## 泛型类
### 基本泛型类
```ts
// 泛型类
class GenericNumber<T> {
  zeroValue: T;
  add: (x: T, y: T) => T;
  
  constructor(zeroValue: T, add: (x: T, y: T) => T) {
    this.zeroValue = zeroValue;
    this.add = add;
  }
}

// 使用泛型类
const numberInstance = new GenericNumber<number>(0, (x, y) => x + y);
const stringInstance = new GenericNumber<string>("", (x, y) => x + y);

// 更实用的泛型类
class Repository<T> {
  private items: T[] = [];
  
  add(item: T): void {
    this.items.push(item);
  }
  
  findById(id: number): T | undefined {
    return this.items.find((item: any) => item.id === id);
  }
  
  getAll(): T[] {
    return this.items;
  }
}

// 使用 Repository 类
interface User {
  id: number;
  name: string;
}

const userRepository = new Repository<User>();
userRepository.add({ id: 1, name: "John" });
userRepository.add({ id: 2, name: "Jane" });
```

### 约束泛型类
```ts
// 带约束的泛型类
interface Identifiable {
  id: number;
}

class IdentifiableRepository<T extends Identifiable> {
  private items: T[] = [];
  
  add(item: T): void {
    this.items.push(item);
  }
  
  getById(id: number): T | undefined {
    return this.items.find(item => item.id === id);
  }
}

// 使用
interface Product extends Identifiable {
  name: string;
  price: number;
}

const productRepository = new IdentifiableRepository<Product>();
productRepository.add({ id: 1, name: "Laptop", price: 999 });
```

## 泛型与条件类型

### 条件类型基础
```ts
// 基本条件类型
type IsString<T> = T extends string ? true : false;
type T1 = IsString<string>; // true
type T2 = IsString<number>; // false

// 类型提取
type ExtractType<T> = T extends (infer U)[] ? U : never;
type ItemType = ExtractType<string[]>; // string

// 函数返回类型提取
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;
type FnReturn = ReturnType<() => string>; // string
```

### 分布式条件类型
```ts
// 分布式条件类型
type ToArray<T> = T extends any ? T[] : never;
type StringOrNumberArray = ToArray<string | number>; // string[] | number[]

// 非分布式版本
type ToArrayNonDist<T> = [T] extends [any] ? T[] : never;
type StringOrNumberArrayNonDist = ToArrayNonDist<string | number>; // (string | number)[]

// 实用的条件类型
type NonNullable<T> = T extends null | undefined ? never : T;
type ValidValue = NonNullable<string | null | undefined>; // string

type Exclude<T, U> = T extends U ? never : T;
type WithoutStrings = Exclude<string | number | boolean, string>; // number | boolean
```

## 映射类型与泛型
### 基本映射类型
```ts
// 使用映射类型创建新类型
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

type Partial<T> = {
  [P in keyof T]?: T[P];
};

type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;

// 使用示例
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

type UserPreview = Pick<User, "id" | "name">;
type UserWithoutEmail = Omit<User, "email">;
```

### 高级映射类型
```ts
// 键重映射（TypeScript 4.1+）
type Getters<T> = {
  [P in keyof T as `get${Capitalize<string & P>}`]: () => T[P];
};

interface Person {
  name: string;
  age: number;
}

type PersonGetters = Getters<Person>;
// {
//   getName: () => string;
//   getAge: () => number;
// }

// 条件映射
type OnlyFunctions<T> = {
  [P in keyof T as T[P] extends Function ? P : never]: T[P];
};

interface Example {
  name: string;
  greet(): void;
  count: number;
}

type ExampleMethods = OnlyFunctions<Example>; // { greet: () => void }
```

## 泛型使用工具

### 内置工具类型
Typescript 提供了许多内置的泛型工具类型：
```ts
// Partial<T> - 所有属性变为可选
interface User {
  name: string;
  age: number;
}
type PartialUser = Partial<User>; // { name?: string; age?: number }

// Required<T> - 所有属性变为必选
type RequiredUser = Required<PartialUser>; // { name: string; age: number }

// Readonly<T> - 所有属性变为只读
type ReadonlyUser = Readonly<User>;

// Record<K, T> - 创建键值对对象
type UserMap = Record<string, User>;

// Pick<T, K> - 选择部分属性
type UserName = Pick<User, "name">; // { name: string }

// Omit<T, K> - 忽略部分属性
type UserWithoutAge = Omit<User, "age">; // { name: string }

// Exclude<T, U> - 从联合类型中排除类型
type NonString = Exclude<string | number | boolean, string>; // number | boolean

// Extract<T, U> - 从联合类型中提取类型
type OnlyString = Extract<string | number | boolean, string>; // string
```

### 自定义工具类型
```ts
// 深度只读
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

// 深度可选
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// 异步函数返回类型
type AsyncReturnType<T> = T extends (...args: any[]) => Promise<infer R> ? R : never;

// 获取构造函数参数类型
type ConstructorParameters<T extends new (...args: any[]) => any> = 
  T extends new (...args: infer P) => any ? P : never;

// 获取实例类型
type InstanceType<T extends new (...args: any[]) => any> = 
  T extends new (...args: any[]) => infer R ? R : never;
```

## 泛型在实际项目中的应用
### API 服务层
```ts
// 泛型API服务
interface ApiService<T> {
  getAll(): Promise<T[]>;
  getById(id: number): Promise<T>;
  create(item: Omit<T, "id">): Promise<T>;
  update(id: number, item: Partial<T>): Promise<T>;
  delete(id: number): Promise<void>;
}

class HttpClient {
  async get<T>(url: string): Promise<T> {
    const response = await fetch(url);
    return response.json();
  }
  
  async post<T>(url: string, data: any): Promise<T> {
    const response = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data)
    });
    return response.json();
  }
}

// 具体实现
class UserApiService implements ApiService<User> {
  constructor(private http: HttpClient) {}
  
  async getAll(): Promise<User[]> {
    return this.http.get<User[]>("/api/users");
  }
  
  async getById(id: number): Promise<User> {
    return this.http.get<User>(`/api/users/${id}`);
  }
  
  async create(user: Omit<User, "id">): Promise<User> {
    return this.http.post<User>("/api/users", user);
  }
  
  async update(id: number, updates: Partial<User>): Promise<User> {
    return this.http.post<User>(`/api/users/${id}`, updates);
  }
  
  async delete(id: number): Promise<void> {
    await fetch(`/api/users/${id}`, { method: "DELETE" });
  }
}
```

### 状态管理
```ts
// 泛型状态管理
interface State<T> {
  data: T;
  loading: boolean;
  error: string | null;
}

type Action<T> =
  | { type: "LOADING" }
  | { type: "SUCCESS"; payload: T }
  | { type: "ERROR"; payload: string };

function createReducer<T>() {
  return function reducer(state: State<T>, action: Action<T>): State<T> {
    switch (action.type) {
      case "LOADING":
        return { ...state, loading: true, error: null };
      case "SUCCESS":
        return { data: action.payload, loading: false, error: null };
      case "ERROR":
        return { ...state, loading: false, error: action.payload };
      default:
        return state;
    }
  };
}

// 使用
const userReducer = createReducer<User[]>();
const initialUserState: State<User[]> = {
  data: [],
  loading: false,
  error: null
};
```

### 表单处理
```ts
// 泛型表单处理
interface FieldState<T> {
  value: T;
  error?: string;
  touched: boolean;
}

type FormState<T extends Record<string, any>> = {
  [K in keyof T]: FieldState<T[K]>;
} & {
  valid: boolean;
  submitted: boolean;
};

function createForm<T extends Record<string, any>>(initialValues: T): FormState<T> {
  const formState = {} as FormState<T>;
  
  for (const key in initialValues) {
    formState[key] = {
      value: initialValues[key],
      touched: false,
      error: undefined
    };
  }
  
  return {
    ...formState,
    valid: false,
    submitted: false
  };
}

// 使用
interface LoginForm {
  email: string;
  password: string;
  rememberMe: boolean;
}

const loginForm = createForm<LoginForm>({
  email: "",
  password: "",
  rememberMe: false
});
```

## 最佳实践和常见陷阱
### 最佳实践
```ts
// 1. 使用有意义的类型参数名
function processData<TData>(data: TData): TData {
  return data;
}

function handleResponse<TResponse, TError>(response: TResponse, error: TError) {
  // ...
}

// 2. 合理使用约束，避免过度约束
// 不好的做法：过度约束
function process<T extends SomeComplexInterface>(item: T): T {
  // ...
}

// 好的做法：最小约束
function processBetter<T extends { id: number }>(item: T): T {
  // ...
}

// 3. 使用默认类型参数
interface Config<T = any> {
  data: T;
  timeout: number;
}

// 4. 优先使用类型推断
const numbers = [1, 2, 3]; // number[]
const mixed = [1, "hello"]; // (number | string)[]

// 5. 使用泛型组件创建可重用代码
function createLogger<T>() {
  return {
    log: (item: T) => console.log(item),
    warn: (item: T) => console.warn(item),
    error: (item: T) => console.error(item)
  };
}

const numberLogger = createLogger<number>();
numberLogger.log(42);
```

### 常见陷阱
```ts
// 1. 过度使用泛型
// 不需要泛型的情况
function formatName<T>(name: T): string {
  return String(name); // 不需要泛型，直接使用 string
}

// 2. 忽略类型安全
function unsafeProcess<T>(data: T): T {
  // const result = data.someMethod(); // 错误：T 可能没有 someMethod
  return data;
}

// 3. 复杂的嵌套泛型
function veryComplex<T extends Map<string, Array<Set<number>>>>(param: T): T {
  // 过于复杂，难以理解和维护
  return param;
}

// 4. 忽略性能考虑
// 复杂的条件类型和映射类型可能影响编译性能

// 5. 忘记处理边界情况
function getFirst<T>(items: T[]): T {
  return items[0]; // 如果数组为空，返回 undefined
}

// 更好的做法
function getFirstSafe<T>(items: T[]): T | undefined {
  return items[0];
}
```

## 总结
TypeScript 泛型提供了强大的类型参数化能力：
- ​基础泛型​：使用 <T>语法创建可重用组件
- ​泛型约束​：使用 extends限制类型参数的范围
- ​泛型接口和类​：创建可重用的类型结构和类定义
- ​条件类型​：根据条件选择不同的类型
- ​映射类型​：基于现有类型创建新类型
- ​实用工具​：内置和自定义的泛型工具类型
​关键优势：​​
- 提高代码复用性
- 保持类型安全
- 增强代码表达能力
- 减少重复代码
​适用场景：​​
- 数据处理函数
- 集合类和数据容器
- API 客户端和服务层
- 状态管理和表单处理
- 工具函数和工具类型
掌握泛型是成为 TypeScript 高级开发者的关键一步，它能让你的代码更加灵活、健壮和可维护。