---
title: TS高级类型
date: 2025-10-11 17:32:25
permalink: /pages/117de3/
categories:
  - 前端
tags:
  - TypeScript
  - TS进阶
---
:::tip
TypeScript 的高级类型系统提供了强大的类型编程能力，允许开发者创建灵活、精确且可重用的类型定义。掌握这些高级类型技巧能够显著提升代码质量和开发效率。
:::

## 条件类型基础
### 基本条件类型
条件类型根据类型关系选择不同的类型分支，语法类似于三元表达式。

```typescript
// 基本条件类型
type IsString<T> = T extends string ? true : false;

type T1 = IsString<string>;  // true
type T2 = IsString<number>;  // false

// 嵌套条件类型
type TypeName<T> = 
  T extends string ? "string" :
  T extends number ? "number" :
  T extends boolean ? "boolean" :
  T extends undefined ? "undefined" :
  T extends Function ? "function" :
  "object";

type T3 = TypeName<string>;     // "string"
type T4 = TypeName<number[]>;   // "object"
type T5 = TypeName<() => void>; // "function"
```

### 条件类型约束
```typescript
// 类型约束检查
type HasProperty<T, K extends string> = 
  T extends { [P in K]: any } ? true : false;

type T6 = HasProperty<{ name: string }, "name">;   // true
type T7 = HasProperty<{ name: string }, "age">;    // false

// 条件类型与泛型约束
type ExtractPropertyType<T, K extends string> = 
  T extends { [P in K]: infer U } ? U : never;

type T8 = ExtractPropertyType<{ age: number }, "age">; // number
type T9 = ExtractPropertyType<{ name: string }, "age">; // never
```

## 分布式条件类型
### 分布式特性
当条件类型作用于联合类型时，TypeScript 会自动进行分布式计算。

```typescript
// 分布式条件类型
type ToArray<T> = T extends any ? T[] : never;

type T10 = ToArray<string | number>; // string[] | number[]

// 非分布式版本
type ToArrayNonDist<T> = [T] extends [any] ? T[] : never;
type T11 = ToArrayNonDist<string | number>; // (string | number)[]

// 过滤特定类型
type FilterString<T> = T extends string ? T : never;
type T12 = FilterString<string | number | boolean>; // string

// 排除特定类型
type ExcludeType<T, U> = T extends U ? never : T;
type T13 = ExcludeType<string | number | boolean, number>; // string | boolean
```

### 实际应用
```typescript
// 从函数类型中提取参数类型
type FunctionParams<T> = 
  T extends (...args: infer P) => any ? P : never;

type T14 = FunctionParams<(a: string, b: number) => void>; // [string, number]

// 提取Promise的解析类型
type UnwrapPromise<T> = 
  T extends Promise<infer U> ? U : T;

type T15 = UnwrapPromise<Promise<string>>; // string
type T16 = UnwrapPromise<string>;          // string

// 提取数组元素类型
type ArrayElement<T> = 
  T extends (infer U)[] ? U : never;

type T17 = ArrayElement<string[]>;      // string
type T18 = ArrayElement<(string | number)[]>; // string | number
```

## 类型推断与 infer 关键字
### infer 基础用法
infer关键字在条件类型中用于声明类型变量，实现类型提取。

```typescript
// 提取函数返回类型
type ReturnType<T> = 
  T extends (...args: any[]) => infer R ? R : any;

function getUser() { return { name: "John", age: 30 }; }
type User = ReturnType<typeof getUser>; // { name: string; age: number }

// 提取构造函数实例类型
type InstanceType<T> = 
  T extends new (...args: any[]) => infer R ? R : any;

class UserClass { name: string = ""; }
type UserInstance = InstanceType<typeof UserClass>; // UserClass

// 提取Promise解析值
type Awaited<T> = 
  T extends Promise<infer U> ? U : T;

type T19 = Awaited<Promise<string>>; // string
```

### 复杂类型推断
```typescript
// 提取元组第一个元素
type First<T extends any[]> = 
  T extends [infer U, ...any[]] ? U : never;

type T20 = First<[string, number, boolean]>; // string

// 提取元组最后一个元素
type Last<T extends any[]> = 
  T extends [...any[], infer U] ? U : never;

type T21 = Last<[string, number, boolean]>; // boolean

// 提取函数第一个参数类型
type FirstParam<T> = 
  T extends (arg: infer U, ...args: any[]) => any ? U : never;

type T22 = FirstParam<(name: string, age: number) => void>; // string
```
## 模板字面量类型
### 基础模板字面量

TypeScript 4.1 引入了模板字面量类型，支持基于字符串的模式匹配。

```typescript
// 基本模板字面量
type World = "world";
type Greeting = `Hello ${World}`; // "Hello world"

// 联合类型扩展
type Color = "red" | "blue" | "green";
type Size = "small" | "medium" | "large";

type ButtonClass = `btn-${Color}-${Size}`;
// "btn-red-small" | "btn-red-medium" | "btn-red-large" |
// "btn-blue-small" | "btn-blue-medium" | "btn-blue-large" |
// "btn-green-small" | "btn-green-medium" | "btn-green-large"

// 实用工具类型
type Uppercase<S extends string> = S extends string ? Uppercase<S> : never;
type Lowercase<S extends string> = S extends string ? Lowercase<S> : never;
type Capitalize<S extends string> = S extends string ? Capitalize<S> : never;
type Uncapitalize<S extends string> = S extends string ? Uncapitalize<S> : never;
```

### 高级模式匹配
```typescript
// 路径参数匹配
type ExtractParams<Path extends string> =
  Path extends `${string}:${infer Param}/${infer Rest}`
    ? Param | ExtractParams<Rest>
    : Path extends `${string}:${infer Param}`
      ? Param
      : never;

type RouteParams = ExtractParams<"/user/:id/posts/:postId">;
// "id" | "postId"

// CSS 类名转换
type BemClass<Block extends string, Element extends string, Modifier extends string> =
  `${Block}__${Element}--${Modifier}`;

type ButtonClass = BemClass<"button", "icon", "disabled">; // "button__icon--disabled"

// 事件处理函数命名
type EventType = "click" | "change" | "submit";
type HandlerName = `on${Capitalize<EventType>}`;
// "onClick" | "onChange" | "onSubmit"
```

## 映射类型进阶
### 键重映射
TypeScript 4.1 引入了键重映射，允许在映射过程中修改属性名。

```typescript
// 添加前缀
type AddPrefix<T, Prefix extends string> = {
  [K in keyof T as `${Prefix}${Capitalize<string & K>}`]: T[K];
};

interface User {
  name: string;
  age: number;
}

type PrefixedUser = AddPrefix<User, "get">;
// {
//   getName: string;
//   getAge: number;
// }

// 过滤属性
type FilterByType<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K];
};

interface Example {
  name: string;
  age: number;
  isActive: boolean;
  update(): void;
}

type StringProps = FilterByType<Example, string>; // { name: string }
type FunctionProps = FilterByType<Example, Function>; // { update: () => void }
```

### 条件键映射
```typescript
// 根据条件修改键名
type ConditionalKeys<T, Condition> = {
  [K in keyof T as T[K] extends Condition ? `valid${Capitalize<string & K>}` : `invalid${Capitalize<string & K>}`]: T[K];
};

interface Data {
  name: string;
  age: number;
  email: string | null;
}

type ValidatedData = ConditionalKeys<Data, string>;
// {
//   validName: string;
//   invalidAge: number;
//   invalidEmail: string | null;
// }

// 基于值的键映射
type ValueBasedKeys<T> = {
  [K in keyof T as T[K] extends string ? `${string & K}Str` : 
                   T[K] extends number ? `${string & K}Num` : K]: T[K];
};

type ConvertedData = ValueBasedKeys<Data>;
// {
//   nameStr: string;
//   ageNum: number;
//   email: string | null;
// }
```

## 递归类型
### 类型递归
TypeScript 支持类型递归，用于处理嵌套结构。

```typescript
// 深度只读
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object 
    ? T[P] extends Function 
      ? T[P] 
      : DeepReadonly<T[P]>
    : T[P];
};

// 深度可选
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object 
    ? T[P] extends Function 
      ? T[P] 
      : DeepPartial<T[P]>
    : T[P];
};

// 深度Required
type DeepRequired<T> = {
  [P in keyof T]-?: T[P] extends object 
    ? T[P] extends Function 
      ? T[P] 
      : DeepRequired<T[P]>
    : T[P];
};

interface NestedObject {
  level1: {
    level2: {
      value: string;
      nested: {
        final: number;
      };
    };
  };
}

type ReadonlyNested = DeepReadonly<NestedObject>;
type PartialNested = DeepPartial<NestedObject>;
```

### 递归实用类型
```typescript
// 提取所有叶子节点类型
type LeafTypes<T> = 
  T extends object 
    ? { [K in keyof T]: LeafTypes<T[K]> }[keyof T]
    : T;

interface ComplexObject {
  user: {
    name: string;
    profile: {
      age: number;
      settings: {
        theme: "light" | "dark";
      };
    };
  };
  metadata: {
    version: string;
  };
}

type Leaves = LeafTypes<ComplexObject>; // string | number | "light" | "dark"

// 递归键路径
type Paths<T> = 
  T extends object
    ? { [K in keyof T]: `${Exclude<K, symbol>}${"" | `.${Paths<T[K]>}`}` }[keyof T]
    : never;

type ObjectPaths = Paths<ComplexObject>;
// "user" | "user.name" | "user.profile" | "user.profile.age" | 
// "user.profile.settings" | "user.profile.settings.theme" | 
// "metadata" | "metadata.version"
```

## 高级类型工具
### 类型谓词与断言
```typescript
// 自定义类型守卫
function isStringArray(value: any): value is string[] {
  return Array.isArray(value) && value.every(item => typeof item === "string");
}

function processValue(value: unknown) {
  if (isStringArray(value)) {
    // value 被推断为 string[]
    value.map(str => str.toUpperCase());
  }
}

// 断言函数
function assertIsNumber(value: unknown): asserts value is number {
  if (typeof value !== "number") {
    throw new Error("Value must be a number");
  }
}

function calculate(value: unknown) {
  assertIsNumber(value);
  // value 被推断为 number
  return value * 2;
}
```

### 条件类型分发
```typescript
// 条件类型的分发行为
type Distributed<T> = T extends any ? { value: T } : never;
type NonDistributed<T> = [T] extends [any] ? { value: T } : never;

type DistributedResult = Distributed<string | number>;
// { value: string } | { value: number }

type NonDistributedResult = NonDistributed<string | number>;
// { value: string | number }

// 利用分发特性创建高级工具
type ToUnion<T> = T extends any ? T : never;
type UnionFromArray<T extends any[]> = T[number];
type UnionFromTuple<T extends readonly any[]> = T[number];

type T23 = ToUnion<[string, number, boolean]>; // string | number | boolean
type T24 = UnionFromArray<[string, number, boolean]>; // string | number | boolean
```

## 实际应用场景
### API 响应处理
```typescript
// 灵活的API响应类型
type ApiResponse<T> = 
  | { status: "success"; data: T; timestamp: Date }
  | { status: "error"; code: string; message: string; details?: unknown }
  | { status: "loading"; progress: number };

// 条件响应处理
type ResponseHandler<T> = {
  [K in ApiResponse<T>["status"]]: 
    (response: Extract<ApiResponse<T>, { status: K }>) => void;
};

function createResponseHandler<T>(handlers: ResponseHandler<T>) {
  return function handleResponse(response: ApiResponse<T>) {
    const handler = handlers[response.status];
    handler(response as any);
  };
}

// 使用示例
const userHandler = createResponseHandler<User>({
  success: (response) => console.log("Data:", response.data),
  error: (response) => console.error("Error:", response.code, response.message),
  loading: (response) => console.log("Progress:", response.progress)
});
```

### 表单验证系统
```typescript
// 动态表单验证类型
type ValidationRule<T> = {
  required?: boolean;
  minLength?: number;
  maxLength?: number;
  pattern?: RegExp;
  validator?: (value: T) => boolean | string;
};

type ValidationRules<T> = {
  [K in keyof T]?: ValidationRule<T[K]>;
};

type ValidationResult<T> = {
  [K in keyof T]?: string | null;
} & {
  valid: boolean;
};

function createValidator<T>(rules: ValidationRules<T>) {
  return function validate(data: T): ValidationResult<T> {
    const result: ValidationResult<T> = { valid: true };
    
    for (const key in rules) {
      if (rules.hasOwnProperty(key)) {
        const rule = rules[key]!;
        const value = data[key];
        let error: string | null = null;
        
        if (rule.required && (value === undefined || value === null || value === "")) {
          error = "This field is required";
        } else if (typeof value === "string") {
          if (rule.minLength && value.length < rule.minLength) {
            error = `Minimum length is ${rule.minLength}`;
          } else if (rule.maxLength && value.length > rule.maxLength) {
            error = `Maximum length is ${rule.maxLength}`;
          } else if (rule.pattern && !rule.pattern.test(value)) {
            error = "Invalid format";
          }
        }
        
        if (rule.validator) {
          const validationResult = rule.validator(value);
          if (validationResult !== true) {
            error = typeof validationResult === "string" ? validationResult : "Invalid value";
          }
        }
        
        result[key] = error;
        if (error) {
          result.valid = false;
        }
      }
    }
    
    return result;
  };
}

// 使用示例
interface LoginForm {
  username: string;
  password: string;
  rememberMe: boolean;
}

const validateLogin = createValidator<LoginForm>({
  username: { required: true, minLength: 3 },
  password: { required: true, minLength: 8 },
  rememberMe: {} // 无验证规则
});

const formData: LoginForm = { username: "john", password: "secret", rememberMe: true };
const validation = validateLogin(formData);
```

## 最佳实践与性能考虑
### 类型性能优化
```typescript
// 避免过度复杂的递归类型
// 不好的做法：深度递归可能影响性能
type OverlyComplex<T> = {
  [K in keyof T]: T[K] extends object 
    ? OverlyComplex<T[K]> 
    : T[K];
};

// 好的做法：限制递归深度或使用内置类型
type SafePartial<T> = Partial<T>; // 使用内置工具类型

// 使用条件类型提前返回
type EfficientType<T> = 
  T extends primitive ? T :
  T extends Array<infer U> ? EfficientType<U>[] :
  T extends object ? { [K in keyof T]: EfficientType<T[K]> } :
  T;

// 缓存复杂类型计算
type ComplexCalculation<T> = /* 复杂类型计算 */;
interface CachedResult<T> = ComplexCalculation<T>;

// 重用而不是重新计算
type ReuseType = CachedResult<SomeComplexType>;
```

### 可维护性建议
```typescript
// 使用有意义的类型名称
type UserAuthenticationToken = string;
type Timestamp = number;
type EmailAddress = string;

// 避免过度抽象
// 不好的做法：过度抽象难以理解
type AbstractType<T, U, V> = 
  T extends U ? (V extends T ? never : T) : U extends V ? T : never;

// 好的做法：保持类型简单明了
type ConcreteType = string | number;

// 提供类型文档
/**
 * 表示API响应结果
 * @template T 数据类型
 */
type ApiResponse<T> = {
  data: T;
  status: "success" | "error";
  message?: string;
};

// 使用类型别名提高可读性
type ID = string | number;
type URLString = string;
type DateTimeString = string;
```

## 总结
TypeScript 高级类型提供了强大的类型编程能力：

- ​条件类型​：基于类型关系选择不同的类型分支

- ​分布式特性​：自动处理联合类型的条件分发

- ​类型推断​：使用 infer关键字提取复杂类型信息

- ​模板字面量​：基于字符串模式的类型操作

- ​键重映射​：在映射过程中修改属性名称

- ​递归类型​：处理嵌套数据结构的类型定义

​关键优势：​​

- 提供更精确的类型安全

- 减少重复代码，提高可维护性

- 支持复杂的类型操作和转换

- 增强代码的表达能力和灵活性

​适用场景：​​

- API 响应处理和数据转换

- 表单验证和状态管理

- 复杂数据结构的类型定义

- 框架和库的类型系统设计

掌握这些高级类型技巧将帮助你构建更加健壮和灵活的 TypeScript 应用程序，提升开发效率和代码质量。