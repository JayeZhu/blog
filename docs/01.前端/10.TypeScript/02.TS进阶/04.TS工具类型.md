---
title: TS工具类型
date: 2025-10-11 16:45:51
permalink: /pages/0f6197/
categories:
  - 前端
tags:
  - TypeScript
  - TS进阶
---
:::tip
TypeScript 提供了强大的内置工具类型，这些工具类型基于 TypeScript 的类型系统，能够帮助我们进行各种类型转换和操作。掌握这些工具类型可以极大提高类型编程的效率和代码质量。
:::
## 基础工具类型
### Partial<T> - 所有属性变为可选
将类型 T 的所有属性变为可选。

```typescript
interface User {
  id: number;
  name: string;
  email: string;
}

type PartialUser = Partial<User>;
// 等价于：
// {
//   id?: number;
//   name?: string;
//   email?: string;
// }

// 实际应用
function updateUser(user: User, updates: Partial<User>): User {
  return { ...user, ...updates };
}

const user: User = { id: 1, name: "John", email: "john@example.com" };
updateUser(user, { name: "Jane" }); // 只更新名称
```

### Required<T> - 所有属性变为必选
将类型 T 的所有属性变为必选。

```typescript
interface User {
  id?: number;
  name?: string;
  email?: string;
}

type RequiredUser = Required<User>;
// 等价于：
// {
//   id: number;
//   name: string;
//   email: string;
// }

// 实际应用
function createUser(user: Required<User>): void {
  // 确保所有属性都有值
  console.log(user);
}

createUser({ id: 1, name: "John", email: "john@example.com" });
```

### Readonly<T> - 所有属性变为只读
将类型 T 的所有属性变为只读。

```typescript
interface User {
  id: number;
  name: string;
}

type ReadonlyUser = Readonly<User>;
// 等价于：
// {
//   readonly id: number;
//   readonly name: string;
// }

// 实际应用
const config: Readonly<User> = { id: 1, name: "John" };
// config.name = "Jane"; // 错误：无法分配到只读属性
```

### Record<K, T> - 创建键值对对象
创建一个对象类型，其键的类型为 K，值的类型为 T。

```typescript
type UserRole = "admin" | "user" | "guest";
type UserPermissions = Record<UserRole, string[]>;

const permissions: UserPermissions = {
  admin: ["read", "write", "delete"],
  user: ["read", "write"],
  guest: ["read"]
};

// 实际应用：动态创建对象类型
type ApiEndpoints = Record<string, { method: string; url: string }>;

const endpoints: ApiEndpoints = {
  getUser: { method: "GET", url: "/users/:id" },
  createUser: { method: "POST", url: "/users" }
};
```

## 属性选择工具类型
### Pick<T, K> - 选择部分属性
从类型 T 中选择一组属性 K。

```typescript
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
  createdAt: Date;
}

type UserPreview = Pick<User, "id" | "name" | "email">;
// 等价于：
// {
//   id: number;
//   name: string;
//   email: string;
// }

// 实际应用：API 响应预览
function getUserPreview(user: User): Pick<User, "id" | "name" | "email"> {
  return {
    id: user.id,
    name: user.name,
    email: user.email
  };
}
```

### Omit<T, K> - 忽略部分属性
从类型 T 中忽略一组属性 K。

```typescript
interface User {
  id: number;
  name: string;
  email: string;
  password: string;
}

type PublicUser = Omit<User, "password">;
// 等价于：
// {
//   id: number;
//   name: string;
//   email: string;
// }

// 实际应用：安全的数据传输
function sanitizeUser(user: User): Omit<User, "password"> {
  const { password, ...sanitized } = user;
  return sanitized;
}
```

### Extract<T, U> - 提取共有类型
从 T 中提取那些可以赋值给 U 的类型。

```typescript
type T0 = Extract<"a" | "b" | "c", "a" | "f">; // "a"
type T1 = Extract<string | number | (() => void), Function>; // () => void

// 实际应用：过滤事件类型
type EventType = "click" | "change" | "submit" | "keydown";
type FormEvent = Extract<EventType, "click" | "change" | "submit">; // "click" | "change" | "submit"

// 过滤对象类型
interface Admin { role: "admin"; permissions: string[]; }
interface User { role: "user"; isActive: boolean; }
type AdminOnly = Extract<Admin | User, { role: "admin" }>; // Admin
```

### Exclude<T, U> - 排除特定类型
从 T 中排除那些可以赋值给 U 的类型。

```typescript
type T0 = Exclude<"a" | "b" | "c", "a">; // "b" | "c"
type T1 = Exclude<string | number | (() => void), Function>; // string | number

// 实际应用：排除特定值
type Status = "pending" | "success" | "error" | "loading";
type FinalStatus = Exclude<Status, "loading">; // "pending" | "success" | "error"

// 排除 null 和 undefined
type MaybeString = string | null | undefined;
type DefiniteString = Exclude<MaybeString, null | undefined>; // string
```

## 函数相关工具类型
### ReturnType<T> - 获取函数返回类型
获取函数类型 T 的返回类型。

```typescript
function getUser() {
  return { id: 1, name: "John" };
}

type User = ReturnType<typeof getUser>;
// { id: number; name: string }

// 实际应用：API 响应类型推断
async function fetchData() {
  const response = await fetch("/api/data");
  return response.json() as Promise<{ data: any[] }>;
}

type ResponseData = ReturnType<typeof fetchData>; // Promise<{ data: any[] }>

// 结合 Awaited 获取实际数据类型
type ActualData = Awaited<ReturnType<typeof fetchData>>; // { data: any[] }
```

### Parameters<T> - 获取函数参数类型
获取函数类型 T 的参数类型。

```typescript
function createUser(name: string, age: number, email?: string) {
  return { name, age, email };
}

type CreateUserParams = Parameters<typeof createUser>;
// [name: string, age: number, email?: string]

// 实际应用：高阶函数包装
function withLogging<T extends (...args: any[]) => any>(fn: T) {
  return function(...args: Parameters<T>): ReturnType<T> {
    console.log(`Calling function with args:`, args);
    return fn(...args);
  };
}

const createUserWithLog = withLogging(createUser);
```

### ConstructorParameters<T> - 获取构造函数参数类型
获取构造函数类型 T 的参数类型。

```typescript
class User {
  constructor(public name: string, public age: number) {}
}

type UserConstructorParams = ConstructorParameters<typeof User>;
// [name: string, age: number]

// 实际应用：依赖注入容器
class Container {
  private instances = new Map();
  
  register<T>(ctor: new (...args: any[]) => T, ...args: ConstructorParameters<typeof ctor>) {
    this.instances.set(ctor, new ctor(...args));
  }
  
  resolve<T>(ctor: new (...args: any[]) => T): T {
    return this.instances.get(ctor);
  }
}

const container = new Container();
container.register(User, "John", 30);
```

### InstanceType<T> - 获取实例类型
获取构造函数类型 T 的实例类型。

```typescript
class User {
  constructor(public name: string, public age: number) {}
}

type UserInstance = InstanceType<typeof User>;
// User

// 实际应用：工厂函数
function createInstance<T extends new (...args: any[]) => any>(
  ctor: T,
  ...args: ConstructorParameters<T>
): InstanceType<T> {
  return new ctor(...args);
}

const user = createInstance(User, "John", 30); // User 实例
```

## 条件类型工具
### NonNullable<T> - 排除 null 和 undefined
从 T 中排除 null 和 undefined。

```typescript
type T0 = NonNullable<string | number | null>; // string | number
type T1 = NonNullable<string[] | null | undefined>; // string[]

// 实际应用：安全的属性访问
function getSafeValue<T>(value: T): NonNullable<T> {
  if (value == null) {
    throw new Error("Value cannot be null or undefined");
  }
  return value as NonNullable<T>;
}

// 数组过滤
type MaybeArray = (string | null | undefined)[];
type DefiniteArray = NonNullable<MaybeArray[number]>[]; // string[]
```

### ThisParameterType<T> - 获取 this 参数类型
提取函数类型的 this 参数类型。

```typescript
function sayHello(this: { name: string }) {
  return `Hello, ${this.name}`;
}

type ThisType = ThisParameterType<typeof sayHello>; // { name: string }

// 实际应用：绑定上下文
function bindContext<T extends (this: any, ...args: any[]) => any>(
  fn: T,
  context: ThisParameterType<T>
): OmitThisParameter<T> {
  return fn.bind(context) as OmitThisParameter<T>;
}

const context = { name: "John" };
const boundSayHello = bindContext(sayHello, context);
```

### OmitThisParameter<T> - 移除 this 参数类型
从函数类型中移除 this 参数。

```typescript
function sayHello(this: { name: string }, greeting: string) {
  return `${greeting}, ${this.name}`;
}

type WithoutThis = OmitThisParameter<typeof sayHello>;
// (greeting: string) => string

// 实际应用：创建独立函数
function createStandalone<T extends (this: any, ...args: any[]) => any>(
  fn: T
): OmitThisParameter<T> {
  return function(...args: Parameters<T>) {
    return fn.call({}, ...args);
  } as OmitThisParameter<T>;
}

const standaloneSayHello = createStandalone(sayHello);
standaloneSayHello("Hi"); // 不需要 this 上下文
```

## 字符串操作工具类型
### Uppercase<T> - 转换为大写
将字符串字面量类型转换为大写。

```typescript
type T0 = Uppercase<"hello">; // "HELLO"
type T1 = Uppercase<"hello" | "world">; // "HELLO" | "WORLD"

// 实际应用：常量生成
type EventName = "click" | "change" | "submit";
type EventConstant = `ON_${Uppercase<EventName>}`;
// "ON_CLICK" | "ON_CHANGE" | "ON_SUBMIT"
```

### Lowercase<T> - 转换为小写
将字符串字面量类型转换为小写。

```typescript
type T0 = Lowercase<"HELLO">; // "hello"
type T1 = Lowercase<"HELLO" | "WORLD">; // "hello" | "world"

// 实际应用：配置键名规范化
type ConfigKey = "API_URL" | "MAX_RETRIES" | "TIMEOUT";
type NormalizedKey = Lowercase<ConfigKey>;
// "api_url" | "max_retries" | "timeout"
```

### Capitalize<T> - 首字母大写
将字符串字面量类型的首字母转换为大写。

```typescript
type T0 = Capitalize<"hello">; // "Hello"
type T1 = Capitalize<"hello" | "world">; // "Hello" | "World"

// 实际应用：属性名转换
type FieldName = "name" | "email" | "age";
type GetterName = `get${Capitalize<FieldName>}`;
// "getName" | "getEmail" | "getAge"
```

### Uncapitalize<T> - 首字母小写
将字符串字面量类型的首字母转换为小写。

```typescript
type T0 = Uncapitalize<"Hello">; // "hello"
type T1 = Uncapitalize<"Hello" | "World">; // "hello" | "world"

// 实际应用：驼峰命名转换
type PascalCase = "UserName" | "EmailAddress";
type CamelCase = Uncapitalize<PascalCase>;
// "userName" | "emailAddress"
```

## 高级工具类型组合
### 深度只读
```typescript
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object 
    ? T[P] extends Function 
      ? T[P] 
      : DeepReadonly<T[P]>
    : T[P];
};

interface User {
  profile: {
    name: string;
    settings: {
      theme: string;
      notifications: boolean;
    };
  };
}

type ReadonlyUser = DeepReadonly<User>;
// 所有嵌套属性都是只读的

const user: ReadonlyUser = {
  profile: {
    name: "John",
    settings: {
      theme: "dark",
      notifications: true
    }
  }
};

// user.profile.settings.theme = "light"; // 错误：所有层级都是只读
```

## 深度可选
```typescript
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object 
    ? T[P] extends Function 
      ? T[P] 
      : DeepPartial<T[P]>
    : T[P];
};

interface Config {
  database: {
    host: string;
    port: number;
    credentials: {
      username: string;
      password: string;
    };
  };
  api: {
    timeout: number;
    retries: number;
  };
}

type PartialConfig = DeepPartial<Config>;
// 所有属性都是可选的，包括嵌套属性

const config: PartialConfig = {
  database: {
    host: "localhost",
    // port 和 credentials 是可选的
  }
  // api 也是可选的
};
```

### 按条件过滤属性
```typescript
type FilterProperties<T, U> = {
  [P in keyof T as T[P] extends U ? P : never]: T[P];
};

interface Example {
  name: string;
  age: number;
  isActive: boolean;
  createdAt: Date;
  update(): void;
}

type StringProperties = FilterProperties<Example, string>; // { name: string }
type NumberProperties = FilterProperties<Example, number>; // { age: number }
type FunctionProperties = FilterProperties<Example, Function>; // { update: () => void }
```

## 实用工具类型示例
### API 响应工具类型
```typescript

// 基础响应类型
type ApiResponse<T> = {
  data: T;
  status: number;
  message: string;
  timestamp: Date;
};

// 分页响应
type PaginatedResponse<T> = ApiResponse<T[]> & {
  pagination: {
    page: number;
    limit: number;
    total: number;
    hasNext: boolean;
  };
};

// 错误响应
type ErrorResponse = Omit<ApiResponse<null>, "data"> & {
  error: {
    code: string;
    details?: any;
  };
};

// 条件响应类型
type ConditionalResponse<T> = T extends Error 
  ? ErrorResponse 
  : ApiResponse<T>;

// 使用示例
function handleResponse<T>(response: ConditionalResponse<T>) {
  if ("error" in response) {
    // 处理错误响应
    console.error(response.error.code);
  } else {
    // 处理成功响应
    console.log(response.data);
  }
}
```

### 表单状态工具类型
```typescript
// 表单字段状态
type FieldState<T> = {
  value: T;
  error?: string;
  touched: boolean;
  valid: boolean;
};

// 动态表单类型
type FormState<T extends Record<string, any>> = {
  [K in keyof T]: FieldState<T[K]>;
} & {
  valid: boolean;
  submitted: boolean;
  submitting: boolean;
};

// 表单更新操作
type FormAction<T> =
  | { type: "SET_VALUE"; field: keyof T; value: any }
  | { type: "SET_ERROR"; field: keyof T; error: string }
  | { type: "SET_TOUCHED"; field: keyof T; touched: boolean }
  | { type: "RESET" };

// 表单工具函数
function createFormReducer<T extends Record<string, any>>(initialValues: T) {
  return function formReducer(
    state: FormState<T>,
    action: FormAction<T>
  ): FormState<T> {
    // 表单状态更新逻辑
    return state;
  };
}
```

## 最佳实践
### 工具类型的命名规范
```typescript
// 好的命名
type UserDTO = Omit<User, "password">;
type ApiResponse<T> = { data: T; status: number };
type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> };

// 避免的命名
type MyType1 = Omit<User, "password">; // 无意义的名字
type TR = { data: any; status: number }; // 缩写不清晰
8.2 合理使用工具类型组合
```typescript

// 清晰的组合
type UserProfile = Pick<User, "id" | "name" | "email">;
type UserSettings = Partial<Pick<User, "theme" | "language">>;

// 避免过度组合
type ComplexType = Partial<Readonly<Omit<Pick<User, "id" | "name">, "id">>>;
// 过于复杂，难以理解
8.3 性能考虑
```typescript

// 简单的工具类型
type Simple = Pick<User, "id" | "name">;

// 复杂的递归类型可能影响编译性能
type VeryDeep<T> = {
  [P in keyof T]: VeryDeep<T[P]>;
};

// 对于深度嵌套的类型，考虑使用内置工具类型
type ReadonlyArrayDeep<T> = ReadonlyArray<Readonly<T>>;
```

## 总结
TypeScript 的工具类型提供了强大的类型操作能力：

- ​基础转换​：Partial、Required、Readonly、Record

- ​属性操作​：Pick、Omit、Extract、Exclude

- ​函数操作​：ReturnType、Parameters、ConstructorParameters、InstanceType

- ​条件类型​：NonNullable、条件类型工具

- ​字符串操作​：Uppercase、Lowercase、Capitalize、Uncapitalize

​关键优势：​​

- 提高类型安全性

- 减少重复类型定义

- 增强代码可维护性

- 提供更好的开发体验

​使用建议：​​

- 根据具体场景选择合适的工具类型

- 避免过度复杂的类型组合

- 为复杂工具类型添加详细注释

- 期回顾和重构类型定义

掌握这些工具类型将帮助你编写更加健壮和可维护的 TypeScript 代码。