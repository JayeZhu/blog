---
title: TS映射类型
date: 2025-10-11 17:05:29
permalink: /pages/736081/
categories:
  - 前端
tags:
  - TypeScript
  - TS进阶
---
:::tip
映射类型是 TypeScript 中强大的类型编程工具，它允许我们基于现有类型创建新的类型。遵循 DRY （Don't Repeat Yourself）原则，映射类型可以减少重复代码，提高代码的可维护性和可读性。在本文中，我们将深入探讨 TypeScript 映射类型，包括其基本语法、常见用法以及高级技巧。
:::
<!-- more -->

## 前置知识

### 索引访问类型
通过索引访问类型，我们可以获取类型中特定属性的类型

```typescript
interface AppConfig {
  username: string;
  layout: string;
}

type UsernameType = AppConfig["username"]; // string
type LayoutType = AppConfig["layout"];     // string

// 访问嵌套属性
interface User {
  profile: {
    name: string;
    age: number;
  };
}

type ProfileName = User["profile"]["name"]; // string

// 联合类型访问
type ConfigKeys = AppConfig[keyof AppConfig]; // string
```

### 索引签名
当属性名称未知但数据类型已知时，可以使用索引签名。
```ts
interface LanguagePreferences {
  [language: string]: string;
}

const preferences: LanguagePreferences = {
  en: "English",
  zh: "Chinese",
  ja: "Japanese"
};

const currentLang = preferences["en"]; // string 类型
```

###  keyof 类型运算符
keyof运算符返回类型的所有键组成的联合类型。
```ts
interface AppConfig {
  username: string;
  layout: string;
  theme: string;
}

type AppConfigKey = keyof AppConfig; // "username" | "layout" | "theme"

// 与索引签名结合
interface Dictionary {
  [key: string]: number;
}

type DictKeys = keyof Dictionary; // string | number
```

### 条件类型
条件类型根据条件选择不同的类型，语法类似于三元表达式。
```ts
type IsString<T> = T extends string ? true : false;

type Test1 = IsString<string>;  // true
type Test2 = IsString<number>; // false

// 分布式条件类型
type ToArray<T> = T extends any ? T[] : never;
type StringOrNumberArray = ToArray<string | number>; // string[] | number[]
```

## 映射类型基础

### 初体验：理解映射类型
映射类型允许我们基于现有类型创建新的类型，保持类型间的同步关系。
```ts
// 原始配置类型
interface AppConfig {
  username: string;
  layout: string;
  theme: string;
}

// 权限类型 - 手动维护（容易不同步）
interface AppPermissions {
  canEditUsername: boolean;
  canChangeLayout: boolean;
  canChangeTheme: boolean;
}

// 使用映射类型自动同步
type AutoPermissions = {
  [Key in keyof AppConfig]: boolean;
};

// 等价于：
// {
//   username: boolean;
//   layout: boolean;
//   theme: boolean;
// }
```

### 映射类型概念
```ts
// 基本映射类型语法
type Mapping<T> = {
  [P in keyof T]: NewType;
};
```
这类似于 JavaScript 中的 Array.prototype.map()：

```ts
// JavaScript 数组映射
const numbers = [1, 2, 3];
const strings = numbers.map(num => num.toString());

// TypeScript 类型映射
type Numbers = [1, 2, 3];
type Strings = {
  [K in keyof Numbers]: Numbers[K] extends number ? string : never;
}; // [string, string, string]
```

## 映射类型实例
### 设备格式化示例
```ts
// 原始设备类型
interface Device {
  manufacturer: string;
  price: number;
  releaseYear: number;
}

// 创建格式化类型
type DeviceFormatter = {
  [Key in keyof Device as `format${Capitalize<Key>}`]: 
    (value: Device[Key]) => string;
};

// 等价于：
// {
//   formatManufacturer: (value: string) => string;
//   formatPrice: (value: number) => string;
//   formatReleaseYear: (value: number) => string;
// }

// 具体实现
const formatter: DeviceFormatter = {
  formatManufacturer: (manufacturer) => `制造商: ${manufacturer}`,
  formatPrice: (price) => `价格: $${price.toFixed(2)}`,
  formatReleaseYear: (year) => `发布年份: ${year}`
};

// 自动同步：当添加新属性时
interface UpdatedDevice extends Device {
  weight: number;
}

type UpdatedFormatter = {
  [Key in keyof UpdatedDevice as `format${Capitalize<Key>}`]: 
    (value: UpdatedDevice[Key]) => string;
};
// 自动包含 formatWeight: (value: number) => string;
```

### 只读包装器
```typescript
// 创建深度只读类型
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object 
    ? T[P] extends Function 
      ? T[P] 
      : DeepReadonly<T[P]>
    : T[P];
};

interface UserSettings {
  profile: {
    name: string;
    email: string;
  };
  preferences: {
    theme: string;
    language: string;
  };
}

type ReadonlySettings = DeepReadonly<UserSettings>;

const settings: ReadonlySettings = {
  profile: {
    name: "John",
    email: "john@example.com"
  },
  preferences: {
    theme: "dark",
    language: "en"
  }
};

// settings.profile.name = "Jane"; // 错误：只读属性
// settings.preferences.theme = "light"; // 错误：只读属性
```

## 内置映射类型解析
### Partial 实现原理
Partial将类型的所有属性变为可选。

```typescript
// Partial 的实现
type Partial<T> = {
  [P in keyof T]?: T[P];
};

interface Point3D {
  x: number;
  y: number;
  z: number;
}

type PartialPoint3D = Partial<Point3D>;
// 等价于：
// {
//   x?: number;
//   y?: number;
//   z?: number;
// }

// 使用示例
function updatePoint(point: Point3D, updates: Partial<Point3D>): Point3D {
  return { ...point, ...updates };
}

const point: Point3D = { x: 1, y: 2, z: 3 };
updatePoint(point, { x: 10 }); // 只更新 x 坐标
```

### Readonly 实现原理
Readonly将类型的所有属性变为只读。

```typescript
// Readonly 的实现
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

interface Config {
  apiUrl: string;
  timeout: number;
}

type ReadonlyConfig = Readonly<Config>;

const config: ReadonlyConfig = {
  apiUrl: "https://api.example.com",
  timeout: 5000
};

// config.apiUrl = "new-url"; // 错误：只读属性
```

### Pick 实现原理
Pick从类型中选择指定的属性。

```typescript
// Pick 的实现
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

interface User {
  id: number;
  name: string;
  email: string;
  age: number;
  createdAt: Date;
}

type UserPreview = Pick<User, "id" | "name" | "email">;
// 等价于：
// {
//   id: number;
//   name: string;
//   email: string;
// }
```

### Record 实现原理
Record创建键值对对象类型。

```typescript
// Record 的实现
type Record<K extends keyof any, T> = {
  [P in K]: T;
};

type UserRole = "admin" | "user" | "guest";
type Permissions = Record<UserRole, string[]>;

const permissions: Permissions = {
  admin: ["read", "write", "delete"],
  user: ["read", "write"],
  guest: ["read"]
};
```

## 高级映射技巧
### 键重映射（Key Remapping）
TypeScript 4.1 引入了键重映射，允许在映射过程中修改键名。

```typescript
// 添加前缀
type AddPrefix<T, Prefix extends string> = {
  [K in keyof T as `${Prefix}${Capitalize<string & K>}`]: T[K];
};

interface User {
  name: string;
  age: number;
}

type PrefixedUser = AddPrefix<User, "get">;
// 等价于：
// {
//   getName: string;
//   getAge: number;
// }

// 过滤属性
type FilterByType<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K];
};

interface Example {
  name: string;
  age: number;
  isActive: boolean;
  update(): void;
}

type StringProperties = FilterByType<Example, string>; // { name: string }
type FunctionProperties = FilterByType<Example, Function>; // { update: () => void }
```

### 条件映射
结合条件类型进行更复杂的映射。

```typescript
// 根据条件转换属性类型
type ConditionalMap<T> = {
  [K in keyof T]: T[K] extends string 
    ? string 
    : T[K] extends number 
      ? number 
      : never;
};

// 可选属性处理
type RequiredByType<T, U> = {
  [K in keyof T]: T[K] extends U 
    ? T[K] 
    : T[K] | undefined;
};
```

## 构建自定义映射类型
###  Optional 映射类型
创建将指定属性变为可选的映射类型。

```typescript
// 方法一：使用现有工具类型组合
type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

// 方法二：直接实现
type OptionalDirect<T, K extends keyof T> = {
  [P in K]?: T[P];
} & {
  [P in Exclude<keyof T, K>]: T[P];
};

interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

type UserWithoutAge = Optional<User, "age">;
// 等价于：
// {
//   id: number;
//   name: string;
//   email: string;
//   age?: number;
// }

// 测试用例
const user1: UserWithoutAge = {
  id: 1,
  name: "John",
  email: "john@example.com"
  // age 是可选的
};

const user2: UserWithoutAge = {
  id: 2,
  name: "Jane",
  email: "jane@example.com",
  age: 25 // 也可以提供 age
};
```

### 深度映射类型
创建处理嵌套对象的映射类型。

```typescript
// 深度 Partial
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object 
    ? T[P] extends Function 
      ? T[P] 
      : DeepPartial<T[P]>
    : T[P];
};

// 深度 Required
type DeepRequired<T> = {
  [P in keyof T]-?: T[P] extends object 
    ? T[P] extends Function 
      ? T[P] 
      : DeepRequired<T[P]>
    : T[P];
};

interface NestedConfig {
  database: {
    host: string;
    port: number;
    credentials: {
      username: string;
      password: string;
    };
  };
  api: {
    timeout: number;
    retries: number;
  };
}

type PartialConfig = DeepPartial<NestedConfig>;
// 所有属性都是可选的，包括嵌套属性

const config: PartialConfig = {
  database: {
    host: "localhost",
    // port 和 credentials 是可选的
  }
  // api 也是可选的
};
```

### 函数属性映射
专门处理函数属性的映射类型。

```typescript
// 将方法转换为异步版本
type AsyncMethods<T> = {
  [K in keyof T]: T[K] extends (...args: infer A) => infer R 
    ? (...args: A) => Promise<R> 
    : T[K];
};

interface UserService {
  getUser(id: number): User;
  createUser(user: Omit<User, "id">): User;
  deleteUser(id: number): void;
}

type AsyncUserService = AsyncMethods<UserService>;
// 等价于：
// {
//   getUser: (id: number) => Promise<User>;
//   createUser: (user: Omit<User, "id">) => Promise<User>;
//   deleteUser: (id: number) => Promise<void>;
// }
```

## 实际应用场景
### API 响应标准化
```typescript
// 基础响应类型
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

// 使用映射类型创建标准化 API
type StandardizedApi<T> = {
  [K in keyof T]: T[K] extends (...args: infer A) => infer R 
    ? (...args: A) => Promise<ApiResponse<R>> 
    : never;
};

interface UserEndpoints {
  getUser(id: number): User;
  createUser(user: Omit<User, "id">): User;
  updateUser(id: number, updates: Partial<User>): User;
}

type StandardizedUserApi = StandardizedApi<UserEndpoints>;

// 自动生成的类型：
// {
//   getUser: (id: number) => Promise<ApiResponse<User>>;
//   createUser: (user: Omit<User, "id">) => Promise<ApiResponse<User>>;
//   updateUser: (id: number, updates: Partial<User>) => Promise<ApiResponse<User>>;
// }
```

### 表单状态管理
```typescript
// 表单字段状态
type FieldState<T> = {
  value: T;
  error?: string;
  touched: boolean;
  valid: boolean;
};

// 动态表单类型
type FormState<T extends Record<string, any>> = {
  [K in keyof T]: FieldState<T[K]>;
} & {
  valid: boolean;
  submitted: boolean;
};

interface LoginForm {
  email: string;
  password: string;
  rememberMe: boolean;
}

type LoginFormState = FormState<LoginForm>;
// 等价于：
// {
//   email: FieldState<string>;
//   password: FieldState<string>;
//   rememberMe: FieldState<boolean>;
//   valid: boolean;
//   submitted: boolean;
// }

// 表单操作类型
type FormActions<T extends Record<string, any>> = {
  [K in keyof T as `set${Capitalize<string & K>}`]: 
    (value: T[K]) => void;
} & {
  [K in keyof T as `validate${Capitalize<string & K>}`]: 
    () => boolean;
} & {
  submit: () => void;
  reset: () => void;
};

type LoginFormActions = FormActions<LoginForm>;
// 自动生成的操作方法：
// {
//   setEmail: (value: string) => void;
//   setPassword: (value: string) => void;
//   setRememberMe: (value: boolean) => void;
//   validateEmail: () => boolean;
//   validatePassword: () => boolean;
//   validateRememberMe: () => boolean;
//   submit: () => void;
//   reset: () => void;
// }
```

## 最佳实践和注意事项
### 性能考虑
```typescript
// 简单的映射类型性能较好
type SimpleMap<T> = {
  [K in keyof T]: T[K];
};

// 复杂的递归映射类型可能影响编译性能
type ComplexDeepMap<T> = {
  [K in keyof T]: T[K] extends object 
    ? ComplexDeepMap<T[K]> 
    : T[K];
};

// 对于深度嵌套，考虑使用内置工具类型
type ReadonlyArrayDeep<T> = ReadonlyArray<Readonly<T>>;
```

### 类型安全性
```typescript
// 使用约束确保类型安全
type SafeMap<T extends Record<string, any>> = {
  [K in keyof T]: T[K];
};

// 避免过于复杂的类型操作
// 不好的做法：过度复杂的映射
type OverlyComplex<T> = {
  [K in keyof T as K extends string 
    ? `formatted${Capitalize<K>}` 
    : never]: T[K] extends number 
      ? string 
      : T[K] extends string 
        ? `Formatted: ${T[K]}` 
        : never;
};

// 好的做法：保持简洁和可读性
type SimpleFormat<T> = {
  [K in keyof T]: string;
};
```

### 组合使用
```typescript
// 合理组合映射类型
type UserPreferences = Partial<Pick<User, "theme" | "language">>;

// 避免过度嵌套
// 不好的做法
type ConfusingType = Readonly<Partial<Pick<Omit<User, "id">, "name" | "email">>>;

// 好的做法：分步定义
type UserWithoutId = Omit<User, "id">;
type UserContactInfo = Pick<UserWithoutId, "name" | "email">;
type OptionalContactInfo = Partial<UserContactInfo>;
type ReadonlyContactInfo = Readonly<OptionalContactInfo>;
```

## 总结
映射类型是 TypeScript 类型系统中强大的工具：

- ​基础概念​：基于索引访问、keyof 运算符和条件类型

- ​核心语法​：[K in keyof T]: NewType的映射模式

- ​内置工具​：Partial、Readonly、Pick、Record 等实用类型

- ​高级特性​：键重映射、条件映射、深度映射

- ​自定义构建​：创建符合特定需求的映射类型

​关键优势：​​

- 遵循 DRY 原则，减少重复代码

- 提高类型安全性和一致性

- 增强代码的可维护性

- 提供强大的类型编程能力

​适用场景：​​

- API 响应标准化

- 表单状态管理

- 配置对象处理- 

- 数据转换和验证

掌握映射类型能够让你编写更加灵活和健壮的 TypeScript 代码，是成为 TypeScript 高级开发者的重要一步。