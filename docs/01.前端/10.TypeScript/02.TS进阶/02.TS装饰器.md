---
title: TS装饰器
date: 2025-10-10 18:20:44
permalink: /pages/1d712d/
categories:
  - 前端
tags:
  - TypeScript
  - TS进阶
---
:::tip
装饰器（Decorators）是 TypeScript 中一个强大的实验性特性，它允许我们以声明式的方式修改类及其成员。装饰器提供了元编程的能力，让我们能够在运行时检查和修改类的行为。
:::

## 装饰器基础
### 弃用装饰器支持
在 tsconfig.json 中，将 `"experimentalDecorators"` 设置为 `true`，以启用装饰器支持。

```json
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "target": "ES5"
  }
}
```

### 装饰器工厂
装饰器工厂是一个函数，它返回一个装饰器函数。装饰器工厂可以接受参数，这些参数可以在装饰器函数中使用。装饰器工厂的参数通常是通过函数参数传递的。
```ts
// 装饰器工厂
function color(value: string) {
  // 装饰器函数
  return function (target: any) {
    // 为类添加元数据
    target.prototype.color = value;
  };
}

@color("red")
class Car {
  brand: string;
  
  constructor(brand: string) {
    this.brand = brand;
  }
}

const myCar = new Car("Toyota");
console.log((myCar as any).color); // "red"
```

## 类装饰器
类装饰器是一个函数，它接收一个构造函数作为参数，并返回一个新的构造函数。类装饰器可以用来修改类的行为，例如添加属性、方法或修改类的原型。

### 基本类装饰器

```ts
function sealed(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

@sealed
class Greeter {
  greeting: string;

  constructor(message: string) {
    this.greeting = message;
  }

  greet() {
    return "Hello, " + this.greeting;
  }
}
```

### 修改类的类装饰器
```ts
// 重写构造函数的类装饰器
function classDecorator<T extends { new(...args: any[]): {} }>(constructor: T) {
  return class extends constructor {
    newProperty = "new property";
    hello = "override";
  };
}

@classDecorator
class Greeter {
  property = "property";
  hello: string;
  
  constructor(m: string) {
    this.hello = m;
  }
}

const greeter = new Greeter("world");
console.log(greeter); // 包含 newProperty 和重写的 hello
```

### 带参数的类装饰器
```ts
// 带参数的类装饰器工厂
function table(name: string) {
  return function <T extends { new(...args: any[]): {} }>(constructor: T) {
    return class extends constructor {
      static tableName = name;
      createdAt = new Date();
    };
  };
}

@table("users")
class User {
  id: number;
  name: string;
  
  constructor(id: number, name: string) {
    this.id = id;
    this.name = name;
  }
}

console.log((User as any).tableName); // "users"
const user = new User(1, "John");
console.log((user as any).createdAt); // 当前日期
```

## 方法装饰器
方法装饰器声明在一个方法的声明之前，应用于方法的属性描述符。

### 基本方法装饰器
```ts
// 方法装饰器
function enumerable(value: boolean) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    descriptor.enumerable = value;
  };
}

class Greeter {
  greeting: string;
  
  constructor(message: string) {
    this.greeting = message;
  }
  
  @enumerable(false)
  greet() {
    return "Hello, " + this.greeting;
  }
}

const greeter = new Greeter("world");
for (let key in greeter) {
  console.log(key); // 不会输出 "greet"，因为 enumerable 为 false
}
```

### 日志方法装饰器
```ts
// 日志装饰器
function log(target: any, propertyName: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  
  descriptor.value = function (...args: any[]) {
    console.log(`Calling ${propertyName} with arguments:`, args);
    const result = originalMethod.apply(this, args);
    console.log(`Method ${propertyName} returned:`, result);
    return result;
  };
  
  return descriptor;
}

class Calculator {
  @log
  add(a: number, b: number): number {
    return a + b;
  }
  
  @log
  multiply(a: number, b: number): number {
    return a * b;
  }
}

const calc = new Calculator();
calc.add(2, 3); // 输出调用日志和返回结果
calc.multiply(4, 5); // 输出调用日志和返回结果
```

### 缓存装饰器
```ts
// 缓存装饰器
function cache(target: any, propertyName: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  const cacheMap = new Map();
  
  descriptor.value = function (...args: any[]) {
    const key = JSON.stringify(args);
    
    if (cacheMap.has(key)) {
      console.log(`Cache hit for ${propertyName} with args:`, args);
      return cacheMap.get(key);
    }
    
    const result = originalMethod.apply(this, args);
    cacheMap.set(key, result);
    console.log(`Cached result for ${propertyName} with args:`, args);
    
    return result;
  };
  
  return descriptor;
}

class ExpensiveCalculator {
  @cache
  fibonacci(n: number): number {
    if (n <= 1) return n;
    return this.fibonacci(n - 1) + this.fibonacci(n - 2);
  }
}

const expensiveCalc = new ExpensiveCalculator();
console.log(expensiveCalc.fibonacci(10)); // 第一次计算，会缓存结果
console.log(expensiveCalc.fibonacci(10)); // 第二次直接从缓存获取
```

## 属性装饰器
属性装饰器声明在一个属性的声明之前（紧接在属性声明之后）。

### 基本属性装饰器
```ts
// 属性装饰器
// 属性装饰器
function format(formatString: string) {
  return function (target: any, propertyKey: string) {
    let value = target[propertyKey];
    
    const getter = function () {
      return value;
    };
    
    const setter = function (newVal: any) {
      if (typeof newVal === "string") {
        value = formatString.replace("%s", newVal);
      } else {
        value = newVal;
      }
    };
    
    // 重新定义属性
    Object.defineProperty(target, propertyKey, {
      get: getter,
      set: setter,
      enumerable: true,
      configurable: true
    });
  };
}

class User {
  @format("Hello, %s!")
  greeting: string;
  
  constructor(greeting: string) {
    this.greeting = greeting;
  }
}

const user = new User("John");
console.log(user.greeting); // "Hello, John!"
```

### 类型检查属性装饰器
```ts
// 类型检查装饰器
function typeCheck(type: Function) {
  return function (target: any, propertyKey: string) {
    let value: any;
    
    const getter = function () {
      return value;
    };
    
    const setter = function (newVal: any) {
      if (newVal instanceof type) {
        value = newVal;
      } else {
        throw new Error(`Property ${propertyKey} must be of type ${type.name}`);
      }
    };
    
    Object.defineProperty(target, propertyKey, {
      get: getter,
      set: setter,
      enumerable: true,
      configurable: true
    });
  };
}

class Product {
  @typeCheck(String)
  name: string;
  
  @typeCheck(Number)
  price: number;
  
  constructor(name: string, price: number) {
    this.name = name;
    this.price = price;
  }
}

const product = new Product("Laptop", 999);
// product.name = 123; // 错误：Property name must be of type String
```

## 参数装饰器
参数装饰器声明在一个参数声明之前（紧接在参数列表的后面）。

### 基本参数装饰器
```ts
// 参数装饰器
// 参数装饰器
function required(target: Object, propertyKey: string | symbol, parameterIndex: number) {
  // 为方法添加元数据，标记参数为必需
  const existingRequiredParameters: number[] = 
    Reflect.getOwnMetadata("required", target, propertyKey) || [];
  
  existingRequiredParameters.push(parameterIndex);
  Reflect.defineMetadata("required", existingRequiredParameters, target, propertyKey);
}

// 验证装饰器
function validate(target: any, propertyName: string, descriptor: PropertyDescriptor) {
  const method = descriptor.value;
  
  descriptor.value = function (...args: any[]) {
    const requiredParams: number[] = 
      Reflect.getOwnMetadata("required", target, propertyName) || [];
    
    requiredParams.forEach(index => {
      if (args[index] === undefined || args[index] === null) {
        throw new Error(`Parameter at index ${index} is required`);
      }
    });
    
    return method.apply(this, args);
  };
}

class ApiService {
  @validate
  getUser(@required id: number, name?: string) {
    return { id, name };
  }
}

const api = new ApiService();
api.getUser(1, "John"); // 正常
// api.getUser(undefined, "John"); // 错误：Parameter at index 0 is required
```

### 依赖注入参数装饰器
```ts
// 简单的IoC容器
class Container {
  private services = new Map();
  
  register(token: any, implementation: any) {
    this.services.set(token, implementation);
  }
  
  resolve<T>(token: any): T {
    const service = this.services.get(token);
    if (!service) {
      throw new Error(`Service ${token.name} not found`);
    }
    return service;
  }
}

const container = new Container();

// 依赖注入装饰器
function inject(token: any) {
  return function (target: any, propertyKey: string | symbol, parameterIndex: number) {
    const existingInjections: any[] = 
      Reflect.getOwnMetadata("injections", target, propertyKey) || [];
    
    existingInjections[parameterIndex] = token;
    Reflect.defineMetadata("injections", existingInjections, target, propertyKey);
  };
}

// 注入解析装饰器
function autoInject(target: any, propertyName: string, descriptor: PropertyDescriptor) {
  const method = descriptor.value;
  const injections: any[] = 
    Reflect.getOwnMetadata("injections", target, propertyName) || [];
  
  descriptor.value = function (...args: any[]) {
    const resolvedArgs = injections.map((token, index) => {
      return args[index] !== undefined ? args[index] : container.resolve(token);
    });
    
    return method.apply(this, resolvedArgs);
  };
}

// 服务定义
class UserService {
  getUsers() {
    return [{ id: 1, name: "John" }];
  }
}

class AuthService {
  login() {
    return true;
  }
}

// 注册服务
container.register(UserService, new UserService());
container.register(AuthService, new AuthService());

class AppController {
  @autoInject
  getData(
    @inject(UserService) userService: UserService,
    @inject(AuthService) authService: AuthService
  ) {
    const users = userService.getUsers();
    const isAuthenticated = authService.login();
    return { users, isAuthenticated };
  }
}

const app = new AppController();
console.log(app.getData()); // 自动注入依赖
```

## 访问器装饰器
访问器装饰器声明在一个访问器声明之前（紧接在访问器关键字之后）。

### 基本访问器装饰器
```ts
// 访问器装饰器
// 访问器装饰器
function configurable(value: boolean) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    descriptor.configurable = value;
  };
}

class Point {
  private _x: number;
  private _y: number;
  
  constructor(x: number, y: number) {
    this._x = x;
    this._y = y;
  }
  
  @configurable(false)
  get x() {
    return this._x;
  }
  
  @configurable(false)
  get y() {
    return this._y;
  }
}

const point = new Point(1, 2);
// 由于 configurable 为 false，以下操作会失败
// delete point.x; // 错误
// Object.defineProperty(point, 'x', { get: function() { return 10; } }); // 错误
```

### 验证访问器装饰器
```ts
// 范围验证装饰器
function range(min: number, max: number) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalSet = descriptor.set;
    
    if (originalSet) {
      descriptor.set = function (value: number) {
        if (value < min || value > max) {
          throw new Error(`Value must be between ${min} and ${max}`);
        }
        originalSet.call(this, value);
      };
    }
    
    return descriptor;
  };
}

class Temperature {
  private _celsius: number = 0;
  
  @range(-273, 1000)
  set celsius(value: number) {
    this._celsius = value;
  }
  
  get celsius(): number {
    return this._celsius;
  }
  
  get fahrenheit(): number {
    return this._celsius * 9 / 5 + 32;
  }
  
  set fahrenheit(value: number) {
    this.celsius = (value - 32) * 5 / 9;
  }
}

const temp = new Temperature();
temp.celsius = 25; // 正常
// temp.celsius = -300; // 错误：Value must be between -273 and 1000
```

## 装饰器执行顺序
装饰器在运行时的执行顺序如下：

1. 参数装饰器（如果有的话），按照从右到左的顺序执行。
2. 方法装饰器。
3. 访问器装饰器。
4. 属性装饰器。
5. 类装饰器。

例如，对于以下代码：
```ts
function decoratorFactory(name: string) {
  console.log(`${name} 装饰器工厂执行`);
  return function (target: any) {
    console.log(`${name} 装饰器应用到 ${target.name}`);
  };
}

function methodDecoratorFactory(name: string) {
  console.log(`${name} 方法装饰器工厂执行`);
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log(`${name} 方法装饰器应用到 ${propertyKey}`);
  };
}

function propertyDecoratorFactory(name: string) {
  console.log(`${name} 属性装饰器工厂执行`);
  return function (target: any, propertyKey: string) {
    console.log(`${name} 属性装饰器应用到 ${propertyKey}`);
  };
}

function parameterDecoratorFactory(name: string) {
  console.log(`${name} 参数装饰器工厂执行`);
  return function (target: any, propertyKey: string, parameterIndex: number) {
    console.log(`${name} 参数装饰器应用到 ${propertyKey} 的参数 ${parameterIndex}`);
  };
}

@decoratorFactory("类")
class Example {
  @propertyDecoratorFactory("属性")
  name: string = "test";
  
  constructor(@parameterDecoratorFactory("构造函数参数") name: string) {
    this.name = name;
  }
  
  @methodDecoratorFactory("方法")
  greet(@parameterDecoratorFactory("方法参数") message: string) {
    return `${this.name}: ${message}`;
  }
}
```

## 实际应用示例

### Web 框架路由装饰器
```ts
// 路由装饰器
// 简单的Web框架装饰器
interface RouteConfig {
  path: string;
  method: 'get' | 'post' | 'put' | 'delete';
}

class Router {
  private routes: Array<RouteConfig & { handler: Function }> = [];
  
  addRoute(config: RouteConfig, handler: Function) {
    this.routes.push({ ...config, handler });
  }
  
  handleRequest(path: string, method: string, req: any, res: any) {
    const route = this.routes.find(r => 
      r.path === path && r.method === method.toLowerCase()
    );
    
    if (route) {
      route.handler(req, res);
    } else {
      res.statusCode = 404;
      res.end('Not Found');
    }
  }
}

const router = new Router();

// 路由装饰器工厂
function route(config: RouteConfig) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    router.addRoute(config, descriptor.value);
  };
}

// 控制器类
class UserController {
  @route({ path: '/users', method: 'get' })
  getUsers(req: any, res: any) {
    res.end(JSON.stringify([{ id: 1, name: 'John' }]));
  }
  
  @route({ path: '/users', method: 'post' })
  createUser(req: any, res: any) {
    res.end('User created');
  }
  
  @route({ path: '/users/:id', method: 'get' })
  getUser(req: any, res: any) {
    res.end(JSON.stringify({ id: 1, name: 'John' }));
  }
}

// 模拟HTTP请求
const mockReq = { url: '/users', method: 'GET' };
const mockRes = {
  statusCode: 200,
  end: (data: string) => console.log('Response:', data)
};

router.handleRequest('/users', 'get', mockReq, mockRes);
```

### 数据库实体装饰器
```ts
// 数据库实体装饰器
interface ColumnOptions {
  type: string;
  primaryKey?: boolean;
  nullable?: boolean;
  unique?: boolean;
}

class TableMetadata {
  tableName: string;
  columns: Map<string, ColumnOptions> = new Map();
}

const tableMetadata = new Map<string, TableMetadata>();

// 表装饰器
function table(name: string) {
  return function (constructor: Function) {
    const metadata = new TableMetadata();
    metadata.tableName = name;
    tableMetadata.set(constructor.name, metadata);
  };
}

// 列装饰器
function column(options: ColumnOptions) {
  return function (target: any, propertyKey: string) {
    const className = target.constructor.name;
    const metadata = tableMetadata.get(className) || new TableMetadata();
    metadata.columns.set(propertyKey, options);
    tableMetadata.set(className, metadata);
  };
}

// 实体类
@table('users')
class User {
  @column({ type: 'int', primaryKey: true })
  id: number;
  
  @column({ type: 'varchar(255)', nullable: false })
  name: string;
  
  @column({ type: 'varchar(255)', unique: true })
  email: string;
  
  @column({ type: 'datetime', nullable: true })
  createdAt: Date;
  
  constructor(id: number, name: string, email: string) {
    this.id = id;
    this.name = name;
    this.email = email;
    this.createdAt = new Date();
  }
}

// 生成SQL创建语句
function generateCreateTableSQL(entityClass: Function): string {
  const metadata = tableMetadata.get(entityClass.name);
  if (!metadata) {
    throw new Error(`No metadata found for ${entityClass.name}`);
  }
  
  const columns: string[] = [];
  metadata.columns.forEach((options, columnName) => {
    let columnDef = `${columnName} ${options.type}`;
    
    if (options.primaryKey) {
      columnDef += ' PRIMARY KEY';
    }
    
    if (!options.nullable) {
      columnDef += ' NOT NULL';
    }
    
    if (options.unique) {
      columnDef += ' UNIQUE';
    }
    
    columns.push(columnDef);
  });
  
  return `CREATE TABLE ${metadata.tableName} (${columns.join(', ')});`;
}

console.log(generateCreateTableSQL(User));
// CREATE TABLE users (id int PRIMARY KEY, name varchar(255) NOT NULL, 
// email varchar(255) UNIQUE, createdAt datetime);
```

## 总结
TypeScript 装饰器提供了强大的元编程能力：

- ​类装饰器​：修改或替换类定义

- ​方法装饰器​：修改方法行为，如日志、缓存、验证

- ​属性装饰器​：修改属性访问行为

- ​参数装饰器​：为参数添加元数据，用于验证或依赖注入

- ​访问器装饰器​：修改getter/setter行为

​主要应用场景：​​

- AOP（面向切面编程）：日志、缓存、性能监控

- 依赖注入：自动管理依赖关系

- ORM：数据库映射和验证

- Web框架：路由、中间件、控制器

- 验证：数据验证和类型检查

​注意事项：​​

- 装饰器是实验性特性，API可能发生变化

- 需要启用 experimentalDecorators编译器选项

- 合理使用装饰器，避免过度复杂化代码

- 注意装饰器的执行顺序

装饰器让 TypeScript 具备了强大的元编程能力，是构建复杂应用程序的重要工具。