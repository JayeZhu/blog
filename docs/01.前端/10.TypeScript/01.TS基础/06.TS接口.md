---
title: TS接口
date: 2025-10-10 12:12:22
permalink: /pages/f3cdd3/
categories:
  - 前端
tags:
  - TypeScript
  - TS基础
---
:::tip
接口是TypeScript的核心特性之一，用于定义对象的类型结构。它允许你定义对象应该包含哪些属性和方法，从而提供强大的类型检查能力。
:::

## 接口

### 接口定义

接口使用`interface`关键字定义，可以定义对象的类型结构。接口可以包含属性、方法和索引签名。

```typescript
// 定义一个Person接口
interface Person {
  name: string;
  age: number;
  email?: string; // 可选属性
}

// 使用接口
const person: Person = {
  name: "JayeZhu",
  age: 25,
  // email是可选的，可以省略
};

// 错误示例：缺少必需属性
// const person2: Person = { name: "Jaye" }; // 错误：缺少age属性

// 错误示例：属性类型不匹配
// const person3: Person = { name: "Jaye", age: "25" }; // 错误：age应该是number
```

### 只读属性
接口中，使用 readonly 关键字定义只读属性，表示该属性只能在对象创建时被赋值，之后不能被修改。

```typescript
interface Point {
  readonly x: number;
  readonly y: number;
}

const point: Point = { x: 10, y: 20 };
// point.x = 5; // 错误：无法分配到只读属性
```

### 函数类型
接口可以定义函数类型，包括参数类型和返回值类型。

```typescript
interface SearchFunc {
  (source: string, subString: string): boolean;
}

const mySearch: SearchFunc = function (source, subString) {
  const result = source.search(subString);
  return result > -1;
};

// 参数名不需要匹配接口定义时的名字
const mySearch2: SearchFunc = function(s: string, sub: string): boolean {
  return s.indexOf(sub) > -1;
};
```

## 接口的高级特性
### 可选属性
接口中的属性可以是可选的，使用`?`符号表示。

```typescript
interface Person {
  name: string;
  age?: number;
}

const person: Person = { name: "Alice" };
```

### 索引签名
当你不确定接口会有哪些属性，但知道属性名的类型和值的类型时，可以使用索引签名。

```typescript
interface StringArray {
  [index: number]: string;
}

const myArray: StringArray = ["Bob", "Fred"];
const myStr: string = myArray[0];

// 同时支持字符串和数字索引，但数字索引返回值必须是字符串索引返回值的子类型
interface NumberDictionary {
  [index: string]: number;
  length: number;
  // name: string; // 错误：string类型不是number的子类型
}

// 只读索引签名
interface ReadonlyStringArray {
  readonly [index: number]: string;
}

let myReadonlyArray: ReadonlyStringArray = ["Alice", "Bob"];
// myReadonlyArray[0] = "Mallory"; // 错误：索引签名只读
```

### 接口继承
接口可以继承一个或多个接口，实现接口的复用和扩展。
```ts
interface Shape {
  color: string;
}

interface PenStroke {
  penWidth: number;
}

// 单继承
interface Square extends Shape {
  sideLength: number;
}

// 多继承
interface SquareWithStroke extends Shape, PenStroke {
  sideLength: number;
}

const square: Square = {
  color: "red",
  sideLength: 10
};

const squareStroke: SquareWithStroke = {
  color: "blue",
  penWidth: 5,
  sideLength: 10
};
```

### 混合类型
接口能够描述JavaScript中丰富的类型，比如一个对象可以同时作为函数和对象使用，并具有额外的属性。
```ts
interface Counter {
  (start: number): string;
  interval: number;
  reset(): void;
}

function getCounter(): Counter {
  let counter = function(start: number) { return start.toString(); } as Counter;
  counter.interval = 123;
  counter.reset = function() { console.log("reset"); };
  return counter;
}

const c = getCounter();
c(10);
c.reset();
console.log(c.interval);
```

## 接口与类型别名
接口和类型别名（type）有些相似，但各有适用场景。

### 相似之处
```typescript
// 使用类型别名
type PersonType = {
  name: string;
  age: number;
};

// 使用接口
interface PersonInterface {
  name: string;
  age: number;
}
```

### 主要区别
​扩展方式不同​：接口使用 extends，类型别名使用 &

​声明合并​：接口可以多次声明并自动合并，类型别名不能

```typescript
// 接口扩展
interface Animal {
  name: string;
}

interface Bear extends Animal {
  honey: boolean;
}

// 类型别名扩展
type AnimalType = {
  name: string;
};

type BearType = AnimalType & { 
  honey: boolean 
};

// 接口声明合并
interface Box {
  height: number;
}

interface Box {
  width: number;
}

// 相当于
// interface Box {
//   height: number;
//   width: number;
// }

const box: Box = { height: 10, width: 20 };
```

## 接口的实际应用
### 定义函数参数和返回值
```typescript
// 用户接口
interface User {
  id: number;
  name: string;
  email: string;
}

// 用户服务接口
interface UserService {
  getUser(id: number): Promise<User>;
  createUser(user: Omit<User, "id">): Promise<User>;
  updateUser(id: number, updates: Partial<User>): Promise<User>;
  deleteUser(id: number): Promise<void>;
}

// 实现用户服务
class UserServiceImpl implements UserService {
  async getUser(id: number): Promise<User> {
    // 模拟从API获取用户
    return { id, name: "JayeZhu", email: "jaye@example.com" };
  }

  async createUser(user: Omit<User, "id">): Promise<User> {
    // 模拟创建用户
    return { id: Date.now(), ...user };
  }

  async updateUser(id: number, updates: Partial<User>): Promise<User> {
    // 模拟更新用户
    const user = await this.getUser(id);
    return { ...user, ...updates };
  }

  async deleteUser(id: number): Promise<void> {
    // 模拟删除用户
    console.log(`Deleting user ${id}`);
  }
}
```

### 描述第三方库的形状
```typescript
// 描述jQuery的简化形状
interface JQuery {
  text(content?: string): this;
  html(content?: string): this;
  on(event: string, handler: Function): this;
  off(event: string, handler: Function): this;
  addClass(className: string): this;
  removeClass(className: string): this;
  // ...更多方法
}

// 声明全局变量
declare const $: (selector: string) => JQuery;

// 使用
$("#myButton").on("click", () => {
  console.log("Button clicked");
});
```

### 配置对象接口
```typescript
// 应用配置接口
interface AppConfig {
  readonly apiUrl: string;
  timeout: number;
  retries?: number;
  logging?: {
    level: "debug" | "info" | "warn" | "error";
    enabled: boolean;
  };
}

// 默认配置
const defaultConfig: AppConfig = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3,
  logging: {
    level: "error",
    enabled: true
  }
};

// 创建配置的函数
function createConfig(config: Partial<AppConfig> = {}): AppConfig {
  return { ...defaultConfig, ...config };
}

// 使用
const devConfig = createConfig({
  logging: {
    level: "debug",
    enabled: true
  }
});
```
## 接口的最佳实践
### 使用接口而非类型别名的场景
​需要声明合并时​

​扩展类时​（类可以实现接口）

​描述对象形状时​（更符合面向对象思维）

### 保持接口单一职责
```typescript
// 不好的做法：一个接口做太多事情
interface UserBad {
  id: number;
  name: string;
  save(): void;
  sendEmail(): void;
  validate(): boolean;
}

// 好的做法：拆分接口
interface User {
  id: number;
  name: string;
}

interface UserRepository {
  save(user: User): void;
  findById(id: number): User;
}

interface UserService {
  sendEmail(user: User): void;
  validate(user: User): boolean;
}
```
### 使用可重用的小接口
```typescript
// 基础接口
interface Identifiable {
  id: number;
}

interface Timestampable {
  createdAt: Date;
  updatedAt: Date;
}

interface SoftDeletable {
  deletedAt?: Date;
  isDeleted: boolean;
}

// 组合接口
interface User extends Identifiable, Timestampable, SoftDeletable {
  name: string;
  email: string;
}

// 通用服务接口
interface CrudService<T extends Identifiable> {
  create(item: Omit<T, "id">): Promise<T>;
  read(id: number): Promise<T>;
  update(item: T): Promise<T>;
  delete(id: number): Promise<void>;
}
```