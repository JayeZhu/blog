---
title: TS特殊类型
date: 2025-10-10 11:31:50
permalink: /pages/15ce4c/
categories:
  - 前端
  - TypeScript
  - TS基础
tags:
  - 
---
:::tip
在TypeScript的强大类型系统中，除了常规的数据类型外，还有一组特殊的类型用于处理各种边界情况。这些类型提供了极大的灵活性，但也需要谨慎使用以避免潜在的问题。
:::

## any
any是类型系统的“逃生舱”

### any类型的基本特性
any类型是TypeScript中最灵活的类型，它允许绕过类型检查器的所有限制。
```ts
// 基本用法
let flexible: any = "hello";
flexible = 42;              // 可以重新赋值为数字
flexible = true;            // 可以重新赋值为布尔值
flexible = { key: "value" }; // 可以重新赋值为对象

// 调用不存在的方法（不会在编译时报错）
flexible.nonExistentMethod(); // 编译时通过，运行时可能出错
flexible.toFixed(2);         // 编译时通过，但flexible当前是字符串

// 与任何类型兼容
let num: number = flexible;  // 可以赋值给其他类型
let str: string = flexible;  // 可以赋值给字符串
let bool: boolean = flexible; // 可以赋值给布尔值
```

### any类型的应用场景
```ts
// 1. 迁移遗留 JavaScript 代码
const legacyData: any = getDataFromOldSystem();

// 2. 处理第三方库没有类型定义的情况
declare const thirdPartyLib: any;
const result = thirdPartyLib.doSomething();

// 3. 处理动态内容（如 JSON 解析）
function parseJson(json: string): any {
  try {
    return JSON.parse(json);
  } catch {
    return null;
  }
}

const data = parseJson('{"name": "John", "age": 30}');
console.log(data.name); // 编译时通过，运行时正常

// 4. 快速原型开发
const quickPrototype: any = {
  name: "Test",
  value: 100,
  method() { return this.value; }
};
```

### any类型的风险和最佳实践
```ts
// 危险的使用方式
function dangerousFunction(data: any): number {
  return data.value + data.anotherValue; // 完全失去类型安全
}

// 最佳实践：尽量避免使用 any，或限制其范围
interface PartiallyTyped {
  knownProperty: string;
  [key: string]: any; // 只对未知属性使用 any
}

// 使用类型断言缩小 any 的范围
const uncertain: any = getSomeData();
const typedData = uncertain as { name: string; age: number };

// 逐步替换 any 类型
function migrateFromAny<T>(data: any): T {
  // 在这里添加验证逻辑
  return data as T;
}
```

## unknown
unknown是类型安全的any

### unknown类型的基本特性
unknown类型与any类似，但它更安全，因为对unknown类型的操作需要先进行类型检查。
```ts
// 基本用法
let uncertain: unknown = "hello";
uncertain = 42;              // 可以重新赋值
uncertain = true;            // 可以重新赋值

// 与 any 的关键区别
// uncertain.toUpperCase();   // 错误：unknown 类型不能直接操作
// let str: string = uncertain; // 错误：不能直接赋值给其他类型

// 必须进行类型检查或断言后才能使用
if (typeof uncertain === "string") {
  console.log(uncertain.toUpperCase()); // 安全：已确认是字符串
}

if (typeof uncertain === "number") {
  console.log(uncertain.toFixed(2)); // 安全：已确认是数字
}
```

### unknown类型的应用场景
```ts
// 1. 安全的 JSON 解析
function safeParse(json: string): unknown {
  try {
    return JSON.parse(json);
  } catch {
    return null;
  }
}

const data = safeParse('{"name": "John", "age": 30}');
if (data && typeof data === "object" && "name" in data) {
    console.log(data.name); // 安全：已进行类型检查
}

// 2. 处理用户输入或外部数据
function processInput(input: unknown): string {
  if (typeof input === "string") {
    return input.trim();
  } else if (typeof input === "number") {
    return input.toString();
  } else if (input instanceof Date) {
    return input.toISOString();
  }
  return "Invalid input";
}

// 3. 类型安全的函数参数
function executeSafely(operation: (data: unknown) => void, data: unknown): void {
  // 可以传递任何数据，但操作函数必须处理 unknown 类型
  operation(data);
}
```

### unknown与类型守卫
```ts
// 自定义类型守卫
function isString(value: unknown): value is string {
  return typeof value === "string";
}

function isNumber(value: unknown): value is number {
  return typeof value === "number";
}

function isUser(value: unknown): value is { name: string; age: number } {
  return (
    typeof value === "object" &&
    value !== null &&
    "name" in value &&
    "age" in value &&
    typeof (value as any).name === "string" &&
    typeof (value as any).age === "number"
  );
}

// 使用类型守卫
function handleUnknown(value: unknown): void {
  if (isString(value)) {
    console.log(value.toUpperCase());
  } else if (isNumber(value)) {
    console.log(value.toFixed(2));
  } else if (isUser(value)) {
    console.log(`User: ${value.name}, Age: ${value.age}`);
  }
}
```

## void
void表示没有返回值的函数

### void类型的基本特性
void类型表示没有返回值的函数或表达式。当一个函数没有返回值时，它的返回类型就是void。
```ts
// 函数返回 void
function logMessage(message: string): void {
  console.log(message);
  // 隐式返回 undefined
}

// 显式返回 undefined
function explicitVoid(): void {
  return undefined; // 允许
}

// 箭头函数
const logger: (msg: string) => void = (msg) => {
  console.log(msg);
};

// void 的特殊行为
const results: number[] = [];
const returnValue = results.push(logMessage("test")); 
// push 返回 number，但 logMessage 返回 void
```

### void类型的应用场景
```ts
// 1. 事件处理函数
const button = document.getElementById("myButton");
button?.addEventListener("click", (event: MouseEvent): void => {
  console.log("Button clicked", event);
});

// 2. 回调函数没有返回值时
function processArray(
  items: any[],
  callback: (item: any) => void
): void {
  for (const item of items) {
    callback(item);
  }
}

// 3. 设置类方法
class Configurator {
  private settings: Map<string, any> = new Map();
  
  set(key: string, value: any): void {
    this.settings.set(key, value);
  }
  
  // 虽然返回 void，但可以链式调用（返回 this）
  setAndChain(key: string, value: any): this {
    this.settings.set(key, value);
    return this;
  }
}
```

### void的注意事项
```ts
// void 与 undefined 的区别
function returnsUndefined(): undefined {
    return undefined; // 必须显式返回 undefined
}

function returnsVoid(): void {
    // 可以没有 return，或 return undefined
}

// let v: void = 1; // 错误：不能将 number 赋值给 void
let u: undefined = undefined; // 正确

// void 在泛型中的特殊行为
function handleCallback(callback: () => void): void {
    const result = callback();
    // result 的类型是 void，但实际可能是任何值
}

handleCallback(() => "hello"); // 编译时通过，result 实际是 string
```

## never
never表示永远不会发生的类型

### never类型的基本特性
never类型表示永远不会发生的类型。它通常用于表示函数永远不会返回的分支，或者表示永远不会到达的代码路径。
```ts
// 1. 抛出错误的函数
function error(message: string): never {
  throw new Error(message);
}

// 2. 无限循环
function infiniteLoop(): never {
  while (true) {
    // 永远不会退出
  }
}

// 3. 类型收窄中的不可能分支
function assertNever(value: never): never {
  throw new Error(`Unexpected value: ${value}`);
}
```

### never类型的应用场景
```ts
// 1. 穷尽检查（Exhaustiveness Checking）
type Shape = 
  | { kind: "circle"; radius: number }
  | { kind: "square"; side: number }
  | { kind: "triangle"; base: number; height: number };

function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.side ** 2;
    case "triangle":
      return (shape.base * shape.height) / 2;
    default:
      // 如果 shape 不是上述类型，这里会是 never
      return assertNever(shape);
  }
}

// 2. 过滤掉某些类型
type NonNullable<T> = T extends null | undefined ? never : T;

type T1 = NonNullable<string | number | null | undefined>; // string | number

// 3. 空数组类型
const emptyArray: never[] = [];
// emptyArray.push("anything"); // 错误：不能添加任何元素

// 4. 不可能的条件
function checkImpossible(value: string | number): void {
  if (typeof value === "string" && typeof value === "number") {
    // 这个分支永远不会执行，value 的类型是 never
    console.log(value); // value: never
  }
}
```

### never在条件类型中的应用
```ts
// 从联合类型中排除某些类型
type Exclude<T, U> = T extends U ? never : T;
type T2 = Exclude<"a" | "b" | "c", "a" | "b">; // "c"

// 从联合类型中提取某些类型
type Extract<T, U> = T extends U ? T : never;
type T3 = Extract<"a" | "b" | "c", "a" | "b">; // "a" | "b"

// 映射类型中的过滤
type FilterProperties<T, U> = {
    [K in keyof T]: T[K] extends U ? K : never;
}[keyof T];

interface Example {
    name: string;
    age: number;
    active: boolean;
}

type StringKeys = FilterProperties<Example, string>; // "name"
```
