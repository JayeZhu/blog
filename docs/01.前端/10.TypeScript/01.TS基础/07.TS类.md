---
title: TS类
date: 2029-10-10 15:01:43
permalink: /pages/0c1f1f/
categories:
  - 前端
tags:
  - TypeScript
  - TS基础
---
:::tip
类（Class）是面向对象编程的核心概念。TypeScript不进提供对ES6类的完整支持，还添加了类型朱杰、访问修饰符等特性，使得TypeScript的类更加灵活和强大。
:::
## 类的基本概念
### 类的定义

在TypeScript中，使用`class`关键字来定义一个类。类可以包含属性和方法，属性和方法都可以有类型注解。

```typescript
class Person {
  // 属性
  name: string;
  age: number;

  // 构造函数
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  // 方法
  greet(): string {
    return `Hello, my name is ${this.name} and I am ${this.age} years old.`;
  }
}

// 创建类的实例
const person = new Person("JayeZhu", 29);
console.log(person.greet()); // "Hello, my name is JayeZhu and I am 29 years old."
```

### 类的继承

在TypeScript中，可以使用`extends`关键字来实现类的继承。子类可以继承父类的属性和方法，并且可以添加自己的属性和方法。

```typescript
class Employee extends Person {
  // 新增属性
  employeeId: number;
  department: string;

  constructor(name: string, age: number, employeeId: number, department: string) {
    super(name, age); // 调用父类的构造函数
    this.employeeId = employeeId;
    this.department = department;
  }

  // 重写方法
  greet(): string {
    return `Hello, my name is ${this.name}, I work in ${this.department}.`;
  }

  // 新增方法
  work(): string {
    return `${this.name} is working.`;
  }
}

const employee = new Employee("Alice", 30, 1001, "Engineering");
console.log(employee.greet()); // "Hello, my name is Alice, I work in Engineering."
console.log(employee.work()); // "Alice is working."
```

## 访问修饰符
在TypeScript中，可以使用访问修饰符来控制类成员的访问权限。访问修饰符有三种：`public`、`protected`和`private`。

- `public`：公共的，可以在任何地方访问。
- `protected`：受保护的，只能在类内部和子类中访问。
- `private`：私有的，只能在类内部访问。

### public修饰符
默认的修饰符，公有成员可以在任何地方被访问。
```typescript
class ExamplePublic {
  public name: string; // public可省略

  constructor(name: string) {
    this.name = name;
  }

  public greet() {
    console.log(`Hello, ${this.name}`);
  }
}

const example = new ExamplePublic("Jaye");
console.log(example.name); // 可以访问
example.greet(); // 可以调用
```

### protected修饰符
受保护的成员只能在类内部和子类中访问。
```typescript
class ExamplePrivate {
  private secret: string;

  constructor(secret: string) {
    this.secret = secret;
  }

  reveal() {
    console.log(`The secret is ${this.secret}`); // 类内部可以访问
  }
}

const example = new ExamplePrivate("confidential");
// console.log(example.secret); // 错误：属性"secret"为私有属性，只能在类内部访问
example.reveal(); // 通过公有方法访问
```

### private修饰符
私有的成员只能在类内部访问。
```typescript
class ExampleProtected {
  protected value: string;

  constructor(value: string) {
    this.value = value;
  }
}

class SubExample extends ExampleProtected {
  getValue(): string {
    return this.value; // 子类可以访问受保护成员
  }
}

const example = new ExampleProtected("test");
// console.log(example.value); // 错误：属性"value"受保护，只能在类内部和子类中访问

const subExample = new SubExample("test");
console.log(subExample.getValue()); // "test"
```

## 只读属性
在TypeScript中，可以使用`readonly`关键字来定义只读属性。只读属性只能在声明时或构造函数中赋值，之后不能修改。

```typescript
class ExampleReadonly {
  readonly constant: string;
  readonly value: number = 42; // 声明时初始化

  constructor(constant: string) {
    this.constant = constant; // 构造函数中初始化
  }

  attemptChange() {
    // this.constant = "new value"; // 错误：无法分配到只读属性
    // this.value = 100; // 错误：无法分配到只读属性
  }
}

const example = new ExampleReadonly("immutable");
console.log(example.constant); // "immutable"
console.log(example.value); // 42
```

## 存取器
在TypeScript中，可以使用存取器（getters和setters）来控制对类属性的访问和修改。存取器可以用于验证属性的值，或者在属性被访问或修改时执行一些额外的逻辑。

```typescript
class PersonWithAccessors {
  private _name: string;
  private _age: number;

  constructor(name: string, age: number) {
    this._name = name;
    this._age = age;
  }

  // getter
  get name(): string {
    return this._name;
  }

  // setter
  set name(newName: string) {
    if (newName.length < 2) {
      throw new Error("Name must be at least 2 characters long.");
    }
    this._name = newName;
  }

  get age(): number {
    return this._age;
  }

  set age(newAge: number) {
    if (newAge < 0) {
      throw new Error("Age cannot be negative.");
    }
    this._age = newAge;
  }
}

const person = new PersonWithAccessors("Jaye", 29);
console.log(person.name); // "Jaye"
person.name = "Al"; // 设置新名字
// person.name = "A"; // 错误：Name must be at least 2 characters long.
```

## 静态属性
在TypeScript中，可以使用`static`关键字来定义静态属性。静态属性属于类本身，而不是类的实例。可以通过类名直接访问静态属性，而不需要创建类的实例。

```typescript
class MathUtils {
  static readonly PI: number = 3.14159;

  static calculateCircleArea(radius: number): number {
    return this.PI * radius * radius;
  }

  static double(value: number): number {
    return value * 2;
  }
}

console.log(MathUtils.PI); // 3.14159
console.log(MathUtils.calculateCircleArea(5)); // 78.53975
console.log(MathUtils.double(10)); // 20

// 实例无法访问静态属性
const utils = new MathUtils();
// console.log(utils.PI); // 错误：属性"PI"在实例上不存在
```

## 抽象类
抽象类作为其他类的基类，不能直接实例化、抽象方法必须在派生类中实现。
```typescript
abstract class Animal {
  protected name: string;

  constructor(name: string) {
    this.name = name;
  }

  // 抽象方法，必须在派生类中实现
  abstract makeSound(): void;

  // 普通方法
  move(distance: number = 0): void {
    console.log(`${this.name} moved ${distance}m.`);
  }
}

class Dog extends Animal {
  constructor(name: string) {
    super(name);
  }

  makeSound(): void {
    console.log("Woof! Woof!");
  }
}

class Cat extends Animal {
  constructor(name: string) {
    super(name);
  }

  makeSound(): void {
    console.log("Meow! Meow!");
  }
}

// const animal = new Animal("Some animal"); // 错误：无法创建抽象类的实例

const dog = new Dog("Buddy");
dog.makeSound(); // "Woof! Woof!"
dog.move(10); // "Buddy moved 10m."

const cat = new Cat("Kitty");
cat.makeSound(); // "Meow! Meow!"
```

## 接口实现
类可以使用 `implements` 关键字实现接口，确保类满足接口定义的契约。
```typescript
// 定义接口
interface Identifiable {
  id: number;
}

interface Auditable {
  createdAt: Date;
  updatedAt: Date;
}

// 类实现接口
class User implements Identifiable, Auditable {
  id: number;
  name: string;
  createdAt: Date;
  updatedAt: Date;

  constructor(id: number, name: string) {
    this.id = id;
    this.name = name;
    this.createdAt = new Date();
    this.updatedAt = new Date();
  }

  update(): void {
    this.updatedAt = new Date();
  }
}

const user = new User(1, "Jaye");
console.log(user.id); // 1
console.log(user.createdAt); // 当前日期时间
```

## 高级特性
### 参数属性
在构造函数参数前添加访问修饰符可以同时声明并初始化属性。

```typescript
class ParameterProperties {
  // 传统方式
  // private name: string;
  // private age: number;

  // constructor(name: string, age: number) {
  //   this.name = name;
  //   this.age = age;
  // }

  // 使用参数属性
  constructor(private name: string, private age: number) {
    // 自动将参数赋值给同名属性
  }

  getDetails(): string {
    return `${this.name} is ${this.age} years old.`;
  }
}

const example = new ParameterProperties("Jaye", 29);
console.log(example.getDetails()); // "Jaye is 29 years old."
```

### 类表达式
与函数表达式类似，类也可以使用表达式形式定义。

```typescript
const Person = class {
  constructor(public name: string, public age: number) {}

  greet() {
    return `Hello, ${this.name}`;
  }
};

const person = new Person("Jaye", 29);
console.log(person.greet()); // "Hello, Jaye"
```

### 装饰器（实验性特性）
装饰器是一种特殊类型的声明，可以附加到类声明、方法、属性或参数上。

```typescript
// 需要在tsconfig.json中启用 experimentalDecorators
function sealed(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

@sealed
class Greeter {
  greeting: string;

  constructor(message: string) {
    this.greeting = message;
  }

  greet() {
    return "Hello, " + this.greeting;
  }
}
```

## 实际应用示例
### 实现简单的数据存储
```typescript
interface Storable {
  id: number;
  save(): void;
  load(id: number): void;
}

abstract class BaseRepository implements Storable {
  id: number;

  constructor(public tableName: string) {}

  abstract save(): void;
  abstract load(id: number): void;

  protected log(message: string): void {
    console.log(`[${this.tableName}] ${message}`);
  }
}

class UserRepository extends BaseRepository {
  constructor() {
    super("users");
  }

  save(): void {
    this.log(`Saving user with id: ${this.id}`);
    // 实际保存逻辑
  }

  load(id: number): void {
    this.log(`Loading user with id: ${id}`);
    this.id = id;
    // 实际加载逻辑
  }
}

const userRepo = new UserRepository();
userRepo.load(1);
userRepo.save();
```

### 实现观察者模式
```typescript
interface Observer {
  update(subject: Subject): void;
}

interface Subject {
  attach(observer: Observer): void;
  detach(observer: Observer): void;
  notify(): void;
}

class ConcreteSubject implements Subject {
  private observers: Observer[] = [];
  public state: number = 0;

  attach(observer: Observer): void {
    if (this.observers.includes(observer)) {
      return;
    }
    this.observers.push(observer);
  }

  detach(observer: Observer): void {
    const index = this.observers.indexOf(observer);
    if (index !== -1) {
      this.observers.splice(index, 1);
    }
  }

  notify(): void {
    for (const observer of this.observers) {
      observer.update(this);
    }
  }

  someBusinessLogic(): void {
    this.state = Math.floor(Math.random() * 10);
    this.notify();
  }
}

class ConcreteObserver implements Observer {
  update(subject: Subject): void {
    if (subject instanceof ConcreteSubject) {
      console.log(`Observer: Reacted to the state change: ${subject.state}`);
    }
  }
}

// 使用观察者模式
const subject = new ConcreteSubject();
const observer1 = new ConcreteObserver();
const observer2 = new ConcreteObserver();

subject.attach(observer1);
subject.attach(observer2);

subject.someBusinessLogic();
// 输出:
// Observer: Reacted to the state change: 5
// Observer: Reacted to the state change: 5

subject.detach(observer2);
subject.someBusinessLogic();
// 输出:
// Observer: Reacted to the state change: 3
```