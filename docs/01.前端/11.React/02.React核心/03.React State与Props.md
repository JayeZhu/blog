---
title: React State与Props
date: 2025-10-16 18:22:49
permalink: /pages/ceae4d/
categories:
  - 前端
  - React
  - React核心
tags:
  - 
---
## State管理

### 1. 基本State使用

```javascript
// 类组件中的State
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  handleClick = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <button onClick={this.handleClick}>
        Count: {this.state.count}
      </button>
    );
  }
}

// 函数组件中的State
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
```

### 2. State更新规则

```javascript
// 正确更新
this.setState(prevState => ({
  count: prevState.count + 1
}));

// 错误更新
this.setState({
  count: this.state.count + 1
});
```

## Props传递

### 1. 基本Props传递

```javascript
// 父组件
function Parent() {
  return <Child message="Hello from Parent" />;
}

// 子组件
function Child(props) {
  return <div>{props.message}</div>;
}

// 使用解构
function Child({ message }) {
  return <div>{message}</div>;
}
```

### 2. Props类型验证

```javascript
import PropTypes from 'prop-types';

function Button({ type, onClick, children }) {
  return (
    <button type={type} onClick={onClick}>
      {children}
    </button>
  );
}

Button.propTypes = {
  type: PropTypes.oneOf(['button', 'submit']),
  onClick: PropTypes.func.isRequired,
  children: PropTypes.node.isRequired
};
```

### 3. 默认Props设置

```javascript
function Button({ 
  type = 'button', 
  onClick = () => {}, 
  children 
}) {
  return (
    <button type={type} onClick={onClick}>
      {children}
    </button>
  );
}
```

## 数据流向

### 1. 单向数据流

```javascript
// 数据从父流向子
function Parent() {
  const [data, setData] = useState('initial data');

  return (
    <div>
      <Child data={data} onChange={setData} />
    </div>
  );
}

function Child({ data, onChange }) {
  return (
    <input 
      value={data} 
      onChange={e => onChange(e.target.value)} 
    />
  );
}
```

### 2. 状态提升

```javascript
// 将共享状态提升到最近的共同父组件
function Parent() {
  const [value, setValue] = useState('');

  return (
    <div>
      <Child1 value={value} onChange={setValue} />
      <Child2 value={value} />
    </div>
  );
}
```

### 3. Context传递

```javascript
// 创建Context
const ThemeContext = React.createContext('light');

// 提供者
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}

// 消费者
function Button() {
  const theme = useContext(ThemeContext);
  return <button className={theme}>Click me</button>;
}
```

## 最佳实践

### 1. State设计原则

```javascript
// 保持state最小化
function UserForm() {
  const [user, setUser] = useState({
    name: '',
    email: '',
    age: ''
  });

  // 分离更新
  const updateName = (name) => {
    setUser(prev => ({ ...prev, name }));
  };

  return (
    <div>
      <input value={user.name} onChange={e => updateName(e.target.value)} />
      {/* 其他输入框 */}
    </div>
  );
}
```

### 2. Props使用规范

```javascript
// 使用默认值和类型检查
function UserCard({ 
  user = { name: '', avatar: '' },
  onUserClick = () => {},
  variant = 'default'
}) {
  return (
    <div className={`user-card-${variant}`} onClick={onUserClick}>
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
    </div>
  );
}
```

### 3. 性能优化

```javascript
// 使用memo优化Props比较
const UserCard = React.memo(function UserCard({ user }) {
  return <div>{user.name}</div>;
});

// 使用useCallback优化回调
function Parent() {
  const [count, setCount] = useState(0);
  
  const handleClick = useCallback(() => {
    // 处理点击
  }, []); // 依赖数组

  return <Child onClick={handleClick} />;
}
```

## 总结

1. **State管理**
   - 保持state最小化
   - 正确使用setState
   - 避免直接修改state

2. **Props传递**
   - 使用解构赋值
   - 添加类型检查
   - 设置默认值

3. **数据流向**
   - 遵循单向数据流
   - 合理使用状态提升
   - 适当使用Context

这些概念和实践将帮助你构建更可维护、可预测的React应用。