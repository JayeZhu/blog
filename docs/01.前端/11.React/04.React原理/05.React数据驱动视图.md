---
title: React数据驱动视图
date: 2025-10-20 06:28:38
permalink: /pages/4a83e6/
categories:
  - 前端
tags:
  - React
  - React原理
---

我们已经深入探讨了 React 的渲染机制，从 JSX 到 Fiber，再到最终的页面绘制。但这一切更新的驱动力是什么？是什么让 UI 产生变化？答案就是 **数据**。在 React 的世界里，数据是唯一的真理来源，而 **State** 和 **Props** 是承载和传递数据的两个核心概念。本章，我们将彻底理解它们是如何协同工作，驱动视图变化的。

## 5.1 Props：组件的“配置文件”

想象一下你正在组装一台电脑。CPU、内存条、硬盘都是独立的组件，但它们需要通过主板连接，并接收电源才能工作。在 React 中，**Props（Properties）** 就像是组件的“配置文件”或“输入接口”，它允许父组件向子组件传递数据，从而控制子组件的行为和外观。

### 5.1.1 Props 是只读的

Props 的一个核心特性是：**它是只读的**。一个组件绝不能修改自己的 props。

```jsx
function Welcome(props) {
  // 错误！Props 是只读的，不能被修改。
  props.name = 'New Name'; 

  return <h1>Hello, {props.name}</h1>;
}
```

这个规定确保了数据的单向流动，使得组件的行为更加可预测。子组件只能被动地接收和使用 props，而不能改变它。如果需要根据 props 的值来改变 UI，正确的做法是在组件内部使用 state。

### 5.1.2 父子组件通信

Props 是 React 中父子组件通信的主要方式。父组件通过在 JSX 中给子组件添加属性来传递数据。

```jsx
// 父组件 App
function App() {
  return <Welcome name="Sara" />;
}

// 子组件 Welcome
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

在这个例子中，`App` 组件是父组件，它向 `Welcome` 子组件传递了一个名为 `name` 的 prop。`Welcome` 组件通过 `props.name` 接收到这个值，并将其渲染在页面上。

这种机制使得组件高度可复用。我们可以用不同的 props 来渲染同一个组件，得到不同的结果。

```jsx
function App() {
  return (
    <div>
      <Welcome name="Sara" />
      <Welcome name="Cahal" />
      <Welcome name="Edite" />
    </div>
  );
}
```

## 5.2 State：组件的“私人记忆”

如果说 props 是组件的外部配置，那么 **State** 就是组件的“私人记忆”或内部状态。它是组件内部可变的数据，当 state 发生变化时，React 会自动重新渲染该组件及其子组件，以反映最新的状态。

### 5.2.1 类组件中的 `this.setState()`

在类组件中，我们通过在构造函数中初始化 `this.state`，并通过调用 `this.setState()` 来更新它。

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 }; // 初始化 state
  }

  handleClick = () => {
    // 使用 setState 更新 state
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <button onClick={this.handleClick}>
        Clicked {this.state.count} times
      </button>
    );
  }
}
```

**`setState` 的工作原理**：
*   **异步更新**：`this.setState()` 不会立即更新 `this.state`。在React的可控事件处理函数​（如onClick）和生命周期函数中，多个setState调用会被批量处理（Batching），只触发一次重新渲染。然而，在异步操作​（如setTimeout, Promise, 原生事件监听器）的回调中，默认不会批量更新。React 18引入的createRoot通过自动批处理解决了这一差异，使所有场景下的更新默认都是批处理的。
*   **触发重新渲染**：当 `setState` 被调用时，React 会将组件加入更新队列，并安排一次重新渲染。
*   **合并更新**：当你调用 `setState` 时，React 会将你提供的对象与当前的 `state` 进行浅合并，而不是完全替换。

```jsx
// 假设 this.state = { name: 'React', age: 10 }
this.setState({ age: 11 });
// 新的 state 会是 { name: 'React', age: 11 }，而不是 { age: 11 }，进行的是浅合并
```

### 5.2.2 函数组件中的 `useState` Hook

在函数组件中，我们没有 `this`，也没有 `setState`。我们使用 `useState` 这个 Hook 来管理 state。

```jsx
import React, { useState } from 'react';

function Counter() {
  // 调用 useState Hook
  // 它返回一个数组：[当前状态值, 更新状态的函数]
  const [count, setCount] = useState(0); // 初始化 state

  const handleClick = () => {
    // 使用 setCount 更新 state
    setCount(count + 1);
  };

  return (
    <button onClick={handleClick}>
      Clicked {count} times
    </button>
  );
}
```

**`useState` 的工作原理**：
*   **数组解构**：`useState` 返回一个包含两个元素的数组，我们通过数组解构赋值给 `count` 和 `setCount`。这是一种常见的命名约定。
*   **状态保持**：React 通过组件对应的 Fiber 节点来存储每个 Hook 的状态。这意味着在组件的多次渲染之间，`useState` 能够“记住”上一次的状态值。
*   **更新函数**：`setCount` 的行为类似于 `setState`。调用它会触发组件的重新渲染。你也可以向它传递一个函数，以确保在多次连续更新时，总是基于最新的状态进行计算。

```jsx
// 安全的更新方式
setCount(prevCount => prevCount + 1);
```

## 5.3 单向数据流：一切变化的源泉

现在我们将 Props 和 State 结合起来，就构成了 React 应用的核心数据流动模式——**单向数据流**。

这条规则可以概括为：**数据总是从父组件流向子组件**。

![](https://miro.medium.com/v2/resize:fit:1400/1*5j2_2A5gQ7g2h2k3e9w3_A.png)

1.  **State 驱动视图**：一个组件的 state 变化，会触发该组件的重新渲染。
2.  **Props 向下传递**：父组件在渲染时，会将它的 state（或其他数据）作为 props 传递给子组件。
3.  **子组件被动接收**：子组件接收 props，并根据 props 的值来渲染自己的 UI。它不能直接修改 props。
4.  **事件向上传递**：如果子组件需要更新父组件的 state，它不能直接修改，而是通过调用父组件传递过来的函数（这个函数本身也是一个 prop）来“通知”父组件进行更新。

```jsx
function Parent() {
  const [message, setMessage] = useState('Hello from Parent');

  // 定义一个函数，通过 props 传递给子组件
  const handleMessageChange = (newMessage) => {
    setMessage(newMessage);
  };

  return (
    <div>
      <h1>{message}</h1>
      {/* 将 state 和更新函数作为 props 传递下去 */}
      <Child 
        message={message} 
        onMessageChange={handleMessageChange} 
      />
    </div>
  );
}

function Child({ message, onMessageChange }) {
  return (
    <button onClick={() => onMessageChange('Hello from Child')}>
      Change Message
    </button>
  );
}
```

在这个例子中，数据流向非常清晰：
*   `Parent` 的 `message` state 流向 `Child` 的 `message` prop。
*   `Child` 通过调用 `onMessageChange` prop（这个 prop 指向 `Parent` 的 `handleMessageChange` 函数）来“向上”通信，触发 `Parent` 的 state 更新。
*   `Parent` 的 state 更新后，重新渲染，新的 `message` 又会流向 `Child`。

### 5.3.1 单向数据流的优势

这种严格的数据流向带来了巨大的好处：

*   **可预测性**：你总是能知道数据来自哪里，将要去向哪里。应用的任何一部分状态，都可以追溯到其源头。
*   **易于调试**：当 UI 出现问题时，你可以顺着数据流反向追溯，很容易定位到是哪个组件的 state 出了问题。
*   **组件解耦**：子组件不关心父组件的状态是如何管理的，它只关心接收到的 props。这使得组件更加独立和可复用。

## 5.4 总结

React 应用的本质是一个由数据驱动的 UI 系统。在这个系统中：

*   **Props** 是组件的“输入”，是只读的，用于从父组件向子组件传递数据和配置。
*   **State** 是组件的“内部记忆”，是可变的，是触发组件自身重新渲染的直接原因。
*   **单向数据流** 是连接二者的规则，它规定了数据只能自上而下流动，而变更通知通过回调函数自下而上传递，保证了应用结构的清晰和可预测。

理解了 State 和 Props，你就掌握了驱动 React 应用运转的核心机制。在下一章，我们将深入探讨 React 为函数组件带来的革命性工具——Hooks，看看它们是如何以一种更优雅的方式处理状态和副作用的。