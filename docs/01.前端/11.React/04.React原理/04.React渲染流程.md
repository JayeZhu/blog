---
title: React渲染流程
date: 2025-10-20 06:19:13
permalink: /pages/10b3bf/
categories:
  - 前端
tags:
  - React
  - React原理
---

我们已经了解了 Virtual DOM 和 Diff 算法，它们是 React 高效更新 UI 的核心。但是，这些概念是如何串联起来，完成从我们编写 JSX 代码到最终页面呈现的完整过程的呢？这个过程的背后，是 React 引以为傲的 **Fiber 架构**。本章，我们将完整地追踪一个 React 应用的渲染与更新生命周期，揭开 Fiber 的神秘面纱。

## 4.1 一切的起点：JSX 的本质

我们每天都在写 JSX，它看起来像 HTML，但运行在浏览器中。浏览器原生并不认识 JSX，那么它究竟是如何工作的呢？

答案是：**JSX 只是一种语法糖**。

React 团队选择了一个巧妙的方式：在构建阶段，使用 **Babel** 这样的工具将 JSX 语法转换为纯粹的 JavaScript 函数调用。

例如，下面这段 JSX 代码：

```jsx
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);
```

经过 Babel 转换后，会变成：

```javascript
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
```

`React.createElement` 这个函数会接收三个参数：
1.  **元素类型**：`'h1'`（字符串表示 DOM 标签，也可以是组件类或函数）。
2.  **配置对象**：`{className: 'greeting'}`，对应 JSX 中的属性。
3.  **子元素**：`'Hello, world!'`，可以是字符串、其他的 `React.createElement` 调用，或者一个数组。

这个函数执行后，会返回我们在上一章提到的 **Virtual DOM 对象**。所以，我们写的 JSX，本质上就是在用一种更直观的方式去调用 `React.createElement`，从而构建 Virtual DOM 树。

## 4.2 Fiber 架构的引入：为何需要它？

在 React 16 之前，React 使用的是 **Stack Reconciler（栈协调）**算法。它的渲染过程是同步的、不可中断的。当 React 开始更新组件树时，它会一直执行直到整棵树遍历完毕，将所有变更应用到 DOM 上。

这种方式在简单的应用中运行良好，但一旦组件树变得庞大和复杂，问题就来了。

### 4.2.1 栈协调的困境：长任务阻塞

想象一下，你有一个包含数千个组件的复杂应用。当某个状态变化触发更新时，Stack Reconciler 会开始一个“长任务”，这个任务会持续占用主线程。

在浏览器中，主线程不仅要执行 JavaScript，还要处理用户交互、页面绘制等任务。如果 JavaScript 执行时间过长（通常超过 16ms），浏览器就无法及时响应用户的操作或更新画面，导致页面出现**卡顿**，也就是我们常说的“掉帧”。

![](https://miro.medium.com/v2/resize:fit:1400/1*9_5C5jM0sLxZk5x5x5x5xQ.png)

如图所示，一个长任务阻塞了主线程，导致用户的点击事件和浏览器的绘制都被延迟了，用户体验极差。Stack Reconciler 的“一口气做完”的策略，在复杂的现代 Web 应用中显得力不从心。

### 4.2.2 Fiber 的诞生：可中断的渲染

为了解决这个核心痛点，React 团队重构了整个协调算法，创造了 **Fiber**。

Fiber 的核心目标是：**将渲染工作分解成多个小单元，并允许在执行过程中随时暂停、移交主线程给高优先级任务（如用户输入），之后再恢复执行。**

这就好比把一个冗长的报告，分解成一个个小章节来写。你可以随时停下来去回复一封紧急邮件，然后再回来继续写报告。Fiber 为 React 带来了**优先级调度**和**时间切片**的能力，是 React 实现流畅交互体验的基石。

## 4.3 Fiber 是什么？一个轻量级的执行单元

那么，Fiber 到底是什么？它听起来很抽象，但本质上非常具体：

> **一个 Fiber 就是一个 JavaScript 对象，它代表了一个组件、一个 DOM 节点或其他工作单元。**

每个 Fiber 节点都包含了组件所需的所有信息，例如：

*   组件的类型和 `props`。
*   组件的 `state`。
*   指向父节点、子节点和兄弟节点的指针，构成一个**链表树结构**。

```javascript
// 一个简化的 Fiber 节点结构
const fiberNode = {
  // 组件类型
  type: 'div',
  // 组件的 props
  props: {},
  // 指向父 Fiber
  return: parentFiber,
  // 指向第一个子 Fiber
  child: childFiber,
  // 指向下一个兄弟 Fiber
  sibling: siblingFiber,
  // ... 其他信息，如 state、副作用标记等
};
```

这个**链表树结构**是 Fiber 实现可中断渲染的关键。因为树结构是递归的，难以暂停和恢复；而链表结构是线性的，我们只需要保存当前执行节点的引用，就可以随时暂停，并在之后从该引用处恢复执行。

## 4.4 渲染两大阶段：Reconciliation 与 Commit

基于 Fiber 架构，React 的渲染过程被清晰地划分为两个阶段：

### 4.4.1 Render/Reconciliation Phase (协调阶段)

这是 React “计算”变更的阶段。在这个阶段，React 会：

1.  **遍历 Fiber 树**：从根节点开始，沿着链表结构遍历。
2.  **执行组件函数**：对于函数组件，会执行它来获取最新的 JSX；对于类组件，会调用 `render` 方法。
3.  **计算 Diff**：将返回的 JSX（新的 Virtual DOM 树）与当前的 Fiber 树进行对比（即执行 Diff 算法）。
4.  **标记副作用**：如果发现节点需要更新、添加或删除，React 会在对应的 Fiber 节点上打上一个“副作用”标记。这个标记就像一个待办事项，告诉 React 这个节点在后续阶段需要进行某些操作。

**关键特性**：这个阶段是**可中断的**。React 会在每个 Fiber 节点执行后检查“时间片”是否用尽。如果用尽，或者有更高优先级的任务进来，React 就会暂停当前的工作，保存当前的执行状态，然后让出主线程。当它恢复工作时，可以从上次暂停的地方继续。

**重要**：在这个阶段，**所有的操作都在内存中进行，不涉及任何真实 DOM 的修改**。它是一个纯粹的“计算”过程。

### 4.4.2 Commit Phase (提交阶段)

当协调阶段完成后，我们有了一棵标记了所有副作用的 Fiber 树。接下来，React 会进入**提交阶段**。

在这个阶段，React 会：

1.  **遍历副作用链**：React 会根据之前标记的副作用，生成一个“副作用链”，它包含了所有需要执行 DOM 操作的节点。
2.  **一次性更新 DOM**：React 会遍历这个副作用链，并将所有计算出的变更**一次性地、同步地**应用到真实 DOM 上。

**关键特性**：这个阶段是**不可中断的**。因为直接操作 DOM，如果中途打断，可能会导致用户看到不完整的 UI 界面，造成视觉闪烁或数据不一致。因此，React 会一鼓作气完成所有 DOM 更新。

为了更精细地控制，提交阶段又被细分为三个子阶段：

1.  **`beforeMutation`**：在 DOM 更新之前执行。主要用于获取 DOM 更新前的信息，例如 `getSnapshotBeforeUpdate` 生命周期。
2.  **`mutation`**：执行真正的 DOM 操作（插入、更新、删除）。在这个阶段，React 会将变更应用到 DOM 树上，但此时浏览器还未绘制这些变更。
3.  **`layout`**：在 DOM 更新之后执行。此时，用户已经看不到任何 DOM 变化了。React 会在此阶段执行 `useLayoutEffect` 和 `componentDidMount`/`componentDidUpdate` 等生命周期。

## 4.5 完整流程总结

让我们把整个过程串起来：

1.  **触发更新**：你调用 `setState` 或 `useState` 的 setter 函数。
2.  **调度**：React 的调度器收到更新请求，根据优先级安排一个任务。
3.  **协调阶段**：
    *   React 开始执行任务，遍历 Fiber 树。
    *   重新执行组件函数，获取新的 JSX/Virtual DOM。
    *   进行 Diff 对比，在 Fiber 节点上标记副作用。
    *   这个过程可以被中断和恢复。
4.  **提交阶段**：
    *   协调阶段完成后，React 进入不可中断的提交阶段。
    *   `beforeMutation` -> `mutation` -> `layout`。
    *   将所有变更同步应用到真实 DOM，并执行相应的副作用钩子。
5.  **绘制**：浏览器接收到 DOM 变更，进行重绘，用户看到最终的界面。

这个从 JSX 到页面的完整链路，展示了 React 如何通过 Fiber 架构，将复杂的 UI 更新工作变得可控、高效且流畅。理解了这个流程，你就能更深刻地体会到 React 在性能和用户体验上的用心。