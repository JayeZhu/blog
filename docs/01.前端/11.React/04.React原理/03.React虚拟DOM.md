---
title: React虚拟DOM
date: 2025-10-20 06:08:34
permalink: /pages/32f498/
categories:
  - 前端
tags:
  - React
  - React原理
---
好的，这是为你撰写的第三章内容，遵循了 Markdown 格式。

---

# 第三章：虚拟 DOM (Virtual DOM) 与 Diff 算法

在上一章中，我们探讨了 React 的设计哲学，其中一个核心观点是：**我们只负责声明 UI 和 `state` 的映射关系，而将 DOM 更新的脏活累活交给 React**。那么，React 是如何高效地完成这项任务的呢？答案就藏在 **Virtual DOM** 和其核心的 **Diff 算法**之中。它们是 React 性能优化和跨平台能力的基石，本章我们将彻底揭开它们的神秘面纱。

## 3.1 什么是 Virtual DOM？

**Virtual DOM（虚拟 DOM）**，顾名思义，它不是真实的 DOM。它本质上是一个普通的 JavaScript 对象，用来描述真实 DOM 的结构和属性。

我们可以把它想象成真实 DOM 的“蓝图”或“副本”。当你用 JSX 编写一个组件时：

```jsx
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);
```

Babel 会将其转换成一个如下的 Virtual DOM 对象（简化版）：

```javascript
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world!'
  }
};
```

这个对象包含了所有构建真实 DOM 节点所需的信息：标签类型（`type`）、属性（`props`）和子元素（`children`）。React 维护着一棵由这些对象构成的 Virtual DOM 树，它与我们页面上的真实 DOM 树一一对应。

## 3.2 为什么需要 Virtual DOM？

直接操作真实的 DOM 到底有什么问题，以至于 React 要大费周章地引入一个中间层呢？主要原因有两点：

### 3.2.1 DOM 操作是“昂贵”的

在浏览器中，DOM 是一个非常复杂的对象。每一次对 DOM 的操作（如读取或修改属性、增删节点）都可能触发**浏览器的重排**或**重绘**，这个过程会消耗大量的计算资源。想象一下，如果我们频繁地、直接地去修改 DOM，就像在厨房里每切一刀都要洗一次手一样，低效且繁琐。

Virtual DOM 的出现，将这个“洗手的”过程变得极其高效：

1.  **批量更新**：当状态变化时，React 会先在内存中对 Virtual DOM 树进行修改，这个过程非常快，因为它只是 JavaScript 对象的计算。
2.  **Diff 计算**：React 会通过 Diff 算法，比较新旧两棵 Virtual DOM 树，找出最小的差异。
3.  **一次性打补丁**：最后，React 只将这些计算出的差异一次性地、批量地更新到真实 DOM 上。

这个过程就像你先在草稿纸上写好完整的修改方案，检查无误后，再一次性誊写到正式文件上，而不是边想边改。Virtual DOM 就是那张“草稿纸”，它将多次、零散的 DOM 操作合并为一次，大大提升了性能。

### 3.2.2 提供跨平台能力

我们之前提到，React 的核心价值之一是跨平台。Virtual DOM 在这里扮演了关键角色。

*   **Virtual DOM** 是对 UI 的抽象描述，它与具体的平台无关。
*   **Renderer（渲染器）** 负责将 Virtual DOM 树渲染到不同平台上。

![](https://miro.medium.com/v2/resize:fit:1400/1*5j2_2A5gQ7g2h2k3e9w3_A.png)

React 团队可以针对不同平台（Web、iOS、Android）开发不同的 Renderer。例如，在 Web 端，`react-dom` 负责将 Virtual DOM 转换为真实的 DOM；而在 Native 端，`react-native` 负责将其转换为原生的 UI 控件。开发者始终使用相同的 React API（即操作 Virtual DOM），而无需关心底层的渲染细节，完美实现了“Learn once, write anywhere”。

## 3.3 Diff 算法核心思想

现在我们知道了 Virtual DOM 的重要性，但还有一个关键问题：React 如何快速地找出新旧两棵 Virtual DOM 树之间的差异呢？这就是 **Diff 算法**要解决的问题。

### 3.3.1 从 O(n³) 到 O(n) 的优化

如果要对两棵树进行完整的、逐节点的对比，这是一个非常复杂的问题，其时间复杂度高达 **O(n³)**，其中 n 是树中节点的数量。对于一个包含 1000 个节点的应用，需要进行约 10 亿次比较，这在实际应用中是完全不可接受的。

React 的工程师们通过一个巧妙的洞察，将这个复杂度优化到了 **O(n)**。他们基于以下三个**假设**，制定了一套启发式算法：

1.  **不同类型的元素会产生不同的树**：如果一个元素的类型发生了变化（例如从 `<a>` 变为 `<img>`），React 会认为这整个子树都变了，会直接销毁旧树，创建新树，而不会去比较其内部。
2.  **开发者可以通过 `key` 来暗示哪些子元素是稳定的**：对于列表中的元素，React 无法通过位置判断它们是否是同一个。`key` 属性帮助 React 识别元素的身份。
3.  **只对同层级节点进行比较**：React 不会跨层级比较节点。如果发现父节点不同，它会直接替换整个子树。

### 3.3.2 Diff 策略详解

基于以上假设，React 的 Diff 策略可以分解为三个部分：

1.  **Tree Diff**：对 Virtual DOM 树进行分层比较。React 只会对比同一层级内的节点，跨层级的节点会被视为整体替换。
2.  **Component Diff**：如果是组件类型，对比两个组件的类型。如果类型不同，则认为整个组件都变了，替换掉整个组件实例。如果类型相同，则暂时保留该组件实例，继续深入比较其 `props`。
3.  **Element Diff**：当处于同一层级且都是 DOM 元素时，进行详细的属性和子节点对比。这是最复杂的一步，尤其是对于列表类型的子节点。

## 3.4 `key` 的魔力：高效更新列表

在 Element Diff 中，处理子节点列表是最具挑战性的。如果没有 `key`，React 的默认行为是按顺序对比新旧列表中的子节点。

让我们通过一个经典的**列表重排**例子来理解 `key` 的重要性。

### 3.4.1 没有 `key` 的灾难

假设我们有一个列表，初始状态是 `['A', 'B', 'C']`，现在要在中间插入一个 `'D'`，变成 `['A', 'D', 'B', 'C']`。

**没有 `key` 的情况下，React 的 Diff 过程是这样的：**

*   **对比第一个子节点**：旧 `A` vs 新 `A` -> 相同，保留。
*   **对比第二个子节点**：旧 `B` vs 新 `D` -> **不同**！React 会认为第二个元素从 `B` 变成了 `D`，于是它会修改 DOM，把 `<li>B</li>` 改成 `<li>D</li>`。
*   **对比第三个子节点**：旧 `C` vs 新 `B` -> **不同**！React 会认为第三个元素从 `C` 变成了 `B`，于是修改 DOM，把 `<li>C</li>` 改成 `<li>B</li>`。
*   **新增节点**：React 发现新列表多了一个节点，于是在末尾创建一个新的 `<li>C</li>`。

**结果**：React 执行了 2 次修改和 1 次创建。明明只是一个简单的插入操作，却导致了大量不必要的 DOM 更新。

### 3.4.2 `key` 的救场

现在，我们给每个列表项加上一个唯一的 `key`，这个 `key` 就是它们的内容本身。

```jsx
// 旧列表
<ul>
  <li key="A">A</li>
  <li key="B">B</li>
  <li key="C">C</li>
</ul>

// 新列表
<ul>
  <li key="A">A</li>
  <li key="D">D</li>
  <li key="B">B</li>
  <li key="C">C</li>
</ul>
```

**有了 `key` 之后，React 的 Diff 过程完全不同了：**

*   **遍历旧列表**：
    *   找到 `key="A"` 的元素，在新列表中也找到了，位置没变，保留。
    *   找到 `key="B"` 的元素，在新列表中也找到了，但位置变了（从 index 1 变成了 index 2）。
    *   找到 `key="C"` 的元素，在新列表中也找到了，位置也变了（从 index 2 变成了 index 3）。
*   **遍历新列表**：
    *   找到 `key="D"` 的元素，在旧列表中不存在，这是一个新元素，需要创建。

**结果**：React 识别出 `'A'` 保持不变，`'B'` 和 `'C'` 只是移动了位置，`'D'` 是新增的。于是，它只需要执行 1 次创建和 2 次移动 DOM 节点的操作。这比之前的 2 次修改和 1 次创建要高效得多，尤其是当列表项是复杂组件时，避免了不必要的重新渲染和销毁。

### 3.4.3 关于 `key` 的最佳实践

*   **保持唯一和稳定**：`key` 必须在列表中是唯一的，并且在多次渲染间保持稳定。不要使用 `Math.random()` 或数组索引 `index` 作为 `key`，因为它们不稳定，会导致 React 无法正确识别元素，反而降低性能。
*   **来源**：通常，`key` 应该使用来自你的数据的一个唯一标识符，比如数据库中的 ID。

```jsx
// 好的做法
todos.map(todo => (
  <li key={todo.id}>
    {todo.text}
  </li>
));

// 不好的做法
todos.map((todo, index) => (
  <li key={index}>
    {todo.text}
  </li>
));
```

## 3.5 总结

Virtual DOM 和 Diff 算法是 React 性能优化的核心。它们通过以下方式协同工作：

1.  **Virtual DOM** 作为真实 DOM 的轻量级 JavaScript 抽象，让我们可以高效地进行 UI 计算，并提供了跨平台的能力。
2.  **Diff 算法** 通过三个核心假设，将复杂的树对比问题从 O(n³) 优化到 O(n)，使得 Virtual DOM 的更新变得可行。
3.  **`key`** 是 Diff 算法处理列表时的“导航仪”，它能帮助 React 识别元素的移动、新增和删除，从而进行最高效的 DOM 操作。

理解了 Virtual DOM 的工作原理，你就明白了 React 为什么能够如此高效地管理复杂的用户界面。在下一章，我们将深入探讨 React 的渲染流程，看看这些概念是如何在 Fiber 架构中落地执行的。