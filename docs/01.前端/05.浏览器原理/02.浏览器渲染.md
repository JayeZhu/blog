---
title: 浏览器渲染
date: 2021-06-04 12:16:20
permalink: /pages/dc8dd1/
categories:
  - 前端
tags:
  - 浏览器原理
---
## 浏览器渲染基本步骤
浏览器主要有以下步骤：
- 浏览器通过HTTP协议向服务端请求页面数据
- 将请求回来的HTML文件解析成DOM树
- 将请求回来的CSS文件解析成CSSOM树
- 将DOM树和CSSOM树结合在一起，生成渲染树（render tree）
- 计算渲染树的布局，这实际上是回流的过程
- 将布局渲染到屏幕上，这实际上是重绘的过程
### 构建DOM树
当打开一个网页时，浏览器都会去请求对应的 HTML 文件。虽然平时我们写代码时都会分为 JS、CSS、HTML 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。

当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记（token），这一过程在词法分析中叫做标记化（tokenization）。

简单来说，标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。

当结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树。
以上就是浏览器从网络中接收到 HTML 文件然后一系列的转换过程。
当然，在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件，接下来就看看浏览器如何解析 CSS 文件。

注意：在解析过程中，如果遇到 `<script>` 就会停止页面的解析，先执行标签中的JavaScript代码，如果代码时外联的形式，也需要等待外联的JavaScript代码下载并执行完才继续执行解析HTML的工作，解析完HTML文件之后，就会触发DOMContentLoaded 事件，这时就可以操作DOM了。
### 构建CSSOM树
其实转换 CSS 到 CSSOM 树的过程和DOM树的渲染过程是极其类似的：

在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。

那为什么会消耗资源呢？来看个例子
```html
<div>
  <a> <span></span> </a>
</div>
<style>
  span {
    color: red;
  }
  div > a > span {
    color: red;
  }
</style>
```
对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。

CSS解析为CSSStyleSheet（也就是CSSOM树）的过程如下：

CSS是一种渲染阻塞资源(render blocking resource)，它需要完全被解析完毕之后才能进入生成渲染树的环节。

由于CSS有些属性具有继承性，后面定义的样式可能会覆盖或修改前面的样式，所以只有当所有的CSS代码都执行渲染完之后才能进入下一个环节。在CSSOM构建完成之前，页面都会处于白屏状态，所以，一般都是在文件的头部引入CSS文件。

### 构建渲染树
DOM 树包含的结构内容与 CSSOM 树包含的样式规则都是独立的，为了更方便渲染，先需要将它们合并成一棵渲染树。这个过程会从 DOM 树的根节点开始遍历，然后在 CSSOM 树上找到每个节点对应的样式。

遍历过程中会自动忽略那些不需要渲染的节点（比如脚本标记、元标记等）以及不可见的节点（比如设置了“display:none”样式）。同时也会将一些需要显示的伪类元素加到渲染树中。

在合并生成渲染树的过程中，有以下几点需要注意：
- 元素如果被设置为 display:none，在 DOM 树中依然会显示，但是在 Render 树中不会显示；
- 元素如果被设置为 visibility:none，那么 DOM 树和 Render 树中都会显示；
- 脱离文档流值得就是脱离 Render Tree。

### 计算渲染树的布局
生成了渲染树之后，就可以进入布局阶段了，布局就是计算元素的大小及位置。

计算元素布局是一个比较复杂的操作，因为需要考虑的因素有很多，包括字体大小、换行位置等，这些因素会影响段落的大小和形状，进而影响下一个段落的位置。

布局完成后会输出对应的“盒模型”，它会精确地捕获每个元素的确切位置和大小，将所有相对值都转换为屏幕上的绝对像素。

### 将布局渲染到屏幕上
绘制就是将渲染树中的每个节点转换成屏幕上的实际像素的过程。得到布局树这份“施工图”之后，渲染引擎并不能立即绘制，因为还不知道绘制顺序，如果没有弄清楚绘制顺序，那么很可能会导致页面被错误地渲染。

例如，对于使用 z-index 属性的元素（如遮罩层）如果未按照正确的顺序绘制，则将导致渲染结果和预期不符（失去遮罩作用）。
所以绘制过程中的第一步就是遍历布局树，生成绘制记录，然后渲染引擎会根据绘制记录去绘制相应的内容。

对于无动画效果的情况，只需要考虑空间维度，生成不同的图层，然后再把这些图层进行合成，最终成为我们看到的页面。当然这个绘制过程并不是静态不变的，会随着页面滚动不断合成新的图形。

上述五个步骤都是浏览器渲染进程中的GUI渲染线程完成的。

GUI渲染线程主要的工作如下：
• 负责渲染浏览器页面，解析HTML、CSS，构建DOM树、CSSOM树、渲染树和绘制页面
• 当界面需要重绘或由于某种操作引发回流时，该线程就会执行

## 重排和重绘
浏览器渲染过程中就会存在重排和重绘，需要避免。

### 重排
重排也叫回流啊，其实就是渲染过程中的布局，常见的引起重排的方式有：
- 添加或者删除可见的 DOM 元素
- 元素位置改变 - diaplay、float、position、overflow 等
- 元素尺寸改变 - padding、margin、border、width 和 height
- 内容改变 - 比如文本改变或者图片大小改变而引起的计算值宽度和高度改变
- 页面渲染初始化
- 浏览器窗口尺寸改变 - resize

### 重绘
重排一定会引起重绘，但重绘不一定会引起重排，一般更改元素的属性会引起重绘
- color
- background
- outline
- border-radius、border-style
- box-shaow

### 减少重排重绘
- 避免使用 table 布局
- 避免逐行更改样式，可以通过更改 class 一次性更改样式
- 避免循环操作 dom，可以创建 documentFragment，在它上面操作后，添加到 window.document
- 将鱼杂元素绝对定位，脱离文档流
- 可以将元素先不显示，操作完后再显示