---
title: 浏览器事件机制
date: 2021-06-04 12:21:21
permalink: /pages/f96432/
categories:
  - 前端
tags:
  - 浏览器原理
---
## 事件
事件就是用户操作网页时发生的交互动作或者网页本身的一些操作

## 事件流
事件流描述了页面接收事情的顺序

### 事件冒泡
IE 事件被称为事件冒泡，这是因为事件被定义为从最基本的元素开始出发，然后向上传播

### 事件捕获
事件捕获是 iwndow 网事件处发出传播，入到注册的捕获事件会触发
## 事件模型
JS 发展到现在经历了 DOM0、IE、DOM2

### DOM0 事件模型
这种模型不会传播，没有事件流的概念。但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 ks 属性来指定监听函数。所以有浏览器兼容这种方式，直接在 dom 对象上注册时间名称

### IE 事件模型
IE 事件包括事件处理和事件冒泡阶段。首先执行事件处理阶段，即执行目标元素绑定的监听事件，然后事件冒泡，一直到 document，遇到绑定的监听事件就执行。

IE 事件模型通过 attachEvent 添加监听函数，通过 cancelBubble 取消冒泡。

### DOM2 事件模型
DOM2 有三个过程：事件捕获，事件处理和事件冒泡。后面两个和 IE一样，不同的是事件捕获：指事件从 document 向下一直传播到目标元素，遇到绑定的监听函数就执行。

DOM2 通过 addEventListener 添加事件。

## 事件代理
事件代理本质上是利用事件冒泡的机制，将子节点的监听函数绑定到父节点上，通过父节点的监听函数统一处理多个子元素的事件。

### 事件代理的优缺点
首先优点：
- 减少内存消耗：将事件绑定到多个子元素上比绑定到一个父元素上会消耗更多内存
- 动态绑定事件：动态生成的子元素需要绑定监听函数很麻烦，而绑定到父元素上就很方便
缺点：
- focus、blur 等事件没有事件冒泡机制，不能使用
- mousemove、mouseeout 等事件虽然有事件冒泡，但是需要不断通过位置来计算定位，对性能消耗高，不适合事件代理

## 同步与异步
- 同步指的是当一个进程在执行某个请求时，这个请求会等段时间才返回，那么进程就会一直等下去，阻塞后续代码执行
- 异步指的是当一个进程在执行某个请求时，这个请求要等段时间才返回，但进行不会等下去，会让后面代码执行，等消息返回时系统再通知进程来处理。

## 事件循环
JS 代码执行过程中，除了依靠函数调用栈来搞定函数执行顺序外，还依靠任务队列来搞定异步函数的执行，整个执行过程，称为事件循环过程。

事件循环中有两种任务：宏任务与微任务。
### 宏任务
宏任务包括：
- script
- setTimeout
- setInterval
- I/O
- UI render

### 微任务
微任务包括：
- process.nextTick
- Promise
- Async/await
- MutationObserver
### 浏览器事件循环
浏览器事件循环机制如下：
- 首先整段代码作为宏任务执行
- 执行过程中同步代码执行，宏任务进入宏任务队列，微任务进入微任务队列
- 当前宏任务执行完出队，检查微任务队列，如果有就依次执行，知道微任务队列为空
- 执行浏览器 UI 线程的渲染工作
- 检查是否有 Web worker 任务，有则执行
- 执行队首新的宏任务，回到第二步，一次循环，直到宏任务和微任务队列为空
### Node 事件循环
Node 事件循环机制如下：
- timer：执行定时器的回调函数
- I/O 错误回调阶段
- 空闲预备阶段
- poll：
  - 首先检查有没有计时器到事件了，有就进入 timer 阶段
  - 没有的话检查回调函数队列，有则一次执行
  - 没有的话检查有没有 setImmediate 的回调函数，有则进入 check 节点
  - 没有的话继续等待一段时间，如有有回调函数进入队列就执行，没有就进入 check 阶段
  - check：执行 setImmediate 的回调函数
  - close：关闭事件的回调阶段

### 浏览器事件循环和 Node 事件循环
- 浏览器的微任务在宏任务队列后面执行
- Node 的微任务在各个阶段执行