(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{516:function(s,t,a){"use strict";a.r(t);var n=a(16),r=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"路由模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由模式"}},[s._v("#")]),s._v(" 路由模式")]),s._v(" "),a("p",[s._v("Vue-Router 有两种路由模式：hash 模式和 history 模式。")]),s._v(" "),a("h2",{attrs:{id:"hash-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-模式"}},[s._v("#")]),s._v(" hash 模式")]),s._v(" "),a("p",[s._v("hash 模式是 vue 开发的默认模式，会在 URL 中附带 #，如 "),a("code",[s._v("http://www.a.com/#/login")]),s._v("，其 hash 值就是 #/login")]),s._v(" "),a("h3",{attrs:{id:"hash-模式的特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-模式的特点"}},[s._v("#")]),s._v(" hash 模式的特点")]),s._v(" "),a("ul",[a("li",[s._v("不影响后端：hash 模式会有 hash 值，它出现在 URL 里，但不会出现在 HTTP 里，因此，不会影响到后端")]),s._v(" "),a("li",[s._v("不重载：改变 hash 值，不会重新加载页面")]),s._v(" "),a("li",[s._v("兼容性好：hash 模式对浏览器支持度较好，低版本的 IE 浏览器也支持这个模式")]),s._v(" "),a("li",[s._v("用于 SPA：hash 被称为前端路由，是 SPA 的标配")])]),s._v(" "),a("h3",{attrs:{id:"hash-模式原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-模式原理"}},[s._v("#")]),s._v(" hash 模式原理")]),s._v(" "),a("p",[s._v("hash 模式主要原理是 onhashchange 事件")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("window"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("onhashchange")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("event")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("event"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("oldURL"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" event"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("newURL"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" hash "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" location"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("slice")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("使用 onhashchange 的好处在于，页面 hash 值发生变化时，无需向后端发起请求，window 就可以检测事件的改变，并按照规则加载相应的代码。")]),s._v(" "),a("p",[s._v("除此之外，hash 值变化对应的 URL 都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。实现没有请求后端服务器的请求跨，将 hash 与 URL 关联。")]),s._v(" "),a("h2",{attrs:{id:"history-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#history-模式"}},[s._v("#")]),s._v(" history 模式")]),s._v(" "),a("p",[s._v("history 模式的 URL 没有 #，比如 "),a("code",[s._v("http://www.a.com/user/id")]),s._v("，")]),s._v(" "),a("h3",{attrs:{id:"history-模式的特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#history-模式的特点"}},[s._v("#")]),s._v(" history 模式的特点")]),s._v(" "),a("ul",[a("li",[s._v("比 hash 好看：history 不带 #")]),s._v(" "),a("li",[s._v("需要后台匹配：history 会向后台发送请求，需要后台匹配支持，匹配不上就返回 404")])]),s._v(" "),a("h3",{attrs:{id:"history-模式的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#history-模式的原理"}},[s._v("#")]),s._v(" history 模式的原理")]),s._v(" "),a("p",[s._v("history 模式使用的是传统的路由分发模式：在用户输入 url 时，服务器会接受这个请求，并解析 URL，返回资源或 404，内部通过 history API 实现大部分功能：")]),s._v(" "),a("ul",[a("li",[s._v("修改历史状态：\n"),a("ul",[a("li",[s._v("pushState：新增")]),s._v(" "),a("li",[s._v("replaceState：替换")])])]),s._v(" "),a("li",[s._v("切换历史状态：\n"),a("ul",[a("li",[s._v("forward")]),s._v(" "),a("li",[s._v("back")]),s._v(" "),a("li",[s._v("go")])])])]),s._v(" "),a("h2",{attrs:{id:"hash-模式与-history-模式的对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-模式与-history-模式的对比"}},[s._v("#")]),s._v(" hash 模式与 history 模式的对比")]),s._v(" "),a("ul",[a("li",[s._v("hash 模式只能修改 # 后面的部分，也就是设置与当前 URL 同文档的 URL；而 history 可通过 pushState 设置同源的任意 URL")]),s._v(" "),a("li",[s._v("hash 模式设置新值比如与原来的值不一样才会将记录添加到栈中；而 history 通过 pushState，在新 URL 与当前一致时也会加入栈中")]),s._v(" "),a("li",[s._v("hahs 只能添加段字符串，history 能通过 pushState 的 stateObject 参数添加任意类型数据到记录中")]),s._v(" "),a("li",[s._v("history 可通过 pushState 添加 title")]),s._v(" "),a("li",[s._v("hash 在路由变更时不会而没有匹配路由时，不会有 404 错误；而 history 会在后台返回 404")]),s._v(" "),a("li",[s._v("hash 模式路由变更不需要向后台发送请求；而 history 模式需要")])])])}),[],!1,null,null,null);t.default=r.exports}}]);