(window.webpackJsonp=window.webpackJsonp||[]).push([[144],{499:function(t,v,_){"use strict";_.r(v);var s=_(8),r=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"同步与异步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步与异步"}},[t._v("#")]),t._v(" 同步与异步")]),t._v(" "),v("p",[t._v("Node.js 的异步特性是其核心灵魂，也是它高性能的关键所在。简单来说，Node.js 的异步编程是一种编程模式，它允许程序在等待诸如文件读写、网络请求等耗时操作完成的同时，继续处理其他任务，而不是干等着什么都不做。")]),t._v(" "),v("p",[t._v("它和同步的区别")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("特性")]),t._v(" "),v("th",[t._v("同步模式 (Synchronous)")]),t._v(" "),v("th",[t._v("异步模式 (Asynchronous)")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("执行方式")]),t._v(" "),v("td",[v("strong",[t._v("顺序执行")]),t._v("：一个任务完成后，才能开始下一个任务。")]),t._v(" "),v("td",[v("strong",[t._v("并发执行")]),t._v("：发起一个任务后，无需等待其完成，立即继续执行后续代码。")])]),t._v(" "),v("tr",[v("td",[t._v("线程阻塞")]),t._v(" "),v("td",[v("strong",[t._v("阻塞")]),t._v("：在执行耗时操作（如读取大文件）时，整个线程会被挂起，无法处理其他请求。")]),t._v(" "),v("td",[v("strong",[t._v("非阻塞")]),t._v("：主线程不会因耗时操作而停滞，可以继续处理其他任务，操作完成后通过回调等方式通知。")])]),t._v(" "),v("tr",[v("td",[t._v("性能与资源")]),t._v(" "),v("td",[t._v("资源利用率较低，尤其在I/O密集型场景下，线程大量时间处于空闲等待状态。")]),t._v(" "),v("td",[t._v("资源利用率高，单线程即可处理大量并发连接，特别适合I/O密集型应用。")])]),t._v(" "),v("tr",[v("td",[t._v("代码风格")]),t._v(" "),v("td",[t._v("代码流程直观，符合线性思维。")]),t._v(" "),v("td",[t._v("代码流程非线性的，需要通过回调、Promise或async/await来管理执行顺序。")])])])]),t._v(" "),v("h2",{attrs:{id:"事件循环"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),v("p",[t._v("Node.js 的异步能力建立在 ​事件循环​ 机制之上。你可以将事件循环想象成一个永不休息的“调度员”，它在一个循环中不断检查是否有新的任务需要处理。")])])}),[],!1,null,null,null);v.default=r.exports}}]);