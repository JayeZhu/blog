(window.webpackJsonp=window.webpackJsonp||[]).push([[149],{501:function(t,s,a){"use strict";a.r(s);var e=a(8),r=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("我们已经了解了 Virtual DOM 和 Diff 算法，它们是 React 高效更新 UI 的核心。但是，这些概念是如何串联起来，完成从我们编写 JSX 代码到最终页面呈现的完整过程的呢？这个过程的背后，是 React 引以为傲的 "),s("strong",[t._v("Fiber 架构")]),t._v("。本章，我们将完整地追踪一个 React 应用的渲染与更新生命周期，揭开 Fiber 的神秘面纱。")]),t._v(" "),s("h2",{attrs:{id:"_4-1-一切的起点-jsx-的本质"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-一切的起点-jsx-的本质"}},[t._v("#")]),t._v(" 4.1 一切的起点：JSX 的本质")]),t._v(" "),s("p",[t._v("我们每天都在写 JSX，它看起来像 HTML，但运行在浏览器中。浏览器原生并不认识 JSX，那么它究竟是如何工作的呢？")]),t._v(" "),s("p",[t._v("答案是："),s("strong",[t._v("JSX 只是一种语法糖")]),t._v("。")]),t._v(" "),s("p",[t._v("React 团队选择了一个巧妙的方式：在构建阶段，使用 "),s("strong",[t._v("Babel")]),t._v(" 这样的工具将 JSX 语法转换为纯粹的 JavaScript 函数调用。")]),t._v(" "),s("p",[t._v("例如，下面这段 JSX 代码：")]),t._v(" "),s("div",{staticClass:"language-jsx line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-jsx"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" element "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("h1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("className")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("greeting"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("\n    Hello, world!\n  ")]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("h1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[t._v("经过 Babel 转换后，会变成：")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" element "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" React"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'h1'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("className")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'greeting'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Hello, world!'")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[s("code",[t._v("React.createElement")]),t._v(" 这个函数会接收三个参数：")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("元素类型")]),t._v("："),s("code",[t._v("'h1'")]),t._v("（字符串表示 DOM 标签，也可以是组件类或函数）。")]),t._v(" "),s("li",[s("strong",[t._v("配置对象")]),t._v("："),s("code",[t._v("{className: 'greeting'}")]),t._v("，对应 JSX 中的属性。")]),t._v(" "),s("li",[s("strong",[t._v("子元素")]),t._v("："),s("code",[t._v("'Hello, world!'")]),t._v("，可以是字符串、其他的 "),s("code",[t._v("React.createElement")]),t._v(" 调用，或者一个数组。")])]),t._v(" "),s("p",[t._v("这个函数执行后，会返回我们在上一章提到的 "),s("strong",[t._v("Virtual DOM 对象")]),t._v("。所以，我们写的 JSX，本质上就是在用一种更直观的方式去调用 "),s("code",[t._v("React.createElement")]),t._v("，从而构建 Virtual DOM 树。")]),t._v(" "),s("h2",{attrs:{id:"_4-2-fiber-架构的引入-为何需要它"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-fiber-架构的引入-为何需要它"}},[t._v("#")]),t._v(" 4.2 Fiber 架构的引入：为何需要它？")]),t._v(" "),s("p",[t._v("在 React 16 之前，React 使用的是 **Stack Reconciler（栈协调）**算法。它的渲染过程是同步的、不可中断的。当 React 开始更新组件树时，它会一直执行直到整棵树遍历完毕，将所有变更应用到 DOM 上。")]),t._v(" "),s("p",[t._v("这种方式在简单的应用中运行良好，但一旦组件树变得庞大和复杂，问题就来了。")]),t._v(" "),s("h3",{attrs:{id:"_4-2-1-栈协调的困境-长任务阻塞"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-1-栈协调的困境-长任务阻塞"}},[t._v("#")]),t._v(" 4.2.1 栈协调的困境：长任务阻塞")]),t._v(" "),s("p",[t._v("想象一下，你有一个包含数千个组件的复杂应用。当某个状态变化触发更新时，Stack Reconciler 会开始一个“长任务”，这个任务会持续占用主线程。")]),t._v(" "),s("p",[t._v("在浏览器中，主线程不仅要执行 JavaScript，还要处理用户交互、页面绘制等任务。如果 JavaScript 执行时间过长（通常超过 16ms），浏览器就无法及时响应用户的操作或更新画面，导致页面出现"),s("strong",[t._v("卡顿")]),t._v("，也就是我们常说的“掉帧”。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://miro.medium.com/v2/resize:fit:1400/1*9_5C5jM0sLxZk5x5x5x5xQ.png",alt:""}})]),t._v(" "),s("p",[t._v("如图所示，一个长任务阻塞了主线程，导致用户的点击事件和浏览器的绘制都被延迟了，用户体验极差。Stack Reconciler 的“一口气做完”的策略，在复杂的现代 Web 应用中显得力不从心。")]),t._v(" "),s("h3",{attrs:{id:"_4-2-2-fiber-的诞生-可中断的渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-2-fiber-的诞生-可中断的渲染"}},[t._v("#")]),t._v(" 4.2.2 Fiber 的诞生：可中断的渲染")]),t._v(" "),s("p",[t._v("为了解决这个核心痛点，React 团队重构了整个协调算法，创造了 "),s("strong",[t._v("Fiber")]),t._v("。")]),t._v(" "),s("p",[t._v("Fiber 的核心目标是："),s("strong",[t._v("将渲染工作分解成多个小单元，并允许在执行过程中随时暂停、移交主线程给高优先级任务（如用户输入），之后再恢复执行。")])]),t._v(" "),s("p",[t._v("这就好比把一个冗长的报告，分解成一个个小章节来写。你可以随时停下来去回复一封紧急邮件，然后再回来继续写报告。Fiber 为 React 带来了"),s("strong",[t._v("优先级调度")]),t._v("和"),s("strong",[t._v("时间切片")]),t._v("的能力，是 React 实现流畅交互体验的基石。")]),t._v(" "),s("h2",{attrs:{id:"_4-3-fiber-是什么-一个轻量级的执行单元"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-fiber-是什么-一个轻量级的执行单元"}},[t._v("#")]),t._v(" 4.3 Fiber 是什么？一个轻量级的执行单元")]),t._v(" "),s("p",[t._v("那么，Fiber 到底是什么？它听起来很抽象，但本质上非常具体：")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("一个 Fiber 就是一个 JavaScript 对象，它代表了一个组件、一个 DOM 节点或其他工作单元。")])])]),t._v(" "),s("p",[t._v("每个 Fiber 节点都包含了组件所需的所有信息，例如：")]),t._v(" "),s("ul",[s("li",[t._v("组件的类型和 "),s("code",[t._v("props")]),t._v("。")]),t._v(" "),s("li",[t._v("组件的 "),s("code",[t._v("state")]),t._v("。")]),t._v(" "),s("li",[t._v("指向父节点、子节点和兄弟节点的指针，构成一个"),s("strong",[t._v("链表树结构")]),t._v("。")])]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一个简化的 Fiber 节点结构")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" fiberNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 组件类型")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'div'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 组件的 props")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("props")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向父 Fiber")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" parentFiber"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向第一个子 Fiber")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("child")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" childFiber"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向下一个兄弟 Fiber")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("sibling")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" siblingFiber"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ... 其他信息，如 state、副作用标记等")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br")])]),s("p",[t._v("这个"),s("strong",[t._v("链表树结构")]),t._v("是 Fiber 实现可中断渲染的关键。因为树结构是递归的，难以暂停和恢复；而链表结构是线性的，我们只需要保存当前执行节点的引用，就可以随时暂停，并在之后从该引用处恢复执行。")]),t._v(" "),s("h2",{attrs:{id:"_4-4-渲染两大阶段-reconciliation-与-commit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-渲染两大阶段-reconciliation-与-commit"}},[t._v("#")]),t._v(" 4.4 渲染两大阶段：Reconciliation 与 Commit")]),t._v(" "),s("p",[t._v("基于 Fiber 架构，React 的渲染过程被清晰地划分为两个阶段：")]),t._v(" "),s("h3",{attrs:{id:"_4-4-1-render-reconciliation-phase-协调阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-1-render-reconciliation-phase-协调阶段"}},[t._v("#")]),t._v(" 4.4.1 Render/Reconciliation Phase (协调阶段)")]),t._v(" "),s("p",[t._v("这是 React “计算”变更的阶段。在这个阶段，React 会：")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("遍历 Fiber 树")]),t._v("：从根节点开始，沿着链表结构遍历。")]),t._v(" "),s("li",[s("strong",[t._v("执行组件函数")]),t._v("：对于函数组件，会执行它来获取最新的 JSX；对于类组件，会调用 "),s("code",[t._v("render")]),t._v(" 方法。")]),t._v(" "),s("li",[s("strong",[t._v("计算 Diff")]),t._v("：将返回的 JSX（新的 Virtual DOM 树）与当前的 Fiber 树进行对比（即执行 Diff 算法）。")]),t._v(" "),s("li",[s("strong",[t._v("标记副作用")]),t._v("：如果发现节点需要更新、添加或删除，React 会在对应的 Fiber 节点上打上一个“副作用”标记。这个标记就像一个待办事项，告诉 React 这个节点在后续阶段需要进行某些操作。")])]),t._v(" "),s("p",[s("strong",[t._v("关键特性")]),t._v("：这个阶段是"),s("strong",[t._v("可中断的")]),t._v("。React 会在每个 Fiber 节点执行后检查“时间片”是否用尽。如果用尽，或者有更高优先级的任务进来，React 就会暂停当前的工作，保存当前的执行状态，然后让出主线程。当它恢复工作时，可以从上次暂停的地方继续。")]),t._v(" "),s("p",[s("strong",[t._v("重要")]),t._v("：在这个阶段，"),s("strong",[t._v("所有的操作都在内存中进行，不涉及任何真实 DOM 的修改")]),t._v("。它是一个纯粹的“计算”过程。")]),t._v(" "),s("h3",{attrs:{id:"_4-4-2-commit-phase-提交阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-2-commit-phase-提交阶段"}},[t._v("#")]),t._v(" 4.4.2 Commit Phase (提交阶段)")]),t._v(" "),s("p",[t._v("当协调阶段完成后，我们有了一棵标记了所有副作用的 Fiber 树。接下来，React 会进入"),s("strong",[t._v("提交阶段")]),t._v("。")]),t._v(" "),s("p",[t._v("在这个阶段，React 会：")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("遍历副作用链")]),t._v("：React 会根据之前标记的副作用，生成一个“副作用链”，它包含了所有需要执行 DOM 操作的节点。")]),t._v(" "),s("li",[s("strong",[t._v("一次性更新 DOM")]),t._v("：React 会遍历这个副作用链，并将所有计算出的变更"),s("strong",[t._v("一次性地、同步地")]),t._v("应用到真实 DOM 上。")])]),t._v(" "),s("p",[s("strong",[t._v("关键特性")]),t._v("：这个阶段是"),s("strong",[t._v("不可中断的")]),t._v("。因为直接操作 DOM，如果中途打断，可能会导致用户看到不完整的 UI 界面，造成视觉闪烁或数据不一致。因此，React 会一鼓作气完成所有 DOM 更新。")]),t._v(" "),s("p",[t._v("为了更精细地控制，提交阶段又被细分为三个子阶段：")]),t._v(" "),s("ol",[s("li",[s("strong",[s("code",[t._v("beforeMutation")])]),t._v("：在 DOM 更新之前执行。主要用于获取 DOM 更新前的信息，例如 "),s("code",[t._v("getSnapshotBeforeUpdate")]),t._v(" 生命周期。")]),t._v(" "),s("li",[s("strong",[s("code",[t._v("mutation")])]),t._v("：执行真正的 DOM 操作（插入、更新、删除）。在这个阶段，React 会将变更应用到 DOM 树上，但此时浏览器还未绘制这些变更。")]),t._v(" "),s("li",[s("strong",[s("code",[t._v("layout")])]),t._v("：在 DOM 更新之后执行。此时，用户已经看不到任何 DOM 变化了。React 会在此阶段执行 "),s("code",[t._v("useLayoutEffect")]),t._v(" 和 "),s("code",[t._v("componentDidMount")]),t._v("/"),s("code",[t._v("componentDidUpdate")]),t._v(" 等生命周期。")])]),t._v(" "),s("h2",{attrs:{id:"_4-5-完整流程总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-完整流程总结"}},[t._v("#")]),t._v(" 4.5 完整流程总结")]),t._v(" "),s("p",[t._v("让我们把整个过程串起来：")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("触发更新")]),t._v("：你调用 "),s("code",[t._v("setState")]),t._v(" 或 "),s("code",[t._v("useState")]),t._v(" 的 setter 函数。")]),t._v(" "),s("li",[s("strong",[t._v("调度")]),t._v("：React 的调度器收到更新请求，根据优先级安排一个任务。")]),t._v(" "),s("li",[s("strong",[t._v("协调阶段")]),t._v("：\n"),s("ul",[s("li",[t._v("React 开始执行任务，遍历 Fiber 树。")]),t._v(" "),s("li",[t._v("重新执行组件函数，获取新的 JSX/Virtual DOM。")]),t._v(" "),s("li",[t._v("进行 Diff 对比，在 Fiber 节点上标记副作用。")]),t._v(" "),s("li",[t._v("这个过程可以被中断和恢复。")])])]),t._v(" "),s("li",[s("strong",[t._v("提交阶段")]),t._v("：\n"),s("ul",[s("li",[t._v("协调阶段完成后，React 进入不可中断的提交阶段。")]),t._v(" "),s("li",[s("code",[t._v("beforeMutation")]),t._v(" -> "),s("code",[t._v("mutation")]),t._v(" -> "),s("code",[t._v("layout")]),t._v("。")]),t._v(" "),s("li",[t._v("将所有变更同步应用到真实 DOM，并执行相应的副作用钩子。")])])]),t._v(" "),s("li",[s("strong",[t._v("绘制")]),t._v("：浏览器接收到 DOM 变更，进行重绘，用户看到最终的界面。")])]),t._v(" "),s("p",[t._v("这个从 JSX 到页面的完整链路，展示了 React 如何通过 Fiber 架构，将复杂的 UI 更新工作变得可控、高效且流畅。理解了这个流程，你就能更深刻地体会到 React 在性能和用户体验上的用心。")])])}),[],!1,null,null,null);s.default=r.exports}}]);