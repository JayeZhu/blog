(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{533:function(v,_,t){"use strict";t.r(_);var a=t(16),e=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件"}},[v._v("#")]),v._v(" 事件")]),v._v(" "),t("p",[v._v("事件就是用户操作网页时发生的交互动作或者网页本身的一些操作")]),v._v(" "),t("h2",{attrs:{id:"事件流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件流"}},[v._v("#")]),v._v(" 事件流")]),v._v(" "),t("p",[v._v("事件流描述了页面接收事情的顺序")]),v._v(" "),t("h3",{attrs:{id:"事件冒泡"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件冒泡"}},[v._v("#")]),v._v(" 事件冒泡")]),v._v(" "),t("p",[v._v("IE 事件被称为事件冒泡，这是因为事件被定义为从最基本的元素开始出发，然后向上传播")]),v._v(" "),t("h3",{attrs:{id:"事件捕获"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件捕获"}},[v._v("#")]),v._v(" 事件捕获")]),v._v(" "),t("p",[v._v("事件捕获是 iwndow 网事件处发出传播，入到注册的捕获事件会触发")]),v._v(" "),t("h2",{attrs:{id:"事件模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件模型"}},[v._v("#")]),v._v(" 事件模型")]),v._v(" "),t("p",[v._v("JS 发展到现在经历了 DOM0、IE、DOM2")]),v._v(" "),t("h3",{attrs:{id:"dom0-事件模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dom0-事件模型"}},[v._v("#")]),v._v(" DOM0 事件模型")]),v._v(" "),t("p",[v._v("这种模型不会传播，没有事件流的概念。但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 ks 属性来指定监听函数。所以有浏览器兼容这种方式，直接在 dom 对象上注册时间名称")]),v._v(" "),t("h3",{attrs:{id:"ie-事件模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ie-事件模型"}},[v._v("#")]),v._v(" IE 事件模型")]),v._v(" "),t("p",[v._v("IE 事件包括事件处理和事件冒泡阶段。首先执行事件处理阶段，即执行目标元素绑定的监听事件，然后事件冒泡，一直到 document，遇到绑定的监听事件就执行。")]),v._v(" "),t("p",[v._v("IE 事件模型通过 attachEvent 添加监听函数，通过 cancelBubble 取消冒泡。")]),v._v(" "),t("h3",{attrs:{id:"dom2-事件模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dom2-事件模型"}},[v._v("#")]),v._v(" DOM2 事件模型")]),v._v(" "),t("p",[v._v("DOM2 有三个过程：事件捕获，事件处理和事件冒泡。后面两个和 IE一样，不同的是事件捕获：指事件从 document 向下一直传播到目标元素，遇到绑定的监听函数就执行。")]),v._v(" "),t("p",[v._v("DOM2 通过 addEventListener 添加事件。")]),v._v(" "),t("h2",{attrs:{id:"事件代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件代理"}},[v._v("#")]),v._v(" 事件代理")]),v._v(" "),t("p",[v._v("事件代理本质上是利用事件冒泡的机制，将子节点的监听函数绑定到父节点上，通过父节点的监听函数统一处理多个子元素的事件。")]),v._v(" "),t("h3",{attrs:{id:"事件代理的优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件代理的优缺点"}},[v._v("#")]),v._v(" 事件代理的优缺点")]),v._v(" "),t("p",[v._v("首先优点：")]),v._v(" "),t("ul",[t("li",[v._v("减少内存消耗：将事件绑定到多个子元素上比绑定到一个父元素上会消耗更多内存")]),v._v(" "),t("li",[v._v("动态绑定事件：动态生成的子元素需要绑定监听函数很麻烦，而绑定到父元素上就很方便\n缺点：")]),v._v(" "),t("li",[v._v("focus、blur 等事件没有事件冒泡机制，不能使用")]),v._v(" "),t("li",[v._v("mousemove、mouseeout 等事件虽然有事件冒泡，但是需要不断通过位置来计算定位，对性能消耗高，不适合事件代理")])]),v._v(" "),t("h2",{attrs:{id:"同步与异步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步与异步"}},[v._v("#")]),v._v(" 同步与异步")]),v._v(" "),t("ul",[t("li",[v._v("同步指的是当一个进程在执行某个请求时，这个请求会等段时间才返回，那么进程就会一直等下去，阻塞后续代码执行")]),v._v(" "),t("li",[v._v("异步指的是当一个进程在执行某个请求时，这个请求要等段时间才返回，但进行不会等下去，会让后面代码执行，等消息返回时系统再通知进程来处理。")])]),v._v(" "),t("h2",{attrs:{id:"事件循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[v._v("#")]),v._v(" 事件循环")]),v._v(" "),t("p",[v._v("JS 代码执行过程中，除了依靠函数调用栈来搞定函数执行顺序外，还依靠任务队列来搞定异步函数的执行，整个执行过程，称为事件循环过程。")]),v._v(" "),t("p",[v._v("事件循环中有两种任务：宏任务与微任务。")]),v._v(" "),t("h3",{attrs:{id:"宏任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#宏任务"}},[v._v("#")]),v._v(" 宏任务")]),v._v(" "),t("p",[v._v("宏任务包括：")]),v._v(" "),t("ul",[t("li",[v._v("script")]),v._v(" "),t("li",[v._v("setTimeout")]),v._v(" "),t("li",[v._v("setInterval")]),v._v(" "),t("li",[v._v("I/O")]),v._v(" "),t("li",[v._v("UI render")])]),v._v(" "),t("h3",{attrs:{id:"微任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#微任务"}},[v._v("#")]),v._v(" 微任务")]),v._v(" "),t("p",[v._v("微任务包括：")]),v._v(" "),t("ul",[t("li",[v._v("process.nextTick")]),v._v(" "),t("li",[v._v("Promise")]),v._v(" "),t("li",[v._v("Async/await")]),v._v(" "),t("li",[v._v("MutationObserver")])]),v._v(" "),t("h3",{attrs:{id:"浏览器事件循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器事件循环"}},[v._v("#")]),v._v(" 浏览器事件循环")]),v._v(" "),t("p",[v._v("浏览器事件循环机制如下：")]),v._v(" "),t("ul",[t("li",[v._v("首先整段代码作为宏任务执行")]),v._v(" "),t("li",[v._v("执行过程中同步代码执行，宏任务进入宏任务队列，微任务进入微任务队列")]),v._v(" "),t("li",[v._v("当前宏任务执行完出队，检查微任务队列，如果有就依次执行，知道微任务队列为空")]),v._v(" "),t("li",[v._v("执行浏览器 UI 线程的渲染工作")]),v._v(" "),t("li",[v._v("检查是否有 Web worker 任务，有则执行")]),v._v(" "),t("li",[v._v("执行队首新的宏任务，回到第二步，一次循环，直到宏任务和微任务队列为空")])]),v._v(" "),t("h3",{attrs:{id:"node-事件循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-事件循环"}},[v._v("#")]),v._v(" Node 事件循环")]),v._v(" "),t("p",[v._v("Node 事件循环机制如下：")]),v._v(" "),t("ul",[t("li",[v._v("timer：执行定时器的回调函数")]),v._v(" "),t("li",[v._v("I/O 错误回调阶段")]),v._v(" "),t("li",[v._v("空闲预备阶段")]),v._v(" "),t("li",[v._v("poll：\n"),t("ul",[t("li",[v._v("首先检查有没有计时器到事件了，有就进入 timer 阶段")]),v._v(" "),t("li",[v._v("没有的话检查回调函数队列，有则一次执行")]),v._v(" "),t("li",[v._v("没有的话检查有没有 setImmediate 的回调函数，有则进入 check 节点")]),v._v(" "),t("li",[v._v("没有的话继续等待一段时间，如有有回调函数进入队列就执行，没有就进入 check 阶段")]),v._v(" "),t("li",[v._v("check：执行 setImmediate 的回调函数")]),v._v(" "),t("li",[v._v("close：关闭事件的回调阶段")])])])]),v._v(" "),t("h3",{attrs:{id:"浏览器事件循环和-node-事件循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器事件循环和-node-事件循环"}},[v._v("#")]),v._v(" 浏览器事件循环和 Node 事件循环")]),v._v(" "),t("ul",[t("li",[v._v("浏览器的微任务在宏任务队列后面执行")]),v._v(" "),t("li",[v._v("Node 的微任务在各个阶段执行")])])])}),[],!1,null,null,null);_.default=e.exports}}]);