(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{448:function(a,e,v){"use strict";v.r(e);var r=v(8),t=Object(r.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"什么是浏览器缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是浏览器缓存"}},[a._v("#")]),a._v(" 什么是浏览器缓存")]),a._v(" "),e("p",[a._v("浏览器缓存就是在第一次请求资源完成后，根据相应的缓存机制，将一些静态资源存储在浏览器缓存里，在下一次请求资源时，可以从本地缓存中提取文件，而不需要再次获取服务器返回的资源。")]),a._v(" "),e("h2",{attrs:{id:"为什么需要浏览器缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要浏览器缓存"}},[a._v("#")]),a._v(" 为什么需要浏览器缓存")]),a._v(" "),e("p",[a._v("浏览器缓存因为不需要重新获取资源，因此有以下优点：")]),a._v(" "),e("p",[a._v("浏览器缓存分为"),e("strong",[a._v("强缓存")]),a._v("和"),e("strong",[a._v("协商缓存")])]),a._v(" "),e("h2",{attrs:{id:"强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[a._v("#")]),a._v(" 强缓存")]),a._v(" "),e("p",[a._v("强缓存是不需要发送 HTTP 请求的，在 HTTP1.0 和 HTTP 1.1 中体现方式不一样")]),a._v(" "),e("h3",{attrs:{id:"expires"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[a._v("#")]),a._v(" Expires")]),a._v(" "),e("p",[a._v("在 HTTP 1.0 中，使用 Expires 设置强缓存的具体过期时间")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Expires: Fri Jun 04 2021 15:37:32 GMT\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("意味着到了这个时间，强缓存就是失效，将发送 HTTP 请求到服务端。但是存在问题：浏览器时间可能与服务器时间不一致，导致缓存失败，因此在 HTTP 1.1 被摒弃了。")]),a._v(" "),e("h3",{attrs:{id:"cache-control"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[a._v("#")]),a._v(" Cache-Control")]),a._v(" "),e("p",[a._v("HTTP 1.1 使用 Cache-Control 来替代 Expires，它通过 max-age 设置过期延迟时长")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Cache-Control: max-age=3600\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("这表示 1h 后过期。使用 Cache-Control 更合理，在于 Expires 一起存在时，优先级高于 Expires。")]),a._v(" "),e("h3",{attrs:{id:"expires-与-cache-control-的不同点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#expires-与-cache-control-的不同点"}},[a._v("#")]),a._v(" Expires 与 Cache-Control 的不同点")]),a._v(" "),e("ul",[e("li",[a._v("版本：Expires 基于 HTTP/1.0；Cache-Control 基于 HTTP/1.1")]),a._v(" "),e("li",[a._v("方式：Expries 设定过期具体时间；Cache-Control 设定过期延长时间")]),a._v(" "),e("li",[a._v("严谨：Expires 设置过期时间可能因服务器与客户端时间不一样而产生误差，Cache-Control 不会")]),a._v(" "),e("li",[a._v("优先级：Cache-Control 优先于 Expires")])]),a._v(" "),e("h2",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[a._v("#")]),a._v(" 协商缓存")]),a._v(" "),e("p",[a._v("协商缓存需要向服务器发送 HTTP 请求，缓存命中，服务器返回 304，否则返回请求结果。")]),a._v(" "),e("p",[a._v("协商缓存通过缓存标识（Tag）来识别是否采用缓存，分为两种：Last-Modified 和 ETag")]),a._v(" "),e("h3",{attrs:{id:"last-modified"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified"}},[a._v("#")]),a._v(" Last-Modified")]),a._v(" "),e("p",[a._v("Last-Modified 代表资源的最后修改时间，配合 If-Modified-Since 使用：")]),a._v(" "),e("ul",[e("li",[a._v("浏览器第一次向服务器请求资源")]),a._v(" "),e("li",[a._v("服务器在返回资源时，在响应头中添加 Last-Modified 字段，其值为该资源在服务器最后修改时间")]),a._v(" "),e("li",[a._v("浏览器接收资源后缓存资源以及 Last-Modified 字段")]),a._v(" "),e("li",[a._v("浏览器再次请求该资源时，检测到缓存有 Last-Modified，会在请求头附带 If-Modified-Since 字段，字段值为 Last-Modified 值")]),a._v(" "),e("li",[a._v("服务器再次接收到该资源请求，根据 If-Modified-Since 与该资源在服务器的最后修改时间做对比")]),a._v(" "),e("li",[a._v("对比相同则返回 304 和空响应体")]),a._v(" "),e("li",[a._v("对比不同则返回 200、最新资源以及新的 Last-Modified")])]),a._v(" "),e("h3",{attrs:{id:"etag"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[a._v("#")]),a._v(" ETag")]),a._v(" "),e("p",[a._v("ETag 与 Last-Modified 类似，不过他采用标识对比，配合 If-None-Match 使用")]),a._v(" "),e("ul",[e("li",[a._v("浏览器第一次向服务器请求资源")]),a._v(" "),e("li",[a._v("服务器返回该资源时，在响应头添加服务器生成的 ETag 字段")]),a._v(" "),e("li",[a._v("浏览器接收资源后缓存资源和 ETag")]),a._v(" "),e("li",[a._v("浏览器再次请求该资源时，检测到缓存有 ETag，将值放入请求头中的 If-None-Match 发给服务器")]),a._v(" "),e("li",[a._v("服务器再次接收到该资源请求，根据资源 ETag 和接收到的 If-None-Match 作对比")]),a._v(" "),e("li",[a._v("对比相同则返回 304 和空响应体")]),a._v(" "),e("li",[a._v("对比不同则返回 200、最新资源以及新的 ETag")])]),a._v(" "),e("h3",{attrs:{id:"last-modified-与-etag-的不同点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-与-etag-的不同点"}},[a._v("#")]),a._v(" Last-Modified 与 ETag 的不同点")]),a._v(" "),e("ul",[e("li",[a._v("准确度：ETag 准确度高于 Last-Mofidied\n"),e("ul",[e("li",[a._v("本地缓存文件打开未修改，会改变最后修改时间")]),a._v(" "),e("li",[a._v("文件在极短时间内修改多次，但显示未修改")])])]),a._v(" "),e("li",[a._v("性能：Last-Modified 优于 ETag\n"),e("ul",[e("li",[a._v("Last-Modified 只需存储传输时间")]),a._v(" "),e("li",[a._v("ETag 随文件修改，需要通过服务器通过算法计算 hash 值")])])]),a._v(" "),e("li",[a._v("优先度：ETag 优于 Last-Modified")])]),a._v(" "),e("h2",{attrs:{id:"缓存位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存位置"}},[a._v("#")]),a._v(" 缓存位置")]),a._v(" "),e("p",[a._v("前面介绍清缓存和协商缓存命中后，就会从浏览器缓存中获取资源，那么这些缓存存在哪里呢？")]),a._v(" "),e("p",[a._v("缓存因优先级分为四种：")]),a._v(" "),e("ul",[e("li",[a._v("Service Worker")]),a._v(" "),e("li",[a._v("Memory Cache")]),a._v(" "),e("li",[a._v("Disk Cache")]),a._v(" "),e("li",[a._v("Push Cache")])]),a._v(" "),e("h3",{attrs:{id:"service-worker"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#service-worker"}},[a._v("#")]),a._v(" Service Worker")]),a._v(" "),e("p",[a._v("Service Worker 是一种独立于主线程之外的 JS 线程，他通过 Service Worker Cache 实现离线缓存。它的特点：")]),a._v(" "),e("ul",[e("li",[a._v("缓存时持续性的")]),a._v(" "),e("li",[a._v("可以自由选择缓存哪些文件，如何匹配读取缓存")]),a._v(" "),e("li",[a._v("HTTPS 协议下使用")])]),a._v(" "),e("h3",{attrs:{id:"memory-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#memory-cache"}},[a._v("#")]),a._v(" Memory Cache")]),a._v(" "),e("p",[a._v("Memory Cache 代表内存上的缓存，主要存储当前页面已将抓取到的资源，如样式、脚本、图片等。它具有以下特点：")]),a._v(" "),e("ul",[e("li",[a._v("读取效率快，但缓存持续时间短，会随着进程的释放而释放")]),a._v(" "),e("li",[a._v("几乎所有的请求资源都能够进入 Memory Cache，并且主要分为 preloader 和 preload 两部分\n"),e("ul",[e("li",[a._v("preloader：实现浏览器打卡网页时，边解析执行 js/css，边下载资源。而下载的资源被 Memory Cache 缓存")]),a._v(" "),e("li",[a._v("preload：显式指定预加载的资源，并将其缓存进 Memory Cache")])])]),a._v(" "),e("li",[a._v("从 Memory Cache 读取缓存时，浏览器会忽视 Cache-Control 中的除 no-store 以外的一些 max-age、no-cache 等头部配置")])]),a._v(" "),e("h3",{attrs:{id:"disk-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#disk-cache"}},[a._v("#")]),a._v(" Disk Cache")]),a._v(" "),e("p",[a._v("也叫 HTTP Cache，代表硬盘上的缓存，它覆盖面很广。具有以下特点：")]),a._v(" "),e("ul",[e("li",[a._v("读取效率慢，储蓄存储，存储在文件系统中")]),a._v(" "),e("li",[a._v("它的缓存附带面最大，通过 HTTP header 字段判断哪些需要缓存，哪些过期需要重新获取")])]),a._v(" "),e("p",[a._v("本文提到的强缓存和协商缓存都属于 Disk Cache")]),a._v(" "),e("p",[a._v("相比于 Memory Cache：")]),a._v(" "),e("ul",[e("li",[a._v("文件较大的 JS、CSS 文件进入 Disk Cache")]),a._v(" "),e("li",[a._v("系统使用率较高，优先进入 Disk Cache")])]),a._v(" "),e("h3",{attrs:{id:"push-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#push-cache"}},[a._v("#")]),a._v(" Push Cache")]),a._v(" "),e("p",[a._v("又叫 推送缓存，以上缓存未正确命中才会使用，它的特点是：")]),a._v(" "),e("ul",[e("li",[a._v("缓存时间短，仅存在与会话阶段，当 session 终止时，缓存释放")]),a._v(" "),e("li",[a._v("当以上三种未命中，它才会使用，是缓存最后一道防线")]),a._v(" "),e("li",[a._v("缓存只能使用一次")]),a._v(" "),e("li",[a._v("HTTP/2 协议下使用")])]),a._v(" "),e("h2",{attrs:{id:"引用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[a._v("#")]),a._v(" 引用")]),a._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/104486657",target:"_blank",rel:"noopener noreferrer"}},[a._v("系统总结浏览器缓存"),e("OutboundLink")],1)]),a._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/LinDaiDai/niubility-coding-js/blob/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/%E9%9C%96%E5%91%86%E5%91%86%E4%BD%A0%E6%9D%A5%E8%AF%B4%E8%AF%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%90%A7.md",target:"_blank",rel:"noopener noreferrer"}},[a._v("霖呆呆你来说说浏览器缓存吧"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=t.exports}}]);