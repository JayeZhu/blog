(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{516:function(t,s,a){"use strict";a.r(s);var n=a(15),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"浏览器渲染基本步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染基本步骤"}},[t._v("#")]),t._v(" 浏览器渲染基本步骤")]),t._v(" "),a("p",[t._v("浏览器主要有以下步骤：")]),t._v(" "),a("ul",[a("li",[t._v("浏览器通过HTTP协议向服务端请求页面数据")]),t._v(" "),a("li",[t._v("将请求回来的HTML文件解析成DOM树")]),t._v(" "),a("li",[t._v("将请求回来的CSS文件解析成CSSOM树")]),t._v(" "),a("li",[t._v("将DOM树和CSSOM树结合在一起，生成渲染树（render tree）")]),t._v(" "),a("li",[t._v("计算渲染树的布局，这实际上是回流的过程")]),t._v(" "),a("li",[t._v("将布局渲染到屏幕上，这实际上是重绘的过程")])]),t._v(" "),a("h2",{attrs:{id:"构建dom树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构建dom树"}},[t._v("#")]),t._v(" 构建DOM树")]),t._v(" "),a("p",[t._v("当打开一个网页时，浏览器都会去请求对应的 HTML 文件。虽然平时我们写代码时都会分为 JS、CSS、HTML 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。")]),t._v(" "),a("p",[t._v("当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记（token），这一过程在词法分析中叫做标记化（tokenization）。")]),t._v(" "),a("p",[t._v("简单来说，标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。")]),t._v(" "),a("p",[t._v("当结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树。\n以上就是浏览器从网络中接收到 HTML 文件然后一系列的转换过程。\n当然，在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件，接下来就看看浏览器如何解析 CSS 文件。")]),t._v(" "),a("p",[t._v("注意：在解析过程中，如果遇到 "),a("code",[t._v("<script>")]),t._v(" 就会停止页面的解析，先执行标签中的JavaScript代码，如果代码时外联的形式，也需要等待外联的JavaScript代码下载并执行完才继续执行解析HTML的工作，解析完HTML文件之后，就会触发DOMContentLoaded 事件，这时就可以操作DOM了。")]),t._v(" "),a("h2",{attrs:{id:"构建cssom树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构建cssom树"}},[t._v("#")]),t._v(" 构建CSSOM树")]),t._v(" "),a("p",[t._v("其实转换 CSS 到 CSSOM 树的过程和DOM树的渲染过程是极其类似的：")]),t._v(" "),a("p",[t._v("在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。")]),t._v(" "),a("p",[t._v("那为什么会消耗资源呢？来看个例子")]),t._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("span")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("span")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("style")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token style"}},[a("span",{pre:!0,attrs:{class:"token language-css"}},[t._v("\n  "),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("span")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" red"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div > a > span")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" red"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("style")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br")])]),a("p",[t._v("对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。")]),t._v(" "),a("p",[t._v("CSS解析为CSSStyleSheet（也就是CSSOM树）的过程如下：")]),t._v(" "),a("p",[t._v("CSS是一种渲染阻塞资源(render blocking resource)，它需要完全被解析完毕之后才能进入生成渲染树的环节。")]),t._v(" "),a("p",[t._v("由于CSS有些属性具有继承性，后面定义的样式可能会覆盖或修改前面的样式，所以只有当所有的CSS代码都执行渲染完之后才能进入下一个环节。在CSSOM构建完成之前，页面都会处于白屏状态，所以，一般都是在文件的头部引入CSS文件。")]),t._v(" "),a("h2",{attrs:{id:"构建渲染树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构建渲染树"}},[t._v("#")]),t._v(" 构建渲染树")]),t._v(" "),a("p",[t._v("DOM 树包含的结构内容与 CSSOM 树包含的样式规则都是独立的，为了更方便渲染，先需要将它们合并成一棵渲染树。这个过程会从 DOM 树的根节点开始遍历，然后在 CSSOM 树上找到每个节点对应的样式。")]),t._v(" "),a("p",[t._v("遍历过程中会自动忽略那些不需要渲染的节点（比如脚本标记、元标记等）以及不可见的节点（比如设置了“display:none”样式）。同时也会将一些需要显示的伪类元素加到渲染树中。")]),t._v(" "),a("p",[t._v("在合并生成渲染树的过程中，有以下几点需要注意：")]),t._v(" "),a("ul",[a("li",[t._v("元素如果被设置为 display:none，在 DOM 树中依然会显示，但是在 Render 树中不会显示；")]),t._v(" "),a("li",[t._v("元素如果被设置为 visibility:none，那么 DOM 树和 Render 树中都会显示；")]),t._v(" "),a("li",[t._v("脱离文档流值得就是脱离 Render Tree。")])]),t._v(" "),a("h2",{attrs:{id:"计算渲染树的布局"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算渲染树的布局"}},[t._v("#")]),t._v(" 计算渲染树的布局")]),t._v(" "),a("p",[t._v("生成了渲染树之后，就可以进入布局阶段了，布局就是计算元素的大小及位置。")]),t._v(" "),a("p",[t._v("计算元素布局是一个比较复杂的操作，因为需要考虑的因素有很多，包括字体大小、换行位置等，这些因素会影响段落的大小和形状，进而影响下一个段落的位置。")]),t._v(" "),a("p",[t._v("布局完成后会输出对应的“盒模型”，它会精确地捕获每个元素的确切位置和大小，将所有相对值都转换为屏幕上的绝对像素。")]),t._v(" "),a("h2",{attrs:{id:"将布局渲染到屏幕上"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#将布局渲染到屏幕上"}},[t._v("#")]),t._v(" 将布局渲染到屏幕上")]),t._v(" "),a("p",[t._v("绘制就是将渲染树中的每个节点转换成屏幕上的实际像素的过程。得到布局树这份“施工图”之后，渲染引擎并不能立即绘制，因为还不知道绘制顺序，如果没有弄清楚绘制顺序，那么很可能会导致页面被错误地渲染。")]),t._v(" "),a("p",[t._v("例如，对于使用 z-index 属性的元素（如遮罩层）如果未按照正确的顺序绘制，则将导致渲染结果和预期不符（失去遮罩作用）。\n所以绘制过程中的第一步就是遍历布局树，生成绘制记录，然后渲染引擎会根据绘制记录去绘制相应的内容。")]),t._v(" "),a("p",[t._v("对于无动画效果的情况，只需要考虑空间维度，生成不同的图层，然后再把这些图层进行合成，最终成为我们看到的页面。当然这个绘制过程并不是静态不变的，会随着页面滚动不断合成新的图形。")]),t._v(" "),a("p",[t._v("上述五个步骤都是浏览器渲染进程中的GUI渲染线程完成的。")]),t._v(" "),a("p",[t._v("GUI渲染线程主要的工作如下：\n• 负责渲染浏览器页面，解析HTML、CSS，构建DOM树、CSSOM树、渲染树和绘制页面\n• 当界面需要重绘或由于某种操作引发回流时，该线程就会执行")])])}),[],!1,null,null,null);s.default=e.exports}}]);